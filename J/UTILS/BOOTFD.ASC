asm {
#define BOOT_ADDRESS	0x040000
#define BLK_SIZE	0x200
#define J_XSUM		0xA5CF3796
#define BOOT_HIGH_LOC	((0xA0000-2*BLK_SIZE)/16)

#define BOOT_CODE_FLOPPY	1
#define BOOT_CODE_HARDDRIVE	2
#define BOOT_CODE_CDROM		3
#define BOOT_CODE_RAM		4

	USE16
BFD_START::
	DB	0x42 DUP(0);
BFD_CODE::
	CLI
	CLD
	MOV	AX,0xB800
	MOV	FS,AX
	MOV	AX,BOOT_HIGH_LOC
	MOV	SS,AX
	MOV	ES,AX
	MOV	SP,2*BLK_SIZE
	STI

	CALL	GET_IP
GET_IP:
	POP	BX
	SUB	BX,GET_IP
	SAR	BX,4
	MOV	AX,CS		//COPY HIGH
	ADD	AX,BX
	MOV	DS,AX
	MOV	CX,BLK_SIZE
	XOR	SI,SI
	XOR	DI,DI
	REP_MOVSB

	XOR	AX,AX
	XOR	DX,DX
	INT	0x13

	DB	0xEA;
	DW	BFD_RESTART,BOOT_HIGH_LOC;

BFD_RESTART::
	MOV	CX,512	       //patched with Blk cnt
	MOV	DX,512	       //patched with sector#
	MOV	AX,BOOT_ADDRESS/16
	MOV	GS,AX
	PUSH	AX

BFD_LOOP:
	PUSH	CX

	MOV	AH,0x70
	MOV	AL,CH
	CALL	CVTHEX
	MOV	WORD  FS:[0],AX
	MOV	AL,CL
	SHR	AL,4
	CALL	CVTHEX
	MOV	WORD  FS:[2],AX
	MOV	AL,CL
	CALL	CVTHEX
	MOV	WORD  FS:[4],AX

	MOV	AX,DX
	PUSH	DX
	XOR	DX,DX
	MOV	BX,18
	DIV	BX
	MOV	CL,DL		//CL=sector
	INC	CL
	MOV	DH,AL
	AND	DH,1		//DH=head
	SHR	AX,1
	MOV	CH,AL		//CH=cyl
	XOR	DL,DL		//DL=Drive
	MOV	AX,GS
	MOV	ES,AX
	ADD	AX,BLK_SIZE/16
	PUSH	AX
	XOR	BX,BX		//ES:[BX]=buf
	MOV	AH,2		//AH=read code
	MOV	AL,1		//1 blk
	PUSH	FS
	PUSH	GS

	INT	0x13

	POP	GS
	POP	FS

	POP	GS
	POP	DX
	INC	DX
	POP	CX
	LOOP	BFD_JMP_BACK

//Check CheckSum
	POP	DS
	XOR	ESI,ESI
	MOV	ECX,DWORD 8[ESI]
	SHR	ECX,4
	MOV	EBX,J_XSUM
@@10:	LODSD
	XOR	EBX,EAX
	LODSD
	XOR	EBX,EAX
	LODSD
	XOR	EBX,EAX
	LODSD
	XOR	EBX,EAX
	XOR	ESI,ESI
	MOV	AX,DS
	INC	AX
	MOV	DS,AX
	LOOP	@@10
	OR	EBX,EBX
	JNZ	WORD BFD_RESTART

	MOV	EBX,BOOT_CODE_FLOPPY
	DB	0xEA;
BFD_JMP_START::
	DW	0,BOOT_ADDRESS/16;
BFD_JMP_BACK:
	JMP	WORD BFD_LOOP
CVTHEX: AND	AL,15
	CMP	AL,9
	JBE	@@1
	ADD	AL,'A'-'9'-1
@@1:	ADD	AL,'0'
	RET
BFD_END::
	END
}