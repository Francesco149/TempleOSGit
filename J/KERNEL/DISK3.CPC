void LockPartition(JPartition *p)
{
  JBlkDev *bdev=p->bdev;
  CheckJPartition(p);
  if (p->owning_task!=Fs) {
    while (Bts(&p->flags,MPEf_LOCKED))
      SwapInNext;
    if (bdev->type==JBDT_FDC)
      FDCGet(bdev);
    p->owning_task=Fs;
  }
}

void UnlockPartition(JPartition *p)
{
  JBlkDev *bdev=p->bdev;
  CheckJPartition(p);
  if (p->owning_task==Fs) {
    p->owning_task=0;
    if (bdev->type==JBDT_FDC)
      FDCFree(bdev);
    Btr(&p->flags,MPEf_LOCKED);
  }
}


void AllocFATBuf(JPartition *p,int num_blks)
{
  CheckJPartition(p);
  RFree(p->cur_FAT_blk);
  RFree(p->buffered_FAT_dirty_bits);
  p->num_buffered_FAT_blks=num_blks;
  p->cur_FAT_blk=RMAlloc(BLK_SIZE*num_blks);
  p->buffered_FAT_dirty_bits=RMAllocZ((num_blks+7)/8);
  p->cur_FAT_blk_num=0;
  RBlks(p,p->cur_FAT_blk,p->FAT1,p->num_buffered_FAT_blks,FALSE);
}


void CleanFATBuf(JPartition *p,int fat_select=-1)
{
  DWORD i;
  if (fat_select==-1 || fat_select==0) {
    for (i=0;i<p->num_buffered_FAT_blks;i++)
      if (Bt(p->buffered_FAT_dirty_bits,i))
	WBlks(p,p->cur_FAT_blk+i*BLK_SIZE,p->FAT1+i+p->cur_FAT_blk_num,1,FALSE);
  }
  if (fat_select==-1 || fat_select==1) {
    for (i=0;i<p->num_buffered_FAT_blks;i++)
      if (Btr(p->buffered_FAT_dirty_bits,i))
	WBlks(p,p->cur_FAT_blk+i*BLK_SIZE,p->FAT2+i+p->cur_FAT_blk_num,1,FALSE);
  }
}

void InvalidateFATBuf(JPartition *p)
{
  p->cur_FAT_blk_num=0xFFFFFFFF;
}


void SetFAT32Buf(JPartition *p,DWORD c,int fat_select=-1)
{
  DWORD FAT_blk_num=c/(BLK_SIZE/4);
  if (FAT_blk_num!=p->cur_FAT_blk_num) {
    CleanFATBuf(p,fat_select);
    p->cur_FAT_blk_num=FAT_blk_num;
    if (fat_select==-1 || fat_select==0)
      RBlks(p,p->cur_FAT_blk,p->FAT1+p->cur_FAT_blk_num,1,FALSE);
    else
      RBlks(p,p->cur_FAT_blk,p->FAT2+p->cur_FAT_blk_num,1,FALSE);
  }
}

void InitFAT12Partition(JPartition *p)
{
  p->type=PT_FAT12;
  p->spc=fd_boot_template.SectorsPerCluster;
  p->offset=0;
  p->FAT1=1;
  p->FAT2=1+fd_boot_template.SectorsPerFAT;
  p->root_cluster=p->FAT2+fd_boot_template.SectorsPerFAT;
  p->data=p->root_cluster+(fd_boot_template.MaxRootEntries*sizeof(FAT12DirEntry)+BLK_SIZE-1)/BLK_SIZE
    -2*p->spc;
  p->root_cluster-=p->data;
  AllocFATBuf(p,fd_boot_template.SectorsPerFAT);
}

void InitFAT32Partition(JPartition *p)
{
  FAT32BootStruct br32;

  p->type=PT_FAT32;
  RBlks(p,&br32,p->offset,1,FALSE);
  p->file_system_info_sector=p->offset+br32.file_system_info_sector;
  p->FAT1=p->offset+br32.reserved_sectors;
  p->FAT2=p->FAT1+br32.sectors_per_FAT;
  p->data=p->FAT2+br32.sectors_per_FAT-2*br32.sectors_per_cluster; //Starts at Cluster 2
  p->spc=br32.sectors_per_cluster;
  p->root_cluster=br32.root_cluster;
  AllocFATBuf(p,1);
  RFree(p->fis);
  p->fis=RMAlloc(BLK_SIZE);
  RBlks(p,p->fis,p->file_system_info_sector,1,FALSE);
}

void InitISOPartition(JPartition *p)
{
  DWORD i=16;
  ISOPrimaryDescriptor *iso=MAlloc(CD_BLK_SIZE);
  ISODirEntry *de;

  p->type=PT_ISO9660;
  p->spc=CD_BLK_SIZE/BLK_SIZE;
  p->size=CD_FILE_OFFSET;
  while (TRUE) {
    RBlks(p,iso,i*p->spc,p->spc,FALSE);
    if (iso->type==ISOT_PRIMARY_VOLUME_DESC)
      break;
    else if (iso->type==ISOT_TERMINATOR)
      throw(TRP_PARTITION,0);
    else
      i++;
  }
  p->data=0;
  de=&iso->root_directory_record;
  p->root_cluster=de->location.little;
  p->size=iso->volume_space_size.little*CD_BLK_SIZE/BLK_SIZE;
  Free(iso);
}

#define ZERO_BUF_SIZE	2048
void WZeroBlks(JPartition *p,DWORD blk,DWORD cnt)
{
  DWORD l;
  BYTE *z=MAllocZ(BLK_SIZE*ZERO_BUF_SIZE);
  while (cnt) {
    l=cnt;
    if (l>ZERO_BUF_SIZE)
      l=ZERO_BUF_SIZE;
    WBlks(p,z,blk,l);
    blk+=l;
    cnt-=l;
    SwapInNext;  //Prevent locking
  }
  Free(z);
}

void FormatFAT12(char drive_letter,BOOL quick=TRUE)
{
  JPartition *p=DriveToPartition(drive_letter);
  if (p->type!=PT_FAT12) {
    PutSysText("ST_NOT_FAT12");
    return;
  }
  if (quick)
    WZeroBlks(p,p->offset,0x20);
  else
    WZeroBlks(p,p->offset,p->size);
  WBlks(p,&fd_boot_template,0,1);
  InitFAT12Partition(p);
}

void FormatFAT32(char drive_letter,BOOL quick=TRUE)
{
  FAT32BootStruct *br=MAllocZ(BLK_SIZE);
  FAT32FileInfoSector *fis=MAllocZ(BLK_SIZE);
  JPartition *p=DriveToPartition(drive_letter);
  DWORD i,l;
  if (p->type!=PT_FAT32) {
    PutSysText("ST_NOT_FAT32");
    return;
  }
  StrCpy(br->OEM_name,"MSDOS5.0");
  br->bytes_per_sector=BLK_SIZE;
  if	  (p->size<0x2000)
    br->sectors_per_cluster=1;
  else if (p->size<0x20000)
    br->sectors_per_cluster=2;
  else if (p->size<0x200000)
    br->sectors_per_cluster=4;
  else if (p->size<0x2000000)
    br->sectors_per_cluster=8;
  else if (p->size<0x20000000)
    br->sectors_per_cluster=16;
  else
    br->sectors_per_cluster=32;
 
  br->reserved_sectors=br->sectors_per_cluster+16; //TODO
  br->copies_of_FAT=2;
  br->media_descriptor=0xF8;//TODO
  br->sectors=p->size;
  l=br->sectors/br->sectors_per_cluster/(BLK_SIZE/4)+1;
  br->sectors_per_FAT=l;
  br->root_cluster=2;
  br->file_system_info_sector=1;
  br->logical_drive_num=0x80; //TODO
  br->extended_signature=0x29;
  br->serial_number=RandDWORD;
  StrCpy(br->volume_name,"NO NAME    ");
  StrCpy(br->FAT_name,"FAT32	");
  br->signature=0xAA55;
  fis->signature1=0xFFFFFFFF;
  fis->signature2=0x61417272;
  fis->free_clusters=0xFFFFFFFF;
  fis->most_recently_allocated=0;
  fis->signature3=0xAA55;

  if (quick)
    i=br->reserved_sectors+2*l+4*br->sectors_per_cluster;
  else
    i=p->size;
  WZeroBlks(p,p->offset,i);

  WBlks(p,fis,p->offset+br->file_system_info_sector,1,FALSE);
  WBlks(p,br,p->offset,1,FALSE);
  InitFAT32Partition(p);
  AllocClusters(p,0,1,FALSE,FALSE);  //Alloc #1
  br->root_cluster=AllocClusters(p,0,1,FALSE,FALSE);
  WBlks(p,br,p->offset,1,FALSE);
  InitFAT32Partition(p);
  Free(br);
  Free(fis);
}

BOOL InitBlkDev(JBlkDev *bd)
{
  JPartition *p=DriveToPartition(bd->partition_base);
  BOOL old_preempt=Preempt(OFF),result=FALSE;
  if (!(bd->flags & JBDF_INITIALIZED)) {
    bd->flags=bd->flags | JBDF_INITIALIZED |
       JBDF_INIT_IN_PROGRESS;
    switch(bd->type) {
      case JBDT_RAM:
	bd->RAM_disk=RMAllocZ((bd->max_blk+1)*BLK_SIZE);
	if (p->type==PT_FAT12)
	  FormatFAT12(bd->partition_base);
	else
	  FormatFAT32(bd->partition_base);
	break;
      case JBDT_FDC:
	if (!monitor_floppy_tss) {
	  monitor_floppy_tss=Spawn(&MonitorFDCTsk,"FLOPPY MANAGER");
	  monitor_floppy_tss->user_aux0=bd;
	}
	bd->max_reads=1;
	bd->max_writes=1;
	bd->read_freq=750;
	bd->write_freq=150;
	break;
      case JBDT_ATA:
	bd->max_reads=128;
	bd->max_writes=1;
	bd->read_freq=2000;
	bd->write_freq=500;
	IDEInit(bd,TRUE);
	break;
      case JBDT_ATAPI:
	bd->max_reads=128;
	bd->max_writes=128;
	bd->read_freq=1000;
	bd->write_freq=250;
	IDEInit(bd,TRUE);
	break;
      case JBDT_FILE:
	if (bd->flags & JBDF_FORMAT) {
	  bd->f=FOpen(bd->filename,"wc",p->size);
	  if (!bd->f)
	    throw(TRP_PARTITION,1);
	  if (p->size==FDC_MAX_SECTOR+1)
	    FormatFAT12(bd->partition_base,TRUE);
	  else
	    FormatFAT32(bd->partition_base,TRUE);
	} else {
	  bd->f=FOpen(bd->filename,"wc+");
	  if (!bd->f)
	    throw(TRP_PARTITION,2);
	  bd->max_blk=(FSize(bd->f)+BLK_SIZE-1)/BLK_SIZE-1;
	  p->size=bd->max_blk+1;
	  if (p->size==FDC_MAX_SECTOR+1)
	    InitFAT12Partition(p);
	  else
	    InitFAT32Partition(p);
	}
	break;
    }
    if (bd->flags & JBDF_READ_CACHE)
      InvalidateDiskCache(p);
    bd->flags=bd->flags & ~JBDF_INIT_IN_PROGRESS;
    result=TRUE;
  }
  Preempt(old_preempt);
  return result;
}

BOOL RBlks(JPartition *p,BYTE *buf, DWORD blk, DWORD cnt,BOOL unlock=TRUE)
{
  BOOL result=TRUE;
  JBlkDev *bdev=p->bdev;
  CheckJPartition(p);
  try {
  if (unlock)
    LockPartition(p);
  InitBlkDev(bdev);
  if ((p->offset && blk<p->offset) || blk+cnt>p->offset+p->size)
    throw(TRP_PARTITION,3);
  blk+=bdev->offset;

  if (bdev->flags & JBDF_READ_CACHE)
    RCache(p,&buf,&blk,&cnt);
  if (cnt) {
    if (!Bt(&sys_flags,SYSf_NO_IO_SOUND))
      Sound(bdev->read_freq);
    disk_status_display.w.w0=cnt;
    result=p->RBlks(p,buf,blk,cnt);
    bdev->last_jiffy=jiffies;
    disk_status_display.w.w0=0;
    if (!Bt(&sys_flags,SYSf_NO_IO_SOUND))
      Sound(0);
    if (bdev->flags & JBDF_READ_CACHE)
      JDCAdd(p,buf,blk,cnt);
  }
  if (unlock)
    UnlockPartition(p);
  } catch
    if (unlock)
      UnlockPartition(p);
  return result;
}

BOOL WBlks(JPartition *p,BYTE *buf, DWORD blk, DWORD cnt,BOOL unlock=TRUE)
{
  BOOL result;
  JBlkDev *bdev=p->bdev;
  CheckJPartition(p);
  try {
  if (unlock)
    LockPartition(p);
  InitBlkDev(bdev);
  if ((bdev->flags & JBDF_READ_ONLY) &&
     !(bdev->flags & JBDF_READ_ONLY_OVERRIDE))
    throw(TRP_BLKDEV,0);
  if ((p->offset && blk<p->offset) || blk+cnt>p->offset+p->size)
    throw(TRP_PARTITION,4);
  blk+=bdev->offset;
  if (cnt) {
    if (!Bt(&sys_flags,SYSf_NO_IO_SOUND))
      Sound(bdev->write_freq);
    disk_status_display.w.w0=cnt+0x8000;
    result=p->WBlks(p,buf,blk,cnt);
    bdev->last_jiffy=jiffies;
    disk_status_display.w.w0=0;
    if (!Bt(&sys_flags,SYSf_NO_IO_SOUND))
      Sound(0);
    if (bdev->flags & JBDF_READ_CACHE)
      JDCAdd(p,buf,blk,cnt);
  }
  if (unlock)
    UnlockPartition(p);
  } catch
    if (unlock)
      UnlockPartition(p);
  return result;
}


void InvalidateDiskCache(JPartition *p,BOOL unlock=TRUE)
{
  JBlkDev *bdev=p->bdev;
  CheckJPartition(p);
  try {
  if (unlock)
    LockPartition(p);
  InitBlkDev(bdev);
  if (bdev->flags & JBDF_READ_CACHE)
    JDCInvalidate(p);
  if (p->type==PT_FAT12)
    InitFAT12Partition(p);  //TODO: should these be here?
  else if (p->type==PT_ISO9660) {
    if (!(bdev->flags & JBDF_READ_ONLY_OVERRIDE))
      InitISOPartition(p);
  }
  if (unlock)
    UnlockPartition(p);
  } catch
    if (unlock)
      UnlockPartition(p);
}

void ChangeDisk(char drive_letter=0)
{
  JBlkDev *bdev=DriveToBlkDev(drive_letter);
  if (!InitBlkDev(bdev) && (bdev->flags & JBDF_REMOVABLE))
    InvalidateDiskCache(DriveToPartition(drive_letter));
  Drive(drive_letter);
}


void PartitionRep()
{
  int i;
  char ch;
  JPartition *p;
  JBlkDev *bdev;
  coutln "\r\nDefined Partitions:\r\n";
  for (i=0;i<32;i++) {
    p=local_partitions+sizeof(JPartition)*i;
    bdev=p->bdev;
    if (p->type) {
      if (p==default_partition)
	cout "*";
      else
	cout " ";
      ch=PartitionToDrive(p);
      cout ch," ";
      if (p->type==PT_FAT12)
	cout "FAT12  ";
      else if (p->type==PT_FAT32)
	cout "FAT32  ";
      else if (p->type==PT_ISO9660)
	cout "ISO9660";
      else
	cout "-------";
      PrintF("%6Z ",bdev->type,"ST_BLKDEV_TYPES");
      cout p->offset,"-",p->offset+p->size-1;
      PrintF(" %04X %02X %01X\r\n",bdev->base0,bdev->irq,bdev->unit);
    }
  }
}

void ReleaseTaskPartitions()
{
  int i;
  JPartition *p;
  for (i=0;i<32;i++) {
    p=local_partitions+sizeof(JPartition)*i;
    if (p->owning_task==Fs)
      UnlockPartition(p);
  }
}

void AddBlkDev(JBlkDev *bd)
{
  int i,j,ext_base,num_partition;
  DWORD offset;
  MasterBootStruct mbr;
  JPartition *p;
  char *drname;

  bd->ch_J='J';
  bd->ch_B='B';
  bd->ch_D='D';
  num_partition=bd->partition_base-'A';
  p=local_partitions+sizeof(JPartition)*num_partition;
  MemSet(p,0,sizeof(JPartition));
  p->drive=num_partition+'A';
  p->ch_J='J';
  p->ch_P='P';
  p->ch_E='E';
  p->bdev=bd;
  p->size=bd->max_blk+1;

  j=(sys_boot_code.ba[1]==0xE0) ? 0:1;
  switch (sys_boot_code.ba[0]) {
    case BOOT_CODE_CDROM:
      if (sys_boot_code.wa[1]==bd->base0 && j==bd->unit)
	boot_blkdev=bd;
      break;
    case BOOT_CODE_HARDDRIVE:
      if (sys_boot_code.wa[1]==bd->base0 && j==bd->unit)
	boot_blkdev=bd;
      break;
  }
  if (boot_blkdev==bd)
    bd->flags|=JBDF_HAS_BEEN_RESET;

  switch (bd->type) {
    case JBDT_FDC:
      p->type=PT_FAT12;
      p->RBlks=&FDCRBlks;
      p->WBlks=&FDCWBlks;
      break;
    case JBDT_RAM:
      if (bd->max_blk==FDC_MAX_SECTOR)
	p->type=PT_FAT12;
      else
	p->type=PT_FAT32;
      p->RBlks=&RAMRBlks;
      p->WBlks=&RAMWBlks;
      break;
    case JBDT_ATA:
      InitBlkDev(bd);
      offset=0;
      ext_base=-1;
      while (TRUE) {
	ATAReadBlks(bd,&mbr,offset,1);
	j=-1;
	for (i=0;i<4;i++) {
	  if (mbr.p[i].type!=0) {
	    p=local_partitions+sizeof(JPartition)*num_partition;
	    MemSet(p,0,sizeof(JPartition));
	    p->drive=num_partition+'A';
	    p->ch_J='J';
	    p->ch_P='P';
	    p->ch_E='E';
	    p->bdev=bd;
	    p->RBlks=&IDERBlks;
	    p->WBlks=&IDEWBlks;
	    p->offset=mbr.p[i].offset+offset;
	    p->size  =mbr.p[i].size;
	    p->type  =mbr.p[i].type;
	    if (p->type==PT_FAT32+1) p->type=PT_FAT32;
	    if (p->type==PT_FAT32)
	      InitFAT32Partition(p);
	    if (p->type==5 || p->type==0xF)
	      j=i;
	    else
	      num_partition++;
	    }
	  }
	if (j<0)
	  break;
	if (mbr.p[j].offset==0)
	  break;
	if (ext_base<0) {
  	  offset=mbr.p[j].offset;
	  ext_base=offset;
	} else
	  offset=mbr.p[j].offset+ext_base;
      }
      break;
    case JBDT_ATAPI:
      p->type=PT_ISO9660;
      p->RBlks=&IDERBlks;
      p->WBlks=&IDEWBlks;
      p->size =CD_FILE_OFFSET;
      break;
    case JBDT_FILE:
      drname=ChangeExtension(bd->filename,"DVC");
      bd->filename=RNewString(drname);
      Free(drname);
      if (bd->max_blk==FDC_MAX_SECTOR)
	p->type=PT_FAT12;
      else
	p->type=PT_FAT32;
      p->RBlks=&FileRBlks;
      p->WBlks=&FileWBlks;
      break;
  }
}


void AddDrives(BOOL show_rep=TRUE)
{
  JBlkDev *bd;
  int base_partition,i,j,k;
  char buf[32],buf2[128];
  BOOL format;
  do {
    if (show_rep)
      PartitionRep;
    show_rep=TRUE;
    coutln "\r\n****** Add Drives ******";
    cout "Base Drive Letter(ENTER to exit):";
    base_partition=ToUpper(GetChar)-'A';
    CrLf;
    if (base_partition>=0 && base_partition<32) {

      cout "\t1=RAM\r\n\t2=FDC(Floppy)\r\n\t3=ATA(Harddisk)\r\n"
	   "\t4=ATAPI(CD-ROM)\r\n\t5=FILE\r\n"
	   "Type:";
      i=GetChar-'0';
      CrLf;

      j=1;k=0;
      if (i==5) {
	cout "Filename:";
	GetS(buf2,128);
	cout "Reformat ";
	format=YorN;
	*buf=0;
      }
      if (i==1 || (i==5 && format)) {
	PrintF("Blks(%d for floppy):",FDC_MAX_SECTOR+1);
	GetS(buf,32);
      } else if (i!=5) {
	cout "\t2=3F0(Floppy)\r\n\t3=1F0(Primary IDE)\r\n"
	     "\t4=170(Secondary IDE)\r\nPort:";
	j=GetChar-'0';
	CrLf;

	cout "\t0=Master\r\n\t1=Slave\r\nUnit:";
	k=GetChar-'0';
	CrLf;
      }

      if (i>0 && i<=5 && j>0 && j<=4 && k>=0 && k<=1) {
	bd=local_blkdevs+sizeof(JBlkDev)*(num_blkdevs++);
	bd->partition_base=base_partition+'A';

	bd->type=i;
	if (i==2 || i==4)
	  bd->flags=JBDF_REMOVABLE;
	else
	  bd->flags=0;
	if (i!=1)
	  bd->flags|=JBDF_READ_CACHE;
 
	if (i==4) {
	  bd->blk_size=CD_BLK_SIZE;
	  bd->flags|=JBDF_READ_ONLY;
	} else
	  bd->blk_size=BLK_SIZE;
	if (i==1 || (i==5 && format)) {
	  bd->max_blk=AtoI(buf)-1;
	  if (bd->max_blk<FDC_MAX_SECTOR)
	    bd->max_blk=FDC_MAX_SECTOR;
	} else if (i==2)
	  bd->max_blk=FDC_MAX_SECTOR;
	else
	  bd->max_blk=0xEFFFFFFF;
	if (j==2) {
	  bd->base0=0x3F0;
	  bd->irq=6;
	} else if (j==3) {
	  bd->base0=0x1F0;
	  bd->base1=0x3F6;
	  bd->irq=14;
	} else if (j==4) {
	  bd->base0=0x170;
	  bd->base1=0x376;
	  bd->irq=15;
	}
	if (i==5) {
	  bd->filename=RNewString(buf2);
	  if (format)
	    bd->flags=bd->flags|JBDF_FORMAT;
	}
	bd->unit=k;
	AddBlkDev(bd);
      } else
	coutln "\r\n\r\nERROR: !!! Invalid Entry!!!";
    }
  } while (base_partition>=0 && base_partition<32);
}

void SetPromptedBaseUnit(JBlkDev *bd)
{
  if (sys_boot_code.ba[1]==0xE0)
    bd->unit=0;
  else
    bd->unit=1;
  if (sys_boot_code.wa[1]==0x1F0) {
    bd->base0=0x1F0;
    bd->base1=0x3F6;
    bd->irq=14;
  } else {
    bd->base0=0x170;
    bd->base1=0x376;
    bd->irq=15;
  }
}

void InitAllBlkDevs()
{
  JBlkDev *bd;
  int ii;

  num_blkdevs=0;
  boot_blkdev=NULL;
  local_blkdevs=RMAllocZ(sizeof(JBlkDev)*16);

  monitor_floppy_tss=NULL;
  FDC_retries=2;
  FDC_DRIVE_HEADS=2;
  FDC_DISK_CYLINDERS=80;
  FDC_DISK_SECTORS=18;
  FDC_MAX_SECTOR=FDC_DRIVE_HEADS*FDC_DISK_CYLINDERS*FDC_DISK_SECTORS-1;
  FDC_DMA_BUF=0xD000;
  ext[EXT_IRQ06]=&Irq06Handler;

  ext[EXT_IRQ0E]=&Irq0EHandler;
  ext[EXT_IRQ0F]=&Irq0FHandler;

  local_partitions=RMAllocZ(sizeof(JPartition)*32);
  for (ii=0;ii<32;ii++)
    drive_to_partition[ii]=local_partitions+sizeof(JPartition)*ii;
  *DC_COL=0;

  exe {
    int base_partition,i,j,k,l;
    char buf[32],buf2[128];
    BOOL format;
    do {
      cout "\r\nBase Drive Letter for device(ENTER to exit):";
      base_partition=ToUpper(GetChar)-'A';
      CrLf;
      if (base_partition>=0 && base_partition<32) {

	cout "\t1=RAM\r\n\t2=FDC(Floppy)\r\n\t3=ATA(Harddisk)\r\n"
	     "\t4=ATAPI(CD-ROM)\r\n\t5=FILE\r\n"
	     "Type:";
	i=GetChar-'0';
	CrLf;

	j=1;k=0;
	if (i==5) {
	  cout "Filename:";
	  GetS(buf2,128);
	  cout "Reformat ";
	  format=YorN;
	  *buf=0;
	}
	if (i==1 || (i==5 && format)) {
	  PrintF("Blks(%d for floppy):",FDC_MAX_SECTOR+1);
	  GetS(buf,32);
	} else if (i!=5) {
	  cout "\t2=3F0(Floppy)\r\n\t3=1F0(Primary IDE)\r\n"
	       "\t4=170(Secondary IDE)\r\n"
	       "\t5=Use CD-ROM prompted values\r\n"
	       "Port:";
	  j=GetChar-'0';
	  CrLf;

	  if (j!=5) {
	    cout "\t0=Master\r\n\t1=Slave\r\nUnit:";
	    k=GetChar-'0';
	    CrLf;
	  } else {
	    if (i!=4) {
	      coutln "Only works for ATAPI type";
	      j=0;  //force error
	    }
	  }
	}

	if (i>0 && i<=5 && j>0 && j<=5 && k>=0 && k<=1) {
	  ExePrintF("bd=local_blkdevs+sizeof(JBlkDev)*(num_blkdevs++);");
	  ExePrintF("bd->partition_base=%d;",
	    base_partition+'A');

	  ExePrintF("bd->type=%d;",i);
	  if (i==2 || i==4)
	    ExePrintF("bd->flags=JBDF_REMOVABLE;");
	  else
	    ExePrintF("bd->flags=0;");
	  if (i!=1)
	    ExePrintF("bd->flags=bd->flags|JBDF_READ_CACHE;");

	  if (i==4) {
	    ExePrintF("bd->blk_size=CD_BLK_SIZE;");
	    ExePrintF("bd->flags=bd->flags | JBDF_READ_ONLY;");
	  } else
	    ExePrintF("bd->blk_size=BLK_SIZE;");
	  if (i==1 || (i==5 && format)) {
	    l=AtoI(buf)-1;
	    if (l<FDC_MAX_SECTOR)
	      l=FDC_MAX_SECTOR;
	    ExePrintF("bd->max_blk=%d;",l);
	  } else if (i==2)
	    ExePrintF("bd->max_blk=FDC_MAX_SECTOR;");
	  else
	    ExePrintF("bd->max_blk=0xEFFFFFFF;");

	  ExePrintF("bd->unit=%d;",k);

	  if (j==2)
	    ExePrintF("bd->base0=0x3F0;bd->irq=6;");
	  else if (j==3)
	    ExePrintF("bd->base0=0x1F0;bd->base1=0x3F6;bd->irq=14;");
	  else if (j==4)
	    ExePrintF("bd->base0=0x170;bd->base1=0x376;bd->irq=15;");
	  else if (j==5)
	    ExePrintF("SetPromptedBaseUnit(bd);");

	  if (i==5) {
	    ExePrintF("bd->filename=RNewString(\"%s\");",buf2);
	    if (format)
	      ExePrintF("bd->flags=bd->flags|JBDF_FORMAT;");
	  }
	  ExePrintF("AddBlkDev(bd);");
	} else
	  coutln "Invalid Entry";
      }
    } while (base_partition>=0 && base_partition<32);
    cout "\r\nDefault Drive Letter(SPACE=prompt):";
    i=GetChar;
    if (i==13) {
      i=Fs->user_aux1; //set by bootins
      PrintF("Using Drive '%c'",i);
    }
    CrLf;
    if (i!=32)
      i=ToUpper(i);
    if (i<'A' || i>'Z') {
      i=0;
      coutln "Drive will be prompted.";
    }
    ExePrintF("default_drive=%d;",i);
  }

  PartitionRep;
}


DWORD NextClusterNum(JPartition *p,DWORD c,DWORD cnt=1)
{
  DWORD FAT_index;
  BYTE *FAT;
  CheckJPartition(p);
  if (!cnt || !c) return c;
  if (p->type==PT_FAT12) {
    while (cnt-- && c && c<0xFF8) {
      FAT_index=(3*c)/2;
      FAT=p->cur_FAT_blk;
      if (c<2) { //root_dir
	c++;
	if (c==0)
	  c=0xFFFFFFFF;
      } else {
	if (c & 1) {
	  c=FAT[FAT_index+1];
	  c=(c<<4) | ((FAT[FAT_index] & 0xF0)>>4);
	} else {
	  c=FAT[FAT_index+1];
	  c=((c & 0x0F)<<8) | FAT[FAT_index];
	}
	if (c>=0xFF8)
	  c=0xFFFFFFFF;
      }
    }
  } else if (p->type==PT_FAT32) {
    while (cnt-- && c && c<0x0FFFFFF8) {
      SetFAT32Buf(p,c);
      c=p->cur_FAT_blk[c & (BLK_SIZE/4-1)];
    }
    if (c>=0xFFFFFF8)
      c=0xFFFFFFFF;
  } else if (p->type==PT_ISO9660)
    c+=cnt;
  else
    c=0xFFFFFFFF;
  return c;
}


DWORD ClusterBlk(JPartition *p,DWORD c)
{
  CheckJPartition(p);
  return p->data+c*p->spc;
}

DWORD RClusters(JPartition *p,BYTE *buf,DWORD c,DWORD cnt=1,BOOL update_display=FALSE)
{
  CheckJPartition(p);
  if (!cnt) return c;
  if (p->type==PT_ISO9660) {
    RBlks(p,buf,p->data+c*p->spc,p->spc*cnt,FALSE);
    c+=cnt;
  } else {
    while (cnt && c && c!=0xFFFFFFFF) {
      RBlks(p,buf,p->data+c*p->spc,p->spc,FALSE);
      buf+=p->spc*BLK_SIZE;
      c=NextClusterNum(p,c);
      cnt--;
      if (update_display)
	disk_status_display.w.w1--;
    }
    if (cnt)
      UnrecoverableSysError(0x0FFF0001);
  }
  return c;
}

BOOL ToFATName(char *dst,char *src)
{
  int i;
  MemSet(dst,0x20,11);
  if (!CheckFileName(src))
    return FALSE;
  if (!StrCmp(src,"..")) {
    dst[0]='.';
    dst[1]='.';
    return TRUE;
  } else if (!StrCmp(src,".")) {
    dst[0]='.';
    return TRUE;
  }
  i=0;
  while (i<8 && *src && *src!='.')
    dst[i++]=*src++;
  i=8;
  if (*src=='.') src++;
  while (*src)
    dst[i++]=*src++;
  return TRUE;
}

BOOL FromFATName(char *dst,char *src)
{
  int i,j,k=0;
  for (j=7;j>=0 && src[j]==0x20;j--);
  for(i=0;i<=j;i++)
    dst[k++]=src[i];
  for (j=10;j>=8 && src[j]==0x20;j--);
  if (*src!='.' && j!=7)
    dst[k++]='.';
  for(i=8;i<=j;i++)
    dst[k++]=src[i];
  dst[k++]=0;
  return CheckFileName(dst);
}

BOOL FromISOName(char *dst,BYTE *src)
{
  BOOL result=TRUE;
  char *saved_dst=dst;
  int i,l;
  l=*src++;
  if (!*src)
    *dst++='.';
  else if (*src==1) {
    *dst++='.';
    *dst++='.';
  } else {
    if (l<=12) {
      for (i=0;i<l;i++)
	*dst++=*src++;
    }
  }
  *dst=0;
  return CheckFileName(saved_dst);
}

BOOL FillJDirFAT12(JDirEntry *tempm,FAT12DirEntry *de)
{
  BOOL result;
  MemSet(tempm,0,sizeof(JDirEntry));
  result=FromFATName(tempm->name,de->name);
  if (result)
    result=
  tempm->cluster=de->cluster_lo;
  tempm->size=de->size;
  tempm->attr=de->attr;
  tempm->datetime.d=DosToJDate(de->Time,de->Date);
  return result;
}

BOOL FillJDirFAT32(JDirEntry *tempm,FAT32DirEntry *de)
{
  BOOL result;
  MemSet(tempm,0,sizeof(JDirEntry));
  result=FromFATName(tempm->name,de->name);
  tempm->cluster=de->cluster_lo+(de->cluster_hi<<16);
  tempm->size=de->size;
  tempm->attr=de->attr;
  tempm->datetime.d=DosToJDate(de->WrtTime,de->WrtDate);
  return result;
}

BOOL FillJDirISO(JDirEntry *tempm,ISODirEntry *de)
{
  BOOL result;
  MemSet(tempm,0,sizeof(JDirEntry));
  result=FromISOName(tempm->name,&de->name_len);
  tempm->cluster=de->location.little;
  tempm->size=de->size.little;
  tempm->attr=0;
  if (de->flags & ISO_ATTR_DIR)
    tempm->attr=tempm->attr | J_ATTR_DIR;
  tempm->datetime.d=ISOToJDate(&de->date);
  return result;
}

BOOL FillFAT12JDir(FAT12DirEntry *de,JDirEntry *tempm)
{
  BOOL result;
  MemSet(de,0,sizeof(FAT12DirEntry));
  result=ToFATName(de->name,tempm->name);
  de->cluster_lo=tempm->cluster;
  de->size=tempm->size;
  de->attr=tempm->attr;
  if (!tempm->datetime.d)
    tempm->datetime.d=GetCurTimeJDate;
  JDateToDos(&de->Time,&de->Date,tempm->datetime.d);
  return result;
}

BOOL FillFAT32JDir(FAT32DirEntry *de,JDirEntry *tempm)
{
  BOOL result;
  MemSet(de,0,sizeof(FAT32DirEntry));
  result=ToFATName(de->name,tempm->name);
  de->cluster_lo=tempm->cluster & 0xFFFF;
  de->cluster_hi=tempm->cluster >> 16;
  de->size=tempm->size;
  de->attr=tempm->attr;
  if (!tempm->datetime.d)
    tempm->datetime.d=GetCurTimeJDate;
  JDateToDos(&de->WrtTime,&de->WrtDate,tempm->datetime.d);
  return result;
}


BOOL FindFAT12File(JPartition *p,DWORD cur_dir_cluster,char *name,
		     JDirEntry *result,
		     BOOL dir_only,BOOL file_only,BOOL unlock=TRUE)
{
  BOOL res=FALSE;
  FAT12DirEntry *buf;
  DWORD cur_dir_entry,entries_per_cluster;
  BOOL cont2=FALSE;
  char *ptr,*ptr2,dname[16];
  DWORD i;
  BYTE ch;

  CheckJPartition(p);
  if (p->type!=PT_FAT12)
    PutSysText("ST_NOT_FAT12");
  else if (!ToFATName(dname,name))
    PutSysText("ST_INVALID_FILENAME");
  else {
    try {
    if (unlock)
      LockPartition(p);
    buf=MAlloc(BLK_SIZE*p->spc);
    entries_per_cluster=BLK_SIZE*p->spc/sizeof(FAT12DirEntry);
    RClusters(p,buf,cur_dir_cluster);
    cur_dir_entry=0;
    while (TRUE) {
      if (cur_dir_entry==entries_per_cluster) {
	cur_dir_cluster=NextClusterNum(p,cur_dir_cluster);
	if (cur_dir_cluster==0xFFFFFFFF||!cur_dir_cluster)
	  break;
	else {
	  RClusters(p,buf,cur_dir_cluster);
	  cur_dir_entry=0;
	}
      }
      ch=buf[cur_dir_entry].name[0];
      if (!ch)
	break;
      else if (ch!=0xE5) {
	if (dir_only && !(buf[cur_dir_entry].attr & FAT12_ATTR_DIR))
	  cont2=FALSE;
	else if (file_only && (buf[cur_dir_entry].attr & FAT12_ATTR_DIR))
	  cont2=FALSE;
	else
	  cont2=TRUE;
	ptr=dname;
	ptr2=buf[cur_dir_entry].name;
	for (i=0;i<11 && cont2;i++)
	  if (*ptr++!=*ptr2++)
	    cont2=FALSE;
	if (cont2) {
	  res=FillJDirFAT12(result,&buf[cur_dir_entry]);
    	  goto exit_this;
	}
      }
      cur_dir_entry++;
    }
exit_this:
    Free(buf);
    if (unlock)
      UnlockPartition(p);
    } catch
      if (unlock)
	UnlockPartition(p);
  }
  return res;
}

BOOL FindFAT32File(JPartition *p,DWORD cur_dir_cluster,char *name,JDirEntry *result,
		     BOOL dir_only,BOOL file_only,BOOL unlock=TRUE)
{
  BOOL res=FALSE;
  FAT32DirEntry *buf;
  DWORD cur_dir_entry,entries_per_cluster;
  BOOL cont2=FALSE;
  char *ptr,*ptr2,dname[16];
  DWORD i;
  BYTE ch;

  CheckJPartition(p);
  if (p->type!=PT_FAT32)
    PutSysText("ST_NOT_FAT32");
  else if (!ToFATName(dname,name))
    PutSysText("ST_INVALID_FILENAME");
  else {
    try {
    if (unlock)
      LockPartition(p);
    buf=MAlloc(BLK_SIZE*p->spc);
    entries_per_cluster=BLK_SIZE*p->spc/sizeof(FAT32DirEntry);
    RClusters(p,buf,cur_dir_cluster);
    cur_dir_entry=0;
    while (TRUE) {
      if (cur_dir_entry==entries_per_cluster) {
	cur_dir_cluster=NextClusterNum(p,cur_dir_cluster);
	if (cur_dir_cluster==0xFFFFFFFF||!cur_dir_cluster)
	  break;
	else {
	  RClusters(p,buf,cur_dir_cluster);
	  cur_dir_entry=0;
	}
      }
      ch=buf[cur_dir_entry].name[0];
      if (!ch)
	break;
      else if (ch!=0xE5) {
	if (dir_only && !(buf[cur_dir_entry].attr & FAT32_ATTR_DIR))
	  cont2=FALSE;
	else if (file_only && (buf[cur_dir_entry].attr & FAT32_ATTR_DIR))
	  cont2=FALSE;
	else
	  cont2=TRUE;
	ptr=dname;
	ptr2=buf[cur_dir_entry].name;
	for (i=0;i<11 && cont2;i++)
	  if (*ptr++!=*ptr2++)
	    cont2=FALSE;
	if (cont2) {
	  res=FillJDirFAT32(result,&buf[cur_dir_entry]);
    	  goto exit_this;
	}
      }
      cur_dir_entry++;
    }
exit_this:
    Free(buf);
    if (unlock)
      UnlockPartition(p);
    } catch
      if (unlock)
	UnlockPartition(p);
  }
  return res;
}

BOOL FindISOFile(JPartition *p,DWORD cur_dir_cluster,char *name,JDirEntry *result,
		     BOOL dir_only,BOOL file_only,BOOL unlock=TRUE)
{
  ISODirEntry *isoptr,*buf;
  BOOL cont2;
  char dname[32];
  BOOL res=FALSE;
  int i;

  CheckJPartition(p);
  if (p->type!=PT_ISO9660)
    PutSysText("ST_NOT_ISO9660");
  else {
    try {
    if (unlock)
      LockPartition(p);
    isoptr=MAlloc(BLK_SIZE*p->spc);
    RClusters(Fs->cur_partition,isoptr,cur_dir_cluster);
    if (isoptr->name_len==1 && isoptr->name==0) { //curdir
      i=(isoptr->size.little+BLK_SIZE*p->spc-1)/(BLK_SIZE*p->spc);
      buf=MAlloc(BLK_SIZE*p->spc*i);
      RClusters(Fs->cur_partition,buf,cur_dir_cluster,i);
      Free(isoptr);
    } else {
      buf=isoptr;
      i=1;
    }
    i*=BLK_SIZE*p->spc;
    isoptr=buf;
    while (i>0) {
      if (!isoptr->length) {
	isoptr++;
	i--;
      } else {
	FromISOName(dname,&isoptr->name_len);
	if (*dname) {
	  if (!StrCmp(name,dname)) {
	    res=FillJDirISO(result,isoptr);
	    if (!res)
	      cont2=FALSE;
	    else if (dir_only && !(result->attr & J_ATTR_DIR))
	      cont2=FALSE;
	    else if (file_only && (result->attr & J_ATTR_DIR))
	      cont2=FALSE;
	    else
	      goto exit_this;
	  }
	}
	i-=isoptr->length;
	isoptr+=isoptr->length;
      }
    }
exit_this:
    Free(buf);
    if (unlock)
      UnlockPartition(p);
    } catch
      if (unlock)
	UnlockPartition(p);
  }
  return res;
}

BYTE *ReadFAT12File(JPartition *p,DWORD cur_dir_cluster,char *filename,DWORD *size=NULL,
	DWORD *attr=NULL,BOOL raw=FALSE,ArcCompressStruct **ac2=NULL,BOOL unlock=TRUE)
{
  BYTE *buf=NULL;
  JDirEntry de;
  DWORD c,cluster_size=BLK_SIZE*p->spc,cluster_cnt;
  ArcCompressStruct *ac;

  CheckJPartition(p);
  if (ac2)
    *ac2=NULL;
  if (size)
    *size=0;
  if (attr)
    *attr=0;
  if (p->type!=PT_FAT12)
    PutSysText("ST_NOT_FAT12");
  else {
    try {
    if (unlock)
      LockPartition(p);
    if (!FindFAT12File(p,cur_dir_cluster,filename,&de,FALSE,TRUE,FALSE))
      cout filename," ",SysText("ST_FILE_NOT_FOUND");
    else {
      if (attr)
	*attr=de.attr;
      cluster_cnt=(de.size+cluster_size-1)/cluster_size;
      buf=MAlloc(cluster_cnt*cluster_size+1);
      c=de.cluster;
      disk_status_display.w.w1=cluster_cnt;
      if (c>=0xFF8)
	c=0xFFFFFFFF;
      else
	c=RClusters(p,buf,c,cluster_cnt,TRUE);
      disk_status_display.w.w1=0;
      if ((FileAttr(de.name) & J_ATTR_COMPRESSED) && !raw) {
	ac=buf;
	if (attr)
	  *attr=FileAttr(de.name,ac->flags|*attr);
	if (size)
	  *size=ac->expanded_size;
	if (ac2) {
	  *ac2=ac;
	  buf=ExpandBuf(ac);
	} else {
	  buf=ExpandBuf(ac);
	  Free(ac);
	}
      } else {
	buf[de.size]=0; //Terminate
	if (size)
	  *size=de.size;
      }
      if (attr)
	*attr=FileAttr(de.name,*attr);
    }
    if (unlock)
      UnlockPartition(p);
    } catch
      if (unlock)
	UnlockPartition(p);
  }
  return buf;
}

BYTE *ReadFAT32File(JPartition *p,DWORD cur_dir_cluster,char *filename,DWORD *size=NULL,
  DWORD *attr=NULL,BOOL raw=FALSE,ArcCompressStruct **ac2=NULL,BOOL unlock=TRUE)
{
  BYTE *buf=NULL;
  JDirEntry de;
  DWORD c,cluster_size=BLK_SIZE*p->spc,cluster_cnt;
  ArcCompressStruct *ac;

  CheckJPartition(p);
  if (size)
    *size=0;
  if (ac2)
    *ac2=NULL;
  if (attr)
    *attr=0;
  if (p->type!=PT_FAT32)
    PutSysText("ST_NOT_FAT32");
  else {
    try {
    if (unlock)
      LockPartition(p);
    if (!FindFAT32File(p,cur_dir_cluster,filename,&de,FALSE,TRUE,FALSE))
      cout filename," ",SysText("ST_FILE_NOT_FOUND");
    else {
      if (attr)
	*attr=de.attr;
      cluster_cnt=(de.size+cluster_size-1)/cluster_size;
      buf=MAlloc(cluster_cnt*cluster_size+1);
      c=de.cluster;
      disk_status_display.w.w1=cluster_cnt;
      if (c>=0x0FFFFFF8)
	c=0xFFFFFFFF;
      else
	c=RClusters(p,buf,c,cluster_cnt,TRUE);
      disk_status_display.w.w1=0;
      if ((FileAttr(de.name) & J_ATTR_COMPRESSED) && !raw) {
	ac=buf;
	if (attr)
	  *attr=FileAttr(de.name,ac->flags|*attr);
	if (size)
	  *size=ac->expanded_size;
	if (ac2) {
	  *ac2=ac;
	  buf=ExpandBuf(ac);
	} else {
	  buf=ExpandBuf(ac);
	  Free(ac);
	}
      } else {
	buf[de.size]=0; //Terminate
	if (size)
	  *size=de.size;
      }
      if (attr)
	*attr=FileAttr(de.name,*attr);
    }
    if (unlock)
      UnlockPartition(p);
    } catch
      if (unlock)
	UnlockPartition(p);
  }
  return buf;
}

BYTE *ReadISOFile(JPartition *p,DWORD cur_dir_cluster,char *filename,DWORD *size=NULL,
  DWORD *attr=NULL,BOOL raw=FALSE,ArcCompressStruct **ac2=NULL,BOOL unlock=TRUE)
{
  BYTE *buf=NULL;
  JDirEntry de;
  DWORD c,cluster_size=BLK_SIZE*p->spc,cluster_cnt;
  ArcCompressStruct *ac;

  CheckJPartition(p);
  if (size)
    *size=0;
  if (ac2)
    *ac2=NULL;
  if (attr)
    *attr=0;
  if (p->type!=PT_ISO9660)
    PutSysText("ST_NOT_ISO9660");
  else {
    try {
    if (unlock)
      LockPartition(p);
    if (!FindISOFile(p,cur_dir_cluster,filename,&de,FALSE,TRUE,FALSE))
      cout filename," ",SysText("ST_FILE_NOT_FOUND");
    else {
      if (attr)
	*attr=de.attr;
      cluster_cnt=(de.size+cluster_size-1)/cluster_size;
      buf=MAlloc(cluster_cnt*cluster_size+1);
      c=de.cluster;
      disk_status_display.w.w1=cluster_cnt;
      c=RClusters(p,buf,c,cluster_cnt,TRUE);
      disk_status_display.w.w1=0;
      if ((FileAttr(de.name) & J_ATTR_COMPRESSED) && !raw) {
	ac=buf;
	if (attr)
	  *attr=FileAttr(de.name,ac->flags|*attr);
	if (size)
	  *size=ac->expanded_size;
	if (ac2) {
	  *ac2=ac;
	  buf=ExpandBuf(ac);
	} else {
	  buf=ExpandBuf(ac);
	  Free(ac);
	}
      } else {
	buf[de.size]=0; //Terminate
	if (size)
	  *size=de.size;
      }
      if (attr)
	*attr=FileAttr(de.name,*attr);
    }
    if (unlock)
      UnlockPartition(p);
    } catch
      if (unlock)
	UnlockPartition(p);
  }
  return buf;
}

BOOL CdFAT12(char *name)
{
  JDirEntry de;
  if (Fs->cur_partition->type!=PT_FAT12)
    PutSysText("ST_NOT_FAT12");
  else {
    if (FindFAT12File(Fs->cur_partition,Fs->cur_dir_cluster,
			name,&de,TRUE,FALSE)) {
      Fs->cur_dir_cluster=de.cluster;
      return TRUE;
    } else
      cout name," ",SysText("ST_FILE_NOT_FOUND");
  }
  return FALSE;
}

BOOL CdFAT32(char *name)
{
  JDirEntry de;
  if (Fs->cur_partition->type!=PT_FAT32)
    PutSysText("ST_NOT_FAT32");
  else {
    if (FindFAT32File(Fs->cur_partition,Fs->cur_dir_cluster,
			name,&de,TRUE,FALSE)) {
      Fs->cur_dir_cluster=de.cluster;
      return TRUE;
    } else
      cout name," ",SysText("ST_FILE_NOT_FOUND");
  }
  return FALSE;
}

BOOL CdISO(char *name)
{
  JDirEntry de;
  if (Fs->cur_partition->type!=PT_ISO9660)
    PutSysText("ST_NOT_ISO9660");
  else {
    if (FindISOFile(Fs->cur_partition,Fs->cur_dir_cluster,
			name,&de,TRUE,FALSE)) {
      Fs->cur_dir_cluster=de.cluster;
      return TRUE;
    } else
      cout name," ",SysText("ST_FILE_NOT_FOUND");
  }
  return FALSE;
}

DWORD WClusters(JPartition *p,BYTE *buf,DWORD c,DWORD cnt=1,BOOL update_display=FALSE)
{
  CheckJPartition(p);
  while (cnt--) {
    if (p->type==PT_FAT12) {
      if (!c || c>=0xFFF)
	UnrecoverableSysError(0x0FFF0004);
    } else if (p->type=PT_FAT32) {
      if (!c || c>=0x0FFFFFF8)
	UnrecoverableSysError(0x0FFF0004);
    }
    WBlks(p,buf,p->data+c*p->spc,p->spc,FALSE);
    buf+=BLK_SIZE*p->spc;
    c=NextClusterNum(p,c);
    if (update_display)
      disk_status_display.w.w1--;
  }
  return c;
}

//This frees a chain of clusters.  It needs to be
//made more efficient by doing one write for
//all modifications to the same FAT blk
void FreeFAT12Clusters(JPartition *p,DWORD c,BOOL unlock)
{
  DWORD FAT_blk_num,FAT_index,next;
  BYTE *FAT=p->cur_FAT_blk;
  BOOL cont=TRUE;
  CheckJPartition(p);
  if (!c || c>=0x0FFF) return;
  if (p->type!=PT_FAT12)
    PutSysText("ST_NOT_FAT12");
  else {
    try {
    if (unlock)
      LockPartition(p);
    do {
      FAT_index=3*c/2;
      FAT_blk_num=FAT_index/BLK_SIZE;
      next=NextClusterNum(p,c);
      if (c &1) {
	FAT[FAT_index+1]=0;
	FAT[FAT_index]=FAT[FAT_index] & 0x0F;
      } else {
	FAT[FAT_index+1]=FAT[FAT_index+1] & 0xF0;
	FAT[FAT_index]=0;
      }
      Bts(p->buffered_FAT_dirty_bits,FAT_blk_num);
      if ((FAT_index & (BLK_SIZE-1))==BLK_SIZE-1)
	Bts(p->buffered_FAT_dirty_bits,FAT_blk_num+1);
      c=next;
    } while (next && next!=0xFFFFFFFF);
    CleanFATBuf(p);
    if (unlock)
      UnlockPartition(p);
    } catch
      if (unlock)
	UnlockPartition(p);
  }
}

void FreeFAT32Clusters(JPartition *p,DWORD c,BOOL unlock)
{
  DWORD next,saved_c=c;
  BOOL cont=TRUE;
  CheckJPartition(p);
  if (!c || c>=0x0FFFFFF8) return;
  if (p->type!=PT_FAT32)
    PutSysText("ST_NOT_FAT32");
  else {
    try {
    if (unlock)
      LockPartition(p);
    CleanFATBuf(p);

    do {
      SetFAT32Buf(p,c,0);
      next=p->cur_FAT_blk[c&(BLK_SIZE/4-1)];
      p->cur_FAT_blk[c&(BLK_SIZE/4-1)]=0;
      Bts(p->buffered_FAT_dirty_bits,0);
      c=next;
    } while (c && c<0x0FFFFFF8);
    CleanFATBuf(p,0);

    c=saved_c;
    do {
      SetFAT32Buf(p,c,1);
      next=p->cur_FAT_blk[c&(BLK_SIZE/4-1)];
      p->cur_FAT_blk[c&(BLK_SIZE/4-1)]=0;
      Bts(p->buffered_FAT_dirty_bits,0);
      c=next;
    } while (c && c<0x0FFFFFF8);
    CleanFATBuf(p,1);

    if (unlock)
      UnlockPartition(p);
    } catch
      if (unlock)
	UnlockPartition(p);
  }
}

DWORD AllocFAT12Clusters(JPartition *p,int c,DWORD cnt,BOOL unlock)
{
  DWORD FAT_blk_cnt=0,first=0xFFFFFFFF,FAT_index,j=1;
  BOOL cont;
  BYTE *FAT=p->cur_FAT_blk;
  try {
  if (unlock)
    LockPartition(p);
  if (c<0) {
    c++;
    if (c*p->spc+cnt>=0)
      UnrecoverableSysError(0x0FFF0002);
    else
      return c;
  }
  while (cnt--) {
    cont=TRUE;
    while (cont) {
      j++;
      if ((j+1)*p->spc+p->data>p->size+p->offset)
	UnrecoverableSysError(0x0FFF0003);
      FAT_index=3*j/2;
      FAT_blk_cnt=FAT_index/BLK_SIZE;
      if (j & 1) {
	if (!FAT[FAT_index+1] && !(FAT[FAT_index] & 0xF0)) {
	  FAT[FAT_index+1]=0xFF;
	  FAT[FAT_index]=FAT[FAT_index] | 0xF0;
	  cont=FALSE;
	}
      } else {
	if (!FAT[FAT_index] && !(FAT[FAT_index+1] & 0xF)) {
	  FAT[FAT_index+1]=FAT[FAT_index+1] | 0x0F;
	  FAT[FAT_index]=0xFF;
	  cont=FALSE;
	}
      }
      if (!cont) {
	Bts(p->buffered_FAT_dirty_bits,FAT_blk_cnt);
	if ((FAT_index & (BLK_SIZE-1))==BLK_SIZE-1)
	  Bts(p->buffered_FAT_dirty_bits,FAT_blk_cnt+1);
      }
    }
    if (first==0xFFFFFFFF)
      first=j;
    if (c) {
      FAT_index=3*c/2;
      FAT_blk_cnt=FAT_index/BLK_SIZE;
      if (c & 1) {
	FAT[FAT_index+1]=(j>>4) & 0xFF;
	FAT[FAT_index]=(FAT[FAT_index] & 0xF) | ((j & 0xF) << 4);
      } else {
	FAT[FAT_index+1]=(FAT[FAT_index+1] & 0xF0) | ((j>>8) & 0x0F);
	FAT[FAT_index]=j & 0xFF;
      }
      Bts(p->buffered_FAT_dirty_bits,FAT_blk_cnt);
      if (FAT_index & (BLK_SIZE-1)==BLK_SIZE-1)
	Bts(p->buffered_FAT_dirty_bits,FAT_blk_cnt+1);
    }
    c=j;
  }
  CleanFATBuf(p);
  if (unlock)
    UnlockPartition(p);
  } catch
    if (unlock)
      UnlockPartition(p);
  return first;
}

DWORD AllocContiguousFAT12Clusters(JPartition *p,DWORD cnt, BOOL unlock)
{
  DWORD FAT_blk_cnt,FAT_index,first=1,i;
  BYTE *FAT=p->cur_FAT_blk;
  BOOL cont;
  try {
  if (unlock)
    LockPartition(p);
  while (TRUE) {
    first++;
    i=0;
    cont=TRUE;
    while (cont && i<cnt) {
      if ((i+first+1)*p->spc+p->data>p->size+p->offset)
	UnrecoverableSysError(0x0FFF0003);
      FAT_index=3*(first+i)/2;
      if ((first+i) & 1) {
	if (FAT[FAT_index+1] || (FAT[FAT_index] & 0xF0))
	  cont=FALSE;
	else
	  i++;
      } else {
	if (FAT[FAT_index] || (FAT[FAT_index+1] & 0xF))
	  cont=FALSE;
	else
	  i++;
      }
    }
    if (!cont)
      first+=i;
    else {
      for (i=0;i<cnt;i++) {
	FAT_index=3*(first+i)/2;
	FAT_blk_cnt=FAT_index/BLK_SIZE;
	Bts(p->buffered_FAT_dirty_bits,FAT_blk_cnt);
	if (FAT_index & (BLK_SIZE-1)==BLK_SIZE-1)
	  Bts(p->buffered_FAT_dirty_bits,FAT_blk_cnt+1);
	if (i+1==cnt) {
	  if ((first+i) & 1) {
	    FAT[FAT_index+1]=0xFF;
	    FAT[FAT_index]=FAT[FAT_index] | 0xF0;
	  } else {
	    FAT[FAT_index+1]=FAT[FAT_index+1] | 0x0F;
	    FAT[FAT_index]=0xFF;
	  }
	} else {
	  if ((first+i) & 1) {
	    FAT[FAT_index+1]=((first+i+1)>>4) & 0xFF;
	    FAT[FAT_index]=(FAT[FAT_index] & 0xF) | (((first+i+1) & 0xF) << 4);
	  } else {
	    FAT[FAT_index+1]=(FAT[FAT_index+1] & 0xF0) | (((first+i+1)>>8) & 0x0F);
	    FAT[FAT_index]=(first+i+1) & 0xFF;
	  }
	}
      }
      goto exit_this;
    }
  }
exit_this:
  CleanFATBuf(p);
  if (unlock)
    UnlockPartition(p);
  } catch
    if (unlock)
      UnlockPartition(p);
  return first;
}

DWORD AllocFAT32Clusters(JPartition *p,DWORD c1,DWORD cnt1,BOOL unlock)
{
  BOOL wrap_around=FALSE;
  DWORD c=c1,c2,cnt=cnt1,first=0xFFFFFFFF,j,l;
  l=(p->size+p->offset-p->data)/p->spc-1;
  try {
  if (unlock)
    LockPartition(p);
  CleanFATBuf(p);
  j=p->fis->most_recently_allocated;
  while (cnt--) {
    while (TRUE) {
      j++;
      if (j<1) j=1;
      if (j>=l) {
	if (wrap_around)
	  UnrecoverableSysError(0x0FFF0003);
	j=1;
	wrap_around=TRUE;
      }
      SetFAT32Buf(p,j,0);
      if (!p->cur_FAT_blk[j&(BLK_SIZE/4-1)])
	break;
    }
    if (first==0xFFFFFFFF)
      first=j;
    if (c>0 && c<l) {
      SetFAT32Buf(p,c,0);
      p->cur_FAT_blk[c&(BLK_SIZE/4-1)]=j;
      Bts(p->buffered_FAT_dirty_bits,0);
    }
    c=j;
  }

  if (c>0 && c<l) {
    SetFAT32Buf(p,c,0);
    p->cur_FAT_blk[c&(BLK_SIZE/4-1)]=0x0FFFFFFF;
    Bts(p->buffered_FAT_dirty_bits,0);
  }
  CleanFATBuf(p,0);
  InvalidateFATBuf(p);

  wrap_around=FALSE;
  c2=c;
  c=c1;cnt=cnt1;first=0xFFFFFFFF;
  j=p->fis->most_recently_allocated;
  while (cnt--) {
    while (TRUE) {
      j++;
      if (j<1) j=1;
      if (j>=l) {
	if (wrap_around)
	  UnrecoverableSysError(0x0FFF0003);
	j=1;
	wrap_around=TRUE;
      }
      SetFAT32Buf(p,j,1);
      if (!p->cur_FAT_blk[j&(BLK_SIZE/4-1)])
	break;
    }
    if (first==0xFFFFFFFF)
      first=j;
    if (c>0 && c<l) {
      SetFAT32Buf(p,c,1);
      p->cur_FAT_blk[c&(BLK_SIZE/4-1)]=j;
      Bts(p->buffered_FAT_dirty_bits,0);
    }
    c=j;
  }

  if (c>0 && c<l) {
    SetFAT32Buf(p,c,1);
    p->cur_FAT_blk[c&(BLK_SIZE/4-1)]=0x0FFFFFFF;
    Bts(p->buffered_FAT_dirty_bits,0);
  }
  CleanFATBuf(p,1);
  if (c!=c2)
    UnrecoverableSysError(0x0FFF0005);	//FAT's don't match
  p->fis->most_recently_allocated=j;
  p->fis->free_clusters=0xFFFFFFFF;
  WBlks(p,p->fis,p->file_system_info_sector,1,FALSE);
  if (unlock)
    UnlockPartition(p);
  } catch
    if (unlock)
      UnlockPartition(p);
  return first;
}

DWORD AllocContiguousFAT32Clusters(JPartition *p,DWORD cnt, BOOL unlock)
{
  DWORD first=1,i;
  BOOL cont;
  try {
  if (unlock)
    LockPartition(p);
  while (TRUE) {
    first++;
    i=0;
    cont=TRUE;
    while (cont && i<cnt) {
      if ((first+i+1)*p->spc+p->data>p->size+p->offset)
	UnrecoverableSysError(0x0FFF0003);
      SetFAT32Buf(p,first+i);
      if (p->cur_FAT_blk[(first+i)&(BLK_SIZE/4-1)])
	cont=FALSE;
      else
	i++;
    }
    if (!cont)
      first=first+i;
    else {
      CleanFATBuf(p);

      for (i=0;i<cnt;i++) {
	SetFAT32Buf(p,first+i,0);
	if (i+1==cnt)
	  p->cur_FAT_blk[(first+i)&(BLK_SIZE/4-1)]=0x0FFFFFFF;
	else
	  p->cur_FAT_blk[(first+i)&(BLK_SIZE/4-1)]=first+i+1;
	Bts(p->buffered_FAT_dirty_bits,0);
      }
      CleanFATBuf(p,0);
      InvalidateFATBuf(p);

      for (i=0;i<cnt;i++) {
	SetFAT32Buf(p,first+i,1);
	if (i+1==cnt)
	  p->cur_FAT_blk[(first+i)&(BLK_SIZE/4-1)]=0x0FFFFFFF;
	else
	  p->cur_FAT_blk[(first+i)&(BLK_SIZE/4-1)]=first+i+1;
	Bts(p->buffered_FAT_dirty_bits,0);
      }
      goto exit_this;
    }
  }
exit_this:
  CleanFATBuf(p,1);
  if (unlock)
    UnlockPartition(p);
  } catch
    if (unlock)
      UnlockPartition(p);
  return first;
}

DWORD UnusedDriveSpace(char drive=0)
{
  JPartition *p=DriveToPartition(drive);
  DWORD i,result=0,size;
  CheckJPartition(p);
  size=(p->size-(p->data-p->offset))/p->spc;
  if (p->type==PT_FAT12 || p->type==PT_FAT32) {
    for (i=0;i<size;i++)
      if (!NextClusterNum(p,i))
	result++;
  }
  return result*p->spc;
}

//c=0 means first cluster in chain
DWORD AllocClusters(JPartition *p,DWORD c=0,DWORD cnt=1,BOOL contiguous=FALSE,BOOL unlock=TRUE)
{
  if (!cnt)
    return c;
  CheckJPartition(p);
  if (p->type==PT_FAT12) {
    if (contiguous) {
      if (c) throw(TRP_FILE,1);
      return AllocContiguousFAT12Clusters(p,cnt,unlock);
    } else
      return AllocFAT12Clusters(p,c,cnt,unlock);
  } else if (p->type==PT_FAT32) {
    if (contiguous) {
      if (c) throw(TRP_FILE,1);
      return AllocContiguousFAT32Clusters(p,cnt,unlock);
    } else
      return AllocFAT32Clusters(p,c,cnt,unlock);
  }
}


//You typically don't need to call this yourself.
//WriteFAT12File calls it automatically.
BOOL NewFAT12DirEntry(JPartition *p,int cur_dir_cluster,FAT12DirEntry *de,BOOL free_old_chain)
{
  FAT12DirEntry *buf;
  int c,cur_dir_entry,entries_per_cluster,entries_per_blk;
  BOOL cont2,written=FALSE;
  char *ptr,*ptr2;
  DWORD i;
  BYTE ch;

    try {
    LockPartition(p);
    buf=MAlloc(BLK_SIZE*p->spc);
    entries_per_blk=BLK_SIZE/sizeof(FAT12DirEntry);
    entries_per_cluster=entries_per_blk*p->spc;
    RClusters(p,buf,cur_dir_cluster);
    cur_dir_entry=0;
    while (TRUE) {
      if (cur_dir_entry==entries_per_cluster) {
	c=NextClusterNum(p,cur_dir_cluster);
	if (c==0xFFFFFFFF||c=0) {
	  c=AllocClusters(p,cur_dir_cluster,1,FALSE,FALSE);
	  MemSet(buf,0,BLK_SIZE*p->spc);
	  WClusters(p,buf,c);
	} else
	  RClusters(p,buf,c);
	cur_dir_cluster=c;
	cur_dir_entry=0;
      }
      ch=buf[cur_dir_entry].name[0];
      if (!ch) {
	if (!written) {
	  MemCpy(&buf[cur_dir_entry],de,sizeof(FAT12DirEntry));
	  WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	     p->data+cur_dir_cluster*p->spc
	     +cur_dir_entry/entries_per_blk,1,FALSE);
	  cur_dir_entry++;
	  if (cur_dir_entry==entries_per_cluster) {
	    cur_dir_cluster=AllocClusters(p,cur_dir_cluster,1,FALSE,FALSE);
	    cur_dir_entry=0;
	    MemSet(buf,0,BLK_SIZE*p->spc);
	    WClusters(p,buf,cur_dir_cluster);
	  } else {
	    buf[cur_dir_entry].name[0]=0;
	    WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	       p->data+cur_dir_cluster*p->spc
	       +cur_dir_entry/entries_per_blk,1,FALSE);
	  }
  	  written=TRUE;
	}
	break;
      } else if (ch==0xE5) {
	if (!written) {
	  MemCpy(&buf[cur_dir_entry],de,sizeof(FAT12DirEntry));
	  WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	    p->data+cur_dir_cluster*p->spc
	    +cur_dir_entry/entries_per_blk,1,FALSE);
	  written=TRUE;
	}
      } else {
	cont2=TRUE;
	ptr=de->name;
	ptr2=buf[cur_dir_entry].name;
	for (i=0;i<11 && cont2;i++)
	  if (*ptr++!=*ptr2++)
	    cont2=FALSE;
	if (cont2) { //Del old entry with same name
	  buf[cur_dir_entry].name[0]=0xE5;
	  WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	     p->data+cur_dir_cluster*p->spc
	     +cur_dir_entry/entries_per_blk,1,FALSE);
	  if (free_old_chain)
	    FreeFAT12Clusters(p,buf[cur_dir_entry].cluster_lo,FALSE);
	}
      }
      cur_dir_entry++;
    }
    Free(buf);
    UnlockPartition(p);
    } catch
      UnlockPartition(p);
  return FALSE;
}

BOOL NewFAT32DirEntry(JPartition *p,DWORD cur_dir_cluster,FAT32DirEntry *de,BOOL free_old_chain)
{
  FAT32DirEntry *buf;
  DWORD c,cur_dir_entry,entries_per_cluster,entries_per_blk;
  BOOL cont2,written=FALSE;
  char *ptr,*ptr2;
  DWORD i;
  BYTE ch;

    try {
    LockPartition(p);
    buf=MAlloc(BLK_SIZE*p->spc);
    entries_per_blk=BLK_SIZE/sizeof(FAT32DirEntry);
    entries_per_cluster=entries_per_blk*p->spc;
    RClusters(p,buf,cur_dir_cluster);
    cur_dir_entry=0;
    while (TRUE) {
      if (cur_dir_entry==entries_per_cluster) {
	c=NextClusterNum(p,cur_dir_cluster);
	if (c==0xFFFFFFFF||c==0) {
	  c=AllocClusters(p,cur_dir_cluster,1,FALSE,FALSE);
	  MemSet(buf,0,BLK_SIZE*p->spc);
	  WClusters(p,buf,c);
	} else
	  RClusters(p,buf,c);
	cur_dir_cluster=c;
	cur_dir_entry=0;
      }
      ch=buf[cur_dir_entry].name[0];
      if (!ch) {
	if (!written) {
	  MemCpy(&buf[cur_dir_entry],de,sizeof(FAT32DirEntry));
	  WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	     p->data+cur_dir_cluster*p->spc
	     +cur_dir_entry/entries_per_blk,1,FALSE);
	  cur_dir_entry++;
	  if (cur_dir_entry==entries_per_cluster) {
	    cur_dir_cluster=AllocClusters(p,cur_dir_cluster,1,FALSE);
	    cur_dir_entry=0;
	    MemSet(buf,0,BLK_SIZE*p->spc);
	    WClusters(p,buf,cur_dir_cluster);
	  } else {
  	    buf[cur_dir_entry].name[0]=0;
	    WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	       p->data+cur_dir_cluster*p->spc
	       +cur_dir_entry/entries_per_blk,1,FALSE);
	  }
	  written=TRUE;
	}
	break;
      } else if (ch==0xE5) {
	if (!written) {
	  MemCpy(&buf[cur_dir_entry],de,sizeof(FAT32DirEntry));
	  WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	    p->data+cur_dir_cluster*p->spc
	    +cur_dir_entry/entries_per_blk,1,FALSE);
	  written=TRUE;
	}
      } else {
	cont2=TRUE;
	ptr=de->name;
	ptr2=buf[cur_dir_entry].name;
	for (i=0;i<11 && cont2;i++)
	  if (*ptr++!=*ptr2++)
	    cont2=FALSE;
	if (cont2) { //Del ond entry with same name
	  buf[cur_dir_entry].name[0]=0xE5;
	  WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	     p->data+cur_dir_cluster*p->spc
	     +cur_dir_entry/entries_per_blk,1,FALSE);
	  if (free_old_chain)
	    FreeFAT32Clusters(p,buf[cur_dir_entry].cluster_lo+
	      (buf[cur_dir_entry].cluster_hi<<16),FALSE);
	}
      }
      cur_dir_entry++;
    }
    Free(buf);
    UnlockPartition(p);
    } catch
      UnlockPartition(p);
  return FALSE;
}

BOOL NewJDirEntry(JPartition *p,DWORD cur_dir_cluster,JDirEntry *tempm,BOOL free_old_chain=TRUE)
{
  FAT12DirEntry de12;
  FAT32DirEntry de32;

  if (p->type==PT_FAT12) {
    if (!FillFAT12JDir(&de12,tempm))
      return FALSE;
    return NewFAT12DirEntry(p,cur_dir_cluster,&de12,free_old_chain);
  } else if (p->type==PT_FAT32) {
    if (!FillFAT32JDir(&de32,tempm))
      return FALSE;
    return NewFAT32DirEntry(p,cur_dir_cluster,&de32,free_old_chain);
  }
  return FALSE;
}

//This is a low level routine.
//Del() calls this
BOOL DelFAT12Files(JPartition *p,DWORD cur_dir_cluster,char *wild,
		     BOOL del_dir=FALSE)
{
  FAT12DirEntry *buf;
  DWORD cur_dir_entry,entries_per_cluster,entries_per_blk;
  char cbuf[16];
  BYTE ch;

    try {
    LockPartition(p);
    buf=MAlloc(BLK_SIZE*p->spc);
    entries_per_blk=BLK_SIZE/sizeof(FAT32DirEntry);
    entries_per_cluster=entries_per_blk*p->spc;
    RClusters(p,buf,cur_dir_cluster);
    cur_dir_entry=0;
    while (TRUE) {
      if (cur_dir_entry==entries_per_cluster) {
	cur_dir_cluster=NextClusterNum(p,cur_dir_cluster);
	RClusters(p,buf,cur_dir_cluster);
	cur_dir_entry=0;
      }
      ch=buf[cur_dir_entry].name[0];
      if (!ch)
	break;
      else if (ch!=0xE5 && ch!='.' && (del_dir ||
	     !(buf[cur_dir_entry].attr & FAT12_ATTR_DIR))) {
	if (FromFATName(cbuf,buf[cur_dir_entry].name) &&
	    WildFileNameList(wild,cbuf)) {
	  coutln SysText("ST_DELETE"),cbuf;
	  buf[cur_dir_entry].name[0]=0xE5;
	  WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	     p->data+cur_dir_cluster*p->spc
	     +cur_dir_entry/entries_per_blk,1,FALSE);
	  FreeFAT12Clusters(p,buf[cur_dir_entry].cluster_lo,FALSE);
	}
      }
      cur_dir_entry++;
    }
    Free(buf);
    UnlockPartition(p);
    } catch
      UnlockPartition(p);
  return FALSE;
}

BOOL DelFAT32Files(JPartition *p,DWORD cur_dir_cluster,char *wild,
		     BOOL del_dir=FALSE)
{
  FAT32DirEntry *buf;
  DWORD cur_dir_entry,entries_per_cluster,entries_per_blk;
  char cbuf[16];
  BYTE ch;

    try {
    LockPartition(p);
    buf=MAlloc(BLK_SIZE*p->spc);
    entries_per_blk=BLK_SIZE/sizeof(FAT32DirEntry);
    entries_per_cluster=entries_per_blk*p->spc;
    RClusters(p,buf,cur_dir_cluster);
    cur_dir_entry=0;
    while (TRUE) {
      if (cur_dir_entry==entries_per_cluster) {
	cur_dir_cluster=NextClusterNum(p,cur_dir_cluster);
	RClusters(p,buf,cur_dir_cluster);
	cur_dir_entry=0;
      }
      ch=buf[cur_dir_entry].name[0];
      if (!ch)
	break;
      else if (ch!=0xE5 && ch!='.' && (del_dir ||
	     !(buf[cur_dir_entry].attr & FAT32_ATTR_DIR))) {
	if (FromFATName(cbuf,buf[cur_dir_entry].name) &&
	    WildFileNameList(wild,cbuf)) {
	  coutln SysText("ST_DELETE"),cbuf;
	  buf[cur_dir_entry].name[0]=0xE5;
	  WBlks(p,&buf[cur_dir_entry & (0-entries_per_blk)],
	     p->data+cur_dir_cluster*p->spc
	     +cur_dir_entry/entries_per_blk,1,FALSE);
	  FreeFAT32Clusters(p,buf[cur_dir_entry].cluster_lo+
	    (buf[cur_dir_entry].cluster_hi<<16),FALSE);
	}
      }
      cur_dir_entry++;
    }
    Free(buf);
    UnlockPartition(p);
    } catch
      UnlockPartition(p);
  return FALSE;
}

//Save text file calls this
DWORD WriteFAT12File(JPartition *p,DWORD cur_dir_cluster,char *name,BYTE *buf,DWORD size,
		     DWORD Jdatetime=0,DWORD attr=0,BOOL raw=FALSE,
		     ArcCompressStruct **ac2=NULL)
{
  FAT12DirEntry de;
  DWORD c=0,cluster_cnt,
	cluster_size=BLK_SIZE*p->spc;
  ArcCompressStruct *ac=NULL;
  WORD ddate,dtime;
  BOOL contiguous;
  if (ac2) *ac2=NULL;
  if (!Jdatetime)
    Jdatetime=GetCurTimeJDate;
  JDateToDos(&dtime,&ddate,Jdatetime);
  if (p->type!=PT_FAT12)
    PutSysText("ST_NOT_FAT12");
  else if (!ToFATName(de.name,name))
    PutSysText("ST_INVALID_FILENAME");
  else {
    attr=FileAttr(name,attr);
    if (attr & J_ATTR_CONTIGUOUS)
      contiguous=TRUE;
    else
      contiguous=FALSE;
    if ((attr & J_ATTR_COMPRESSED) && !raw) {
      ac=CompressBuf(buf,size,attr);
      buf=ac;
      size=ac->compressed_size;
    }
    de.size=size;
    cluster_cnt=(size+cluster_size-1)/cluster_size;
    if (cluster_cnt)
      c=AllocClusters(p,0,cluster_cnt,contiguous);
    else
      c=0xFFF;
    de.cluster_lo=c;
    de.attr=attr;
    MemSet(de.Reserved,0,10);
    de.Date=ddate;
    de.Time=dtime;
    NewFAT12DirEntry(p,cur_dir_cluster,&de,TRUE);
    disk_status_display.w.w1=0x8000+cluster_cnt;
    if (cluster_cnt)
      WClusters(p,buf,c,cluster_cnt,TRUE);
    disk_status_display.w.w1=0;
    if (ac2)
      *ac2=ac;
    else
      Free(ac);
  }
  return c;
}

DWORD WriteFAT32File(JPartition *p,DWORD cur_dir_cluster,char *name,BYTE *buf,DWORD size,
		DWORD Jdatetime=0,DWORD attr=0,BOOL raw=FALSE,
		ArcCompressStruct **ac2=NULL)
{
  FAT32DirEntry de;
  DWORD c=0,cluster_cnt,
	cluster_size=BLK_SIZE*p->spc;
  ArcCompressStruct *ac=NULL;
  WORD ddate,dtime;
  BOOL contiguous;
  if (ac2) *ac2=NULL;
  if (!Jdatetime)
    Jdatetime=GetCurTimeJDate;
  JDateToDos(&dtime,&ddate,Jdatetime);

  if (p->type!=PT_FAT32)
    PutSysText("ST_NOT_FAT32");
  else if (!ToFATName(de.name,name))
    PutSysText("ST_INVALID_FILENAME");
  else {
    attr=FileAttr(name,attr);
    if (attr & J_ATTR_CONTIGUOUS)
      contiguous=TRUE;
    else
      contiguous=FALSE;
    if ((attr & J_ATTR_COMPRESSED) && !raw) {
      ac=CompressBuf(buf,size,attr);
      buf=ac;
      size=ac->compressed_size;
    }
    de.size=size;
    cluster_cnt=(size+cluster_size-1)/cluster_size;
    if (cluster_cnt)
      c=AllocClusters(p,0,cluster_cnt,contiguous);
    else
      c=0x0FFFFFFF;
    de.cluster_lo=c & 0xFFFF;
    de.cluster_hi=c >> 16;
    de.attr=attr;
    de.CrtDate=0;
    de.CrtTime=0;
    de.CrtTimeTenth=0;
    de.LstAccDate=0;
    de.NTres=0;
    de.WrtDate=ddate;
    de.WrtTime=dtime;
    NewFAT32DirEntry(p,cur_dir_cluster,&de,TRUE);
    disk_status_display.w.w1=0x8000+cluster_cnt;
    if (cluster_cnt)
      WClusters(p,buf,c,cluster_cnt,TRUE);
    disk_status_display.w.w1=0;
    if (ac2)
      *ac2=ac;
    else
      Free(ac);
  }
  return c;
}

void DelJDirEntry(JDirEntry *tempm)
{
  if (tempm) {
    Free(tempm->full_name);
    Free(tempm);
  }
}

void DelJDirList(JDirEntry *tempm)
{
  JDirEntry *tempm2;
  while (tempm) {
    tempm2=tempm->next;
    if (tempm->sub)
      DelJDirList(tempm->sub);
    DelJDirEntry(tempm);
    tempm=tempm2;
  }
}

JDirEntry *FindFAT12Files(char *wild,DWORD *fuf_flags,BOOL unlock)
{
  JPartition *p=Fs->cur_partition;
  FAT12DirEntry *buf;
  DWORD cur_dir_cluster=Fs->cur_dir_cluster,cur_dir_entry,entries_per_cluster;
  BYTE ch;
  JDirEntry *result=NULL,*tempm;

    try {
    if (unlock)
      LockPartition(Fs->cur_partition);
    buf=MAlloc(BLK_SIZE*p->spc);
    entries_per_cluster=BLK_SIZE*p->spc/sizeof(FAT12DirEntry);
    RClusters(Fs->cur_partition,buf,cur_dir_cluster);
    cur_dir_entry=0;
    while (TRUE) {
      if (cur_dir_entry==entries_per_cluster) {
	cur_dir_cluster=NextClusterNum(Fs->cur_partition,cur_dir_cluster);
	if (cur_dir_cluster==0xFFFFFFFF)
	  break;
	else {
	  RClusters(Fs->cur_partition,buf,cur_dir_cluster);
	  cur_dir_entry=0;
	}
      }
      ch=buf[cur_dir_entry].name[0];
      if (!ch)
	break;
      else if (ch!=0xE5) {
	tempm=MAlloc(sizeof(JDirEntry));
	if (FillJDirFAT12(tempm,&buf[cur_dir_entry])) {
	  if (Bt(fuf_flags,FUf_RECURSE) && (tempm->attr & J_ATTR_DIR) && tempm->name[0]!='.') {
	    tempm->next=result;
	    result=tempm;
	    tempm->full_name=AbsoluteDirName(tempm->name);
	    Cd(tempm->name);
	    tempm->sub=FindFAT12Files(wild,fuf_flags,FALSE);
	    Cd("..");
	  } else if ((!(tempm->attr & J_ATTR_DIR) || !Bt(fuf_flags,FUf_RECURSE)) &&
      	    WildFileNameList(wild,tempm->name)) {
	    tempm->next=result;
	    result=tempm;
	    tempm->full_name=AbsoluteFileName(tempm->name);
	  } else
	    DelJDirEntry(tempm);
	} else
	  DelJDirEntry(tempm);
      }
      cur_dir_entry++;
    }
    Free(buf);
    if (unlock)
      UnlockPartition(Fs->cur_partition);
    } catch
      if (unlock)
	UnlockPartition(Fs->cur_partition);
  return result;
}


JDirEntry *FindFAT32Files(char *wild,DWORD *fuf_flags,BOOL unlock)
{
  JPartition *p=Fs->cur_partition;
  FAT32DirEntry *buf;
  DWORD cur_dir_cluster=Fs->cur_dir_cluster,cur_dir_entry,entries_per_cluster;
  BYTE ch;
  JDirEntry *result=NULL,*tempm;

    try {
    if (unlock)
      LockPartition(Fs->cur_partition);
    buf=MAlloc(BLK_SIZE*p->spc);
    entries_per_cluster=BLK_SIZE*p->spc/sizeof(FAT32DirEntry);
    RClusters(Fs->cur_partition,buf,cur_dir_cluster);
    cur_dir_entry=0;
    while (TRUE) {
      if (cur_dir_entry==entries_per_cluster) {
	cur_dir_cluster=NextClusterNum(Fs->cur_partition,cur_dir_cluster);
	if (cur_dir_cluster==0xFFFFFFFF)
	  break;
	else {
	  RClusters(Fs->cur_partition,buf,cur_dir_cluster);
	  cur_dir_entry=0;
	}
      }
      ch=buf[cur_dir_entry].name[0];
      if (!ch)
	break;
      else if (ch!=0xE5) {
	tempm=MAlloc(sizeof(JDirEntry));
	if (FillJDirFAT32(tempm,&buf[cur_dir_entry])) {
	  if (Bt(fuf_flags,FUf_RECURSE) && (tempm->attr & J_ATTR_DIR) && tempm->name[0]!='.') {
	    tempm->next=result;
	    result=tempm;
	    tempm->full_name=AbsoluteDirName(tempm->name);
	    Cd(tempm->name);
	    tempm->sub=FindFAT32Files(wild,fuf_flags,FALSE);
	    Cd("..");
	  } else if ((!(tempm->attr & J_ATTR_DIR) || !Bt(fuf_flags,FUf_RECURSE)) &&
      	     WildFileNameList(wild,tempm->name)) {
	    tempm->next=result;
	    result=tempm;
	    tempm->full_name=AbsoluteFileName(tempm->name);
	  } else
	    DelJDirEntry(tempm);
	} else
	  DelJDirEntry(tempm);
      }
      cur_dir_entry++;
    }
    Free(buf);
    if (unlock)
      UnlockPartition(Fs->cur_partition);
    } catch
      if (unlock)
	UnlockPartition(Fs->cur_partition);
  return result;
}

JDirEntry *FindISOFiles(char *wild,DWORD *fuf_flags,BOOL unlock)
{
  JPartition *p=Fs->cur_partition;
  ISODirEntry *buf,*isoptr;
  DWORD cur_dir_cluster=Fs->cur_dir_cluster;
  JDirEntry *result=NULL,*tempm;
  int i;

  try {
  if (unlock)
    LockPartition(Fs->cur_partition);
  isoptr=MAlloc(BLK_SIZE*p->spc);
  RClusters(Fs->cur_partition,isoptr,cur_dir_cluster);
  if (isoptr->name_len==1 && isoptr->name==0) { //curdir
    i=(isoptr->size.little+BLK_SIZE*p->spc-1)/(BLK_SIZE*p->spc);
    buf=MAlloc(BLK_SIZE*p->spc*i);
    RClusters(Fs->cur_partition,buf,cur_dir_cluster,i);
    Free(isoptr);
  } else {
    buf=isoptr;
    i=1;
  }
  i*=BLK_SIZE*p->spc;
  while (i>0) {
    if (!buf->length) {
      buf++;
      i--;
    } else {
      tempm=MAlloc(sizeof(JDirEntry));
      if (FillJDirISO(tempm,buf)) {
	if (Bt(fuf_flags,FUf_RECURSE) && (tempm->attr & J_ATTR_DIR) && tempm->name[0]!='.') {
	  tempm->next=result;
	  result=tempm;
	  tempm->full_name=AbsoluteDirName(tempm->name);
	  Cd(tempm->name);
	  tempm->sub=FindISOFiles(wild,fuf_flags,FALSE);
	  Cd("..");
	} else if ((!(tempm->attr & J_ATTR_DIR) || !Bt(fuf_flags,FUf_RECURSE)) &&
      	   WildFileNameList(wild,tempm->name)) {
	  tempm->next=result;
	  result=tempm;
	  tempm->full_name=AbsoluteFileName(tempm->name);
	} else
	  DelJDirEntry(tempm);
      } else
	DelJDirEntry(tempm);
      i-=buf->length;
      buf+=buf->length;
    }
  }
  Free(buf);
  if (unlock)
    UnlockPartition(Fs->cur_partition);
  } catch
    if (unlock)
      UnlockPartition(Fs->cur_partition);
  return result;
}


int CompareJDir(JDirEntry **e1,JDirEntry **e2)
{
  int d1=0,d2=0;
  if ((*e1)->attr & J_ATTR_DIR)
    d1=1;
  if ((*e2)->attr & J_ATTR_DIR)
    d2=1;
  if (d1!=d2)
    return d2-d1;
  else
    return StrCmp((*e1)->name,(*e2)->name);
}


void SortJDirFiles(JDirEntry **tempm)
{
  int i,cnt=0;
  JDirEntry *tempm1=*tempm,*tempm2,**sort_buf;
  if (tempm1) {
    tempm2=tempm1;
    while (tempm2) {
      cnt++;
      tempm2=tempm2->next;
    }
    sort_buf=MAlloc(cnt*sizeof(DWORD));
    i=0;
    tempm2=tempm1;
    while (tempm2) {
      sort_buf[i++]=tempm2;
      tempm2=tempm2->next;
    }
    QSort(sort_buf,cnt,sizeof(DWORD),&CompareJDir);
    tempm1=sort_buf[0];
    *tempm=tempm1;
    for (i=0;i<cnt-1;i++) {
      tempm2=sort_buf[i];
      tempm2->next=sort_buf[i+1];
    }
    tempm2=sort_buf[i];
    tempm2->next=NULL;
    Free(sort_buf);

    tempm2=tempm1;
    while (tempm2) {
      if (tempm2->sub)
	SortJDirFiles(&tempm2->sub);
      tempm2=tempm2->next;
    }
  }
}

JDirEntry *FindFiles(char *wild,DWORD *fuf_flags=NULL)
{
  JPartition *p=Fs->cur_partition;
  JDirEntry *result=NULL;
  DWORD my_flags=0;
  if (!fuf_flags) fuf_flags=&my_flags;
  CheckJPartition(p);
  if (p->type==PT_FAT12)
    result=FindFAT12Files(wild,fuf_flags,TRUE);
  else if (p->type==PT_FAT32)
    result=FindFAT32Files(wild,fuf_flags,TRUE);
  else if (p->type==PT_ISO9660)
    result=FindISOFiles(wild,fuf_flags,TRUE);
  else {
    PutSysText("ST_FILE_SYSTEM_NOT_SUPPORTED");
    result=NULL;
  }
  SortJDirFiles(&result);
  return result;
}

void PutFileLink(char *name,int line=0)
{
  char *buf;
  if (!name) return;
  buf=AbsoluteFileName(name);
  if (line)
    PrintF("$LK \"%12s,%04d\",\"FL:%s,%d\"$",
      name,line,buf,line);
  else
    PrintF("$LK \"%12s\",\"FI:%s\"$",
      name,buf);
  Free(buf);
}

void PutDirLink(char *name)
{
  char *buf;
  if (!name) return;
  buf=AbsoluteDirName(name);
  PrintF("$MA +A \"%12s\",\"Cd(\\\"%s\\\");Dir;\r\"$",
      name,buf);
  Free(buf);
}

void DirFAT(char *wild,BOOL show_clusters)
{
  JPartition *p=Fs->cur_partition;
  JDirEntry *tempm1=NULL,*tempm2;
  DWORD my_flags=0;

  tempm1=FindFiles(wild,&my_flags);

  if (tempm1) {
    coutln "Directory of ",Fs->cur_dir,
      "\r\n__DATE__ __TIME______________",
      "__SIZE__";
    while (tempm1) {
      tempm2=tempm1->next;
      PrintF("%D %T",
	tempm1->datetime.dt.date,tempm1->datetime.dt.time);

      if (tempm1->attr & J_ATTR_DIR)
	PutDirLink(tempm1->name);
      else
	PutFileLink(tempm1->name);

      cout tempm1->size;
      if (show_clusters)
	cout " ",tempm1->cluster;
      CrLf;
      DelJDirEntry(tempm1);
      tempm1=tempm2;
    }
  } else {
    PutSysText("ST_NO_MATCHING_ENTRIES");
    return;
  }
}


