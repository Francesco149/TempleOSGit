	USE16
	JMP	WORD J_START2
////**************************PROCEDURE*************************
//  ASM Global variables required for 16-bit start-up
	ALIGN	4
SYS_BOOT_BASE::		DD	?;  	//Fixed offset from start used by reboot_J
SYS_BOOT_HEADER_BASE::	DD	?;
OS_32START::		DD	INIT_OS;

	ALIGN	16
GDTTAB::		DB	MAXGDT*8 DUP(0);
SYS_BOOT_CODE::		DD	0xFF;
SYS_MEMBLKS::		DD	0;
FREE_GDT_LIST::		DD	0;
ROOT_TSS::		DB	TSS_STRUCT_SIZE DUP(0);
SYS_TEMP_PTR::		DD	0,0;

////**************************PROCEDURE*************************
//EBX is SYS_BOOT_CODE (value passed from boot blk)
J_START2::
	MOV	AX,(0xA0000-2*BLK_SIZE)/16
	MOV	SS,AX
	MOV	SP,2*BLK_SIZE
	PUSH	EBX		//will be SYS_BOOT_CODE
	MOV	AX,0xB800
	MOV	ES,AX
	MOV	DWORD ES:[0],'J'+0xF000
	MOV	DWORD ES:[4],0
	MOV	ECX,1200000	//Delay
	CALL	BUSY_WAIT

	CALL	WORD GET_IP
GET_IP:
	POP	BX
	SUB	BX,GET_IP
	SHR	BX,4
	MOV	AX,CS
	ADD	AX,BX
	PUSH	AX
	PUSH	WORD J_START3
	RETF
J_START3::
//XSUM Kernel
	MOV	AX,CS
	DEC	AX
	MOV	DS,AX
	XOR	ESI,ESI
	MOV	ECX,DWORD 8[ESI]	//Get length
	SHR	ECX,4
	MOV	EBX,J_XSUM
@@2:	LODSD
	XOR	EBX,EAX
	LODSD
	XOR	EBX,EAX
	LODSD
	XOR	EBX,EAX
	LODSD
	XOR	EBX,EAX
	XOR	ESI,ESI
	MOV	AX,DS
	INC	AX
	MOV	DS,AX
	LOOP	@@2
	MOV	DWORD ES:[4],'O'+65536*'K'+0xF000F000
	OR	EBX,EBX
	JZ	J_CONT_START

//XSUM Error
	MOV	DWORD ES:[4],'X'+65536*'M'+0xF000F000
@@3:	JMP	@@3

BUSY_WAIT::
	MOV	DX,0x379	//Par Port
@@1:	IN	AL,DX
	DEC	ECX
	JNZ	@@1
	RET

////**************************PROCEDURE*************************
J_CONT_START:
	STI
//Enter Graphics Mode
exe {
  int ch,video_mode;
  do {
    CrLf;
    coutln "1) VGA  640x480x16";
    coutln "2) SVGA 800x600x16--not supported by all computers";
    cout "Video Mode:";
    ch=GetChar;
  } while (ch<'1' || ch>'2');
  video_mode=ch-'0';
  switch (video_mode) {
    case 1:
      ExePutS("MOV AX,0x12");
      break;
    case 2:
      ExePutS("MOV AX,0x6A");
      break;
  }
}
	INT	0x10		//ENABLE VGA

//Get memory map
	MOV	AX,0xE801
	INT	0x15
	MOV	AX,CS
	MOV	DS,AX
	ADD	DX,0x101
	MOV	WORD [SYS_MEMBLKS+2],DX

	CLI

//Enable A20
	IN	AL,0x92
	OR	AL,2
	OUT	0x92,AL

	CLD			//Start with known registers
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	MOV	FS,AX
	MOV	GS,AX
	XOR	EAX,EAX
	XOR	EBX,EBX
	XOR	ECX,ECX
	XOR	EDX,EDX
	XOR	ESI,ESI
	XOR	EDI,EDI
	XOR	EBP,EBP

	XOR	EAX,EAX
	MOV	AX,CS
	SHL	EAX,4
	MOV	DWORD [SYS_BOOT_BASE],EAX

	POP	DWORD [SYS_BOOT_CODE]

	MOV	BX,CS
	DEC	BX
	MOV	GS,BX
	MOV	EBX,DWORD GS:[4]
	ADD	EAX,EBX
	SUB	EAX,16
	MOV	DWORD [SYS_BOOT_HEADER_BASE],EAX

	MOV	DWORD [GDTTAB+SYS_BOOT_DS_SEL],0x000FFFF
	MOV	DWORD [GDTTAB+SYS_BOOT_DS_SEL+4],0x0CF9200
	MOV	DWORD [GDTTAB+SYS_BOOT_CS_SEL],0x000FFFF
	MOV	DWORD [GDTTAB+SYS_BOOT_CS_SEL+4],0x0CF9A00
	MOV	EAX,DWORD [SYS_BOOT_BASE]
	ADD	DWORD [GDTTAB+SYS_BOOT_DS_SEL+2],EAX
	ADD	DWORD [GDTTAB+SYS_BOOT_CS_SEL+2],EAX

					// SETUP POINTER TO LIMIT AND BASE
					//OF GDT.  USE ENTRY (0) BECAUSE IT IS
					//INVALID.
	MOV	WORD [SYS_TEMP_PTR],MAXGDT*8-1
	MOV	EAX,DWORD [SYS_BOOT_BASE]
	ADD	EAX,GDTTAB+NULL_SEL
	MOV	DWORD [SYS_TEMP_PTR+2],EAX
	MOV	WORD [SYS_TEMP_PTR+6],0

//	  LGDT	  FWORD SYS_TEMP_PTR
	DB	0x67,0x0F,0x01,0x15;
	DD	SYS_TEMP_PTR;

//	  MOV	  EAX,CR0		  //ENTER PROTECTED MODE!!
	DB	0x0F,0x20,0xC0;

	OR	AL,1


//	  MOV	  CR0,EAX
	DB	0x0F,0x22,0xC0;

	DB	0x66,0xEA;		 //JMP SYS_CS_SEL:INIT_OS
	DD	INIT_OS;
	DW	SYS_BOOT_CS_SEL;
////**************************PROCEDURE*************************
//  ASM Global variables not required for 16-bit start-up
	ALIGN	4
IDTTAB::		DB	MAXIDT*8 DUP(0);
SYS_HEAP_BASE::		DD	0x100000;
SYS_HEAP_LIMIT::	DD	0;
DC_COL::		DD	0; //For raw PutChar

exe {
  ExePrintF("SYS_GRMODE:: DD %d;",video_mode);
}
SYS_GRWIDTH::		DD	?;
SYS_GRHEIGHT::		DD	?;

SYS_HASH_TABLE::	DD	0;
SYS_FLAGS::		DD	0x8; //RAW_CRT_OUT=0x80
SYS_IRQ_FLAGS::		DD	0;
SYS_IRQ_BUSY_FLAGS::	DD	0;
SYS_TEXTBASE::		DD	0;
SYS_GRBASE::	DD	0;
SYS_GRBASE2::	DD	0;
SYS_CUR_SCAN_CODE::	DD	0;
SYS_EXTERN_TABLE::	DD	0;
MEM_FREE_LIST::		DD	0;
FREE_PAGE_CACHE::	DD	FREE_PAGE_CACHE_SIZE DUP(0);
FREE_PAGE_CACHE2::	DD	32 DUP(0);
JIFFIES:: 		DD 	0;
PROGRESS1::		DD	0;
PROGRESS2::		DD	0;
SYS_SWAPS_CNTER::	DD	0;
SYS_CUR_FOCUS_TASK::	DD	0;


////**************************PROCEDURE*************************
	ALIGN 16,0x90
	USE32
INIT_OS::
	MOV	AX,SYS_BOOT_DS_SEL	//LOAD DS SELECTOR
	MOV	DS,AX
	MOV	ES,AX

	MOV	DWORD [GDTTAB+ZERO_DS_SEL],0x0000FFFF
	MOV	DWORD [GDTTAB+ZERO_DS_SEL+4],0x00CF9200
	MOV	DWORD [GDTTAB+SYS_CS_SEL],0x0000FFFF
	MOV	DWORD [GDTTAB+SYS_CS_SEL+4],0x00CF9A00

//INIT FREE GDT ENTRIES
	MOV	DWORD [FREE_GDT_LIST],0
	MOV	ECX,MAXGDT-FIRST_FREE_SEL/8
	MOV	EAX,FIRST_FREE_SEL
@@3:	MOV	EBX,DWORD [FREE_GDT_LIST]
	MOV	DWORD GDTTAB[EAX],EBX
	MOV	DWORD [FREE_GDT_LIST],EAX
	ADD	EAX,8
	LOOP	@@3

//Patch absolute addresses
	MOV	ESI,DWORD [SYS_BOOT_HEADER_BASE]
	MOV	EDI,DWORD [SYS_BOOT_BASE]
	MOV	AX,ZERO_DS_SEL
	MOV	DS,AX
	MOV	ES,AX
	MOV	ECX,DWORD 1[ESI]
	LEA	ESI,DWORD 1+4+1[ESI]
@@10:	LODSD
	ADD	EAX,EDI
	ADD	DWORD [EAX],EDI
	LOOP	@@10

	MOV	AX,ZERO_DS_SEL
	MOV	DS,AX
	MOV	ES,AX
	MOV	FS,AX
	MOV	GS,AX
	MOV	SS,AX
	MOV	ESP,0x800000		//TEMP

	DB	0xEA;		      //JMP SYS_CS_SEL:CONT_INIT_OS
	DD	CONT_INIT_OS;
	DW	SYS_CS_SEL;

CONT_INIT_OS::
	MOV	DWORD [SYS_HEAP_BASE],0x100000
	CALL	INIT_MEM

//INIT INTERRUPT TABLE
	MOV	ECX,MAXIDT
	MOV	EDI,IDTTAB
	MOV	ESI,IRQ_VECTORS
@@1:	LODSW
	STOSW
	MOV	AX,SYS_CS_SEL
	STOSW
	MOV	AX,0x8E00 //E=32-bit irq gate
	STOSW
	MOVSW
	LOOP	@@1

	MOV	WORD [SYS_TEMP_PTR],MAXIDT*8-1
	MOV	DWORD [SYS_TEMP_PTR+2],IDTTAB
	MOV	WORD [SYS_TEMP_PTR+6],0
//	  LIDT	  FWORD SYS_TEMP_PTR
	DB	0x0F,0x01,0x1D;
	DD	SYS_TEMP_PTR;

//INIT SYSTEM TSS
	PUSH	DEFAULT_STACK
	PUSH	ROOT_TSS
	CALL	CP_INIT_TSS+4
	ADD	ESP,8
	MOV	FS,AX
	MOV	ESP,DWORD FS:[TSS_ESP]

	JMP	DWORD CP_OS_MAIN+4

////**************************PROCEDURE*************************
CP_REBOOT::
	MOV	EAX,ZERO_DS_SEL
	MOV	ES,AX
	MOV	WORD ES:[0x472],0

	MOV	AL,0x8F
	OUT	0x70,AL
	OUT	0xEB,AL
	MOV	AL,0
	OUT	0x71,AL
	OUT	0xEB,AL
	MOV	AL,0
	OUT	0x70,AL
	OUT	0xEB,AL

	IN	AL,0x92
	OR	AL,1
	OUT	0x92,AL
	OUT	0xEB,AL
@@100:	JMP	@@100

////**************************PROCEDURE*************************
ALPHA_BITMAP::		DD	0x0000000,0x00000000,0x87FFFFFF,0x07FFFFFE;
			DD	0,0,0,0;
ALPHA_NUMERIC_BITMAP::	DD	0x0000000,0x03FF0000,0x87FFFFFF,0x07FFFFFE;
			DD	0,0,0,0;
FILENAME_CHARS_BITMAP::	DD	0x0000000,0x03FF4000,0x87FFFFFF,0x07FFFFFE;
			DD	0,0,0,0;
DEC_NUMERIC_BITMAP::	DD	0x0000000,0x03FF0000,0,0;
			DD	0,0,0,0;
HEX_NUMERIC_BITMAP::	DD	0x0000000,0x03FF0000,0x7E,0x7E;
			DD	0,0,0,0;
PRINTABLE_CHARS_BITMAP::
	DD	0x00002200,0xFFFFFFFF,0xFFFFFFFF,0x7FFFFFFF;
	DD	0,0,0,0;
DISPLAYABLE_CHARS_BITMAP::
	DD	0x00000000,0xFFFFFFFF,0xFFFFFFFF,0x7FFFFFFF;
	DD	0x00001FFF,0,0,0;


	ALIGN	4,0x90
CP_RUN_STATEMENT::
	PUSHAD
	MOV	EBP,ESP
	MOV	ESI,DWORD SP_PARAM1[EBP]
	OR	ESI,ESI
	JZ	@@100
	CALL	ESI
	MOV	EBP,ESP
	MOV	SP_EAX[EBP],EAX
	POPAD
	RET
@@100:	POPAD
	XOR	EAX,EAX
	RET


