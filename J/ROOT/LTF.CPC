
DWORD ltf_display_types[2],ltf_nondisplay_invisible_types[2],
      ltf_form_types[2],ltf_data_types[2];

ltf_display_types[0]=(1<<LTFT_TEXT)|(1<<LTFT_DATA);
ltf_display_types[1]=(1<<(LTFT_MENU_VALUE-32))|
	(1<<(LTFT_HIDE_START-32)) |
	(1<<(LTFT_TREE-32))|
	(1<<(LTFT_HIDE_END-32))|
	(1<<(LTFT_MACRO-32))|
	(1<<(LTFT_BUTTON-32))|
	(1<<(LTFT_CHECK_BOX-32))|
	(1<<(LTFT_LINK-32))|
	(1<<(LTFT_ANCHOR-32))|
	(1<<(LTFT_PICTURE-32))|
	(1<<(LTFT_INSERT_BINARY-32))|
	(1<<(LTFT_INSERT_BINARY_TYPE-32))|
	(1<<(LTFT_INSERT_BINARY_SIZE-32));
ltf_nondisplay_invisible_types[0]=
  (1<<LTFT_PAGE_LENGTH)|
  (1<<LTFT_LEFT_MARGIN)|
  (1<<LTFT_RIGHT_MARGIN)|
  (1<<LTFT_HEADER)|
  (1<<LTFT_FOOTER)|
  (1<<LTFT_INDENT)|
  (1<<LTFT_FOREGROUND_COLOR)|
  (1<<LTFT_BACKGROUND_COLOR)|
  (1<<LTFT_DEFAULT_FOREGROUND_COLOR)|
  (1<<LTFT_DEFAULT_BACKGROUND_COLOR)|
  (1<<LTFT_LINK_FOREGROUND)|
  (1<<LTFT_LINK_BACKGROUND)|
  (1<<LTFT_MACRO_FOREGROUND)|
  (1<<LTFT_MACRO_BACKGROUND)|
  (1<<LTFT_ANCHOR_FOREGROUND)|
  (1<<LTFT_ANCHOR_BACKGROUND)|
  (1<<LTFT_HIDDEN_FOREGROUND)|
  (1<<LTFT_HIDDEN_BACKGROUND)|
  (1<<LTFT_TREE_FOREGROUND)|
  (1<<LTFT_TREE_BACKGROUND)|
  (1<<LTFT_WORD_WRAP)|
  (1<<LTFT_UNDERLINED)|
  (1<<LTFT_INVERTED)|
  (1<<LTFT_BLINK);
ltf_nondisplay_invisible_types[1]=
  (1<<(LTFT_SHIFTED_X-32))|
  (1<<(LTFT_SHIFTED_Y-32))|
  (1<<(LTFT_PICTURE-32));
ltf_form_types[0]=ltf_display_types[0] & ~(1<<LTFT_TEXT);
ltf_form_types[1]=ltf_display_types[1] | (1<<(LTFT_HEX_EDIT-32));
ltf_data_types[0]=(1<<LTFT_DATA);
ltf_data_types[1]=(1<<(LTFT_HEX_EDIT-32))|
		(1<<(LTFT_CHECK_BOX-32));

LtfBinEntry *LtfFindBin(Ltf *l,DWORD num)
{
  LtfBinEntry *b=l->bin_root.next;
  while (b!=&l->bin_root) {
    if (b->num==num)
      return b;
    b=b->next;
  }
  return NULL;
}

void LtfValidateBins(Ltf *l)
{
  LtfBinEntry *b=l->bin_root.next,*b1;
  LtfEntry *cl=l->dummy.next;
  while (b!=&l->bin_root) {
    b->use_cnt=0;
    b=b->next;
  }
  while (cl!=l) {
    if (cl->flags & LTFLF_HAS_BIN) {
      if (cl->bin_data)
	cl->bin_data->use_cnt++;
      else {
	cl->bin_data=LtfFindBin(l,cl->bin_num);
	if (cl->bin_data)
	  cl->bin_data->use_cnt++;
      }
    }
    cl=cl->next;
  }
  b=l->bin_root.next;
  l->cur_bin_num=1;
  while (b!=&l->bin_root) {
    b1=b->next;
    if (!b->use_cnt) {
      RemQue(b);
      Free(b->data,l->mem_tss);
      Free(b,l->mem_tss);
    } else {
      if (b->num>=l->cur_bin_num)
	l->cur_bin_num=b->num+1;
    }
    b=b1;
  }
}

#include "GRAPH"

void LtfDelBin(LtfBinEntry *b,TssStruct *tss)
{
  b->use_cnt--;
  if (!b->use_cnt) {
    RemQue(b);
    Free(b->data,tss);
    Free(b,tss);
  }
}

void LtfDelEntry2(LtfEntry *cl,TssStruct *tss)
{
  if (Bt(ltf_display_types,cl->btype))
    Free(cl->display,tss);
  if (cl->btype>=LTFT_DATA)
    Free(cl->plain_text,tss);
  if (cl->flags & LTFLF_LEFT_MACRO)
    Free(cl->left_macro,tss);
  if (cl->flags & LTFLF_RIGHT_MACRO)
    Free(cl->right_macro,tss);
  if (cl->flags & LTFLF_AUX_STRING)
    Free(cl->aux_string,tss);
  if (cl->flags & LTFLF_HAS_BIN)
    LtfDelBin(cl->bin_data,tss);
  Free(cl,tss);
}

void LtfFormForward(Ltf *l)
{
  LtfEntry *cl=l->cur_entry,*cl1=cl->last;
  if (l->flags & LTFF_FORM) {
    while (cl!=cl1 && !Bt(ltf_form_types,cl->btype)) {
      cl=cl->next;
      l->cur_data_col=cl->min_col;
    }
  }
  l->cur_entry=cl;
}

void LtfFormBackward(Ltf *l)
{
  LtfEntry *cl=l->cur_entry,*cl1=cl->next;
  if (l->flags & LTFF_FORM) {
    while (cl!=cl1 && !Bt(ltf_form_types,cl->btype)) {
      cl=cl->last;
      l->cur_data_col=cl->min_col;
    }
  }
  l->cur_entry=cl;
}

public void LtfHome(Ltf *l)
{
  if (!l) return;
  l->cur_entry=l->dummy.next;
  l->cur_data_col=l->cur_entry->min_col;
  l->x=0;
  l->y=0;
  l->line_start_col=0;
  l->cur_top_line_num=0;
  LtfFormForward(l);
}

public void LtfReset(Ltf *l,BOOL is_old,BOOL root_mem=FALSE)
{
  LtfEntry *cl,*cl1;
  if (!l) return;
  if (is_old) {
    cl=l->dummy.next;
    while (cl!=l) {
      cl1=cl->next;
      if (root_mem)
	LtfDelEntry2(cl,root_tss);
      else
	LtfDelEntry2(cl,l->mem_tss);
      cl=cl1;
    }
  }
  l->text_attribute=(WHITE<<4)+BLUE;
  l->link_attribute=(WHITE<<4)+RED;
  l->macro_attribute=(WHITE<<4)+LTBLUE;
  l->anchor_attribute=(WHITE<<4)+BLACK;
  l->hidden_attribute=(WHITE<<4)+BLACK;
  l->tree_attribute=(WHITE<<4)+PURPLE;
  l->flags=0;
  l->dummy.next=l;
  l->dummy.last=l;
  l->bin_root.next=&l->bin_root;
  l->bin_root.last=&l->bin_root;
  l->cur_bin_num=1;
  l->recalc_start=l;
  l->menu_ltf=NULL;
  l->dollar_buf_ptr=0;
  l->cmd_char='l';
  l->indent=0;
  l->page_line_num=0;
  l->page_length=66;
  l->left_margin=LTF_DEFAULT;
  l->right_margin=LTF_DEFAULT;
  l->header=LTF_DEFAULT;
  l->footer=LTF_DEFAULT;

  cl=&l->dummy;
  cl->type=LTFT_ERROR;
  cl->flags=0;
  cl->flags2=0;
  cl->x=0;
  cl->y=0;
  cl->min_col=0;
  cl->max_col=0;
  cl->indent=l->indent;
  cl->page_line_num=l->page_line_num;
  cl->left_margin=l->left_margin;
  cl->right_margin=l->right_margin;

  LtfHome(l);
}

public void LtfDel(Ltf *l,BOOL root_mem=FALSE)
{
  Ltf *m;

  if (!l) return;
  m=l->menu_ltf;
  LtfReset(l,TRUE,root_mem);
  Free(l->find_replace,l->mem_tss);
  Free(l->dollar_buf,l->mem_tss);
  LtfDel(m,root_mem);
  Free(l,l->mem_tss);
}


void LtfFormatData(LtfEntry *cl)
{
  BOOL *b;
  DWORD *D;
  int i;
  if (cl->btype==LTFT_DATA) {
    D=cl->data;
    if (cl->flags2 & LTFLF2_DATA_IS_PTR)
      SPrintF(cl->display,cl->aux_string,*D,cl->my_format_data);
    else
      SPrintF(cl->display,cl->aux_string,D,cl->my_format_data);
    if (cl->flags2 & LTFLF2_HAS_TERMINATOR) {
      i=StrLen(cl->display);
      cl->display[i++]='_';
      cl->display[i]=0;
    }
  } else if (cl->btype==LTFT_CHECK_BOX) {
    if (cl->flags2 & LTFLF2_DATA_IS_PTR)
      b=cl->data;
    else
      b=&cl->data;
    if (*b)
      cl->flags2|=LTFLF2_CHECKED;
    else
      cl->flags2&=~LTFLF2_CHECKED;
  }
}

void LtfGetData(LtfEntry *cl)
{
  BOOL *b;
  int i;
  if (cl->btype==LTFT_DATA) {
    i=StrLen(cl->display);
    if (cl->flags2 & LTFLF2_HAS_TERMINATOR)
      cl->display[--i]=0;
    if (i>cl->len+cl->min_col)
      cl->display[cl->len+cl->min_col]=0;
    if (cl->flags2 & LTFLF2_DATA_IS_PTR)
      GetF(cl->display,cl->aux_string,cl->data,cl->my_format_data);
    else
      GetF(cl->display,cl->aux_string,&cl->data,cl->my_format_data);
    if (cl->flags2 & LTFLF2_HAS_TERMINATOR)
      cl->display[i]='_';
  } else if (cl->btype==LTFT_CHECK_BOX) {
    if (cl->flags2 & LTFLF2_DATA_IS_PTR)
      b=cl->data;
    else
      b=&cl->data;
    if (cl->flags2 & LTFLF2_CHECKED)
      *b=TRUE;
    else
      *b=FALSE;
  }
}


extern void DrawBorder(DWORD solid,int l,int r,int t,int b,BYTE attr,BOOL clip);

public void LtfUpdateWindowJoin(Ltf *l,BOOL to_screen,BOOL has_cursor,
  BOOL recalc,BOOL find_cur_entry)
{
  int i,j,k,x,x0,y,y0,D,d2,col,col2,best_col=0,best_d=0x7FFFFFFF;
  int num_entries=0;
  LtfEntry *cl,*cl2,*best_cl=l->cur_entry,*pg_found,*alias;
  DWORD w,w1,w2;
  BYTE *bptr;
  BYTE ch,*ptr,buf[16];
  BOOL cont,cont2,del_cl,skipped_update,tree_collapsed;
  DWORD hide_collapsed[4];
  TssStruct *tss=l->tss,*mem_tss=l->mem_tss;
  BOOL resize=FALSE,found_cu_cmd=FALSE;
  BOOL extra_processing;
  GrBitMap *base=GrNew(grbase2);
  int  left_margin=tss->window_left,right_margin=tss->window_right;

  if (!l) return;
  if (to_screen || find_cur_entry) {
    recalc=TRUE;
    l->recalc_start=l;
  }

  if (has_cursor) {
    if (Btr(&tss->crt_flags,CRTf_HAS_BEEN_RESIZED))
      resize=TRUE;

    if (Btr(&tss->crt_flags,CRTf_SCROLL_X))
      l->line_start_col=(tss->scroll_x*(l->max_x-l->min_x+1)/
	(right_margin-left_margin+4)+l->min_x) & 0xFFFFFFFC;
    if (Btr(&tss->crt_flags,CRTf_SCROLL_Y))
      l->cur_top_line_num=tss->scroll_y*(l->max_y-l->min_y+1)/
	(tss->window_bottom-tss->window_top+1)+l->min_y;
  }
  x=0; y=0;
  l->indent=0;
  l->page_line_num=0;
  l->left_margin=LTF_DEFAULT;
  l->right_margin=LTF_DEFAULT;
  l->header=LTF_DEFAULT;
  l->footer=LTF_DEFAULT;
  if (recalc) {
    pg_found=NULL;
    cl=l->dummy.next;
    while (cl!=l) {
      num_entries++;
      if (cl->btype==LTFT_CLEAR)
	pg_found=cl;
      cl=cl->next;
    }
    if (pg_found) {
      cl=l->dummy.next;
      while (cl!=pg_found) {
	cl2=cl->next;
	if (!(cl->flags2 & LTFLF2_HOLD)) {
	  if (cl==l->cur_entry) {
	    l->cur_entry=cl2;
	    l->cur_data_col=cl2->min_col;
	  }
	  if (cl==l->recalc_start)
	    l->recalc_start=cl2;
	  RemQue(cl);
	  LtfDelEntry2(cl,mem_tss);
	}
	cl=cl2;
      }
    }
    i=num_entries-l->max_entries;
    if (i>200) {
      cl=l->dummy.next;
      y=cl->y;
      for (j=0;j<i;j++) {
	cl2=cl->next;
	if (!(cl->flags2 & LTFLF2_HOLD)) {
	  if (cl==l->cur_entry) {
	    l->cur_entry=cl2;
	    l->cur_data_col=cl2->min_col;
	  }
 	  if (cl==l->recalc_start)
	    l->recalc_start=cl2;
	  if (best_cl==cl2) {
	    best_cl=cl2;
	    best_col=cl2->min_col;
	  }
	  RemQue(cl);
	  LtfDelEntry2(cl,mem_tss);
	}
	cl=cl2;
      }
      l->recalc_start=l;  //This needs fixing
      y-=cl->y;
      if (l->cur_top_line_num>=tss->window_bottom-tss->window_top)
	l->cur_top_line_num+=y;
    }
  }
  l->min_x=0x7FFFFFFC; l->min_y=0x7FFFFFFF;
  l->max_x=0x80000000; l->max_y=0x80000000;
  w=l->text_attribute<<8;
  if (!find_cur_entry) {
    l->x=0; l->y=0;
  }
  l->flags=l->flags & ~(LTFF_WORD_WRAP|LTFF_UNDERLINED|LTFF_INVERTED|LTFF_BLINK);
  l->shifted_x=0;
  l->shifted_y=0;
  if (recalc) {
    if (l->cur_data_col<=l->cur_entry->min_col)
      l->cur_data_col=l->cur_entry->min_col;
    if (!l->recalc_start)
      cl=l; //skip update
    else {
      cl=l->recalc_start;
      if (cl!=l) {
	i=l->ww_lines_back;
	while (i-- &&
	  cl->flags2 & LTFLF2_WORD_WRAP &&
	  cl->last!=l)
	    cl=cl->last;
	if (cl->flags2 & LTFLF2_WORD_WRAP)
	  l->flags|=LTFF_WORD_WRAP;
	else
	  l->flags&=~LTFF_WORD_WRAP;
	if (cl->flags2 & LTFLF2_UNDERLINED) {
	  l->flags|=LTFF_UNDERLINED;
	  w|=LTFLT_UNDERLINED;
	} else
	  l->flags&=~LTFF_UNDERLINED;
	if (cl->flags2 & LTFLF2_INVERTED) {
	  l->flags|=LTFF_INVERTED;
	  w|=LTFLT_INVERTED;
	} else
	  l->flags&=~LTFF_INVERTED;
	if (cl->flags2 & LTFLF2_BLINK) {
	  l->flags|=LTFF_BLINK;
	  w|=LTFLT_BLINK;
	} else
	  l->flags&=~LTFF_BLINK;
	w|=(cl->type & 0x0C00FF00);
	x=cl->x; y=cl->y;
	l->indent=cl->indent;
	l->page_line_num=cl->page_line_num;
	l->left_margin=cl->left_margin;
	l->right_margin=cl->right_margin;
      } else
	cl=l->dummy.next;
    }
  } else
    cl=l->dummy.next;
  x0=l->line_start_col;
  y0=l->cur_top_line_num;
  if (l->dummy.next==l) {
    best_cl=l;
    best_col=0;
    l->cur_entry=l;
    l->cur_data_col=0;
  }
  skipped_update=(cl==l && l->dummy.next!=l);

  extra_processing=recalc||find_cur_entry||resize;
  while (cl!=l) {
    del_cl=FALSE;
    if (cl->flags2 & LTFLF2_SKIP) {
      cl=cl->last;  //for consistency handle skips the same
      goto skip;
    }
    if (cl->flags & LTFLF_DISPLAY_CB) {
      if (recalc || (cl->flags2 & LTFLF2_REFRESH_DATA)) {
	Free(cl->display,mem_tss);
	cl->display=cl->display_cb(l,l->user_data,cl,mem_tss);
	cl->max_col=StrLen(cl->display);
	if (l->cur_entry==cl) {
	  if (l->cur_data_col>=cl->max_col && cl->max_col)
	    l->cur_data_col=cl->max_col-1;
	}
      }
    }
    if (extra_processing) {
      cont=TRUE;
      while (cont) {
	cont2=TRUE;
	while (cont2) {
	  cont2=FALSE;
	  cl2=cl->next;
	  if (cl2->btype==LTFT_SOFT_CR) {
	    if (l->cur_entry==cl2) {
	      l->cur_entry=cl2->next;
	      l->cur_data_col=l->cur_entry->min_col;
	    }
	    if (best_cl==cl2) {
	      best_cl=cl2->next;
	      best_col=0;
	    }
	    RemQue(cl2);
	    LtfDelEntry2(cl2,mem_tss);
	    cont2=TRUE;
	  }
	}
	cont=FALSE;
	cl2=cl->next;
	if (cl->btype==LTFT_TEXT &&
	    cl->flags==cl2->flags &&
	    cl->flags2==cl2->flags2 &&
	    cl->type==cl2->type) {
	  i=StrLen(cl->display);
	  j=StrLen(cl2->display);
	  ptr=MAlloc(i+j+1,mem_tss);
	  MemCpy(ptr,cl->display,i);
	  MemCpy(ptr+i,cl2->display,j+1);
	  Free(cl->display,mem_tss);
	  cl->display=ptr;
	  if (l->cur_entry==cl2) {
	    l->cur_entry=cl;
	    l->cur_data_col=l->cur_data_col+i;
	  }
	  if (best_cl==cl2) {
	    best_cl=cl;
	    best_col=0;
	  }
	  RemQue(cl2);
	  LtfDelEntry2(cl2,mem_tss);
	  cont=TRUE;
	}
      }
    }
    if (cl->flags & LTFLF_SCROLLING_X)
      k=cl->scroll_len;
    else if (Bt(ltf_display_types,cl->btype))
      k=StrLen(cl->display);
    else
      k=0;
    if (cl->flags2 & LTFLF2_MARGIN_REL_X) {
      if (cl->flags & LTFLF_LEFT_X)
	x=left_margin-tss->window_left;
      else if (cl->flags & LTFLF_RIGHT_X)
	x=right_margin-4*(k-1)-tss->window_left;
      else if (cl->flags & LTFLF_CENTER_X)
	x=((right_margin+left_margin)/2-k*2-tss->window_left) & 0xFFFFFFFC;
    } else {
      if (cl->flags & LTFLF_LEFT_X)
	x=x0;
      else if (cl->flags & LTFLF_RIGHT_X)
	x=tss->window_right-tss->window_left+x0-4*(k-1);
      else if (cl->flags & LTFLF_CENTER_X)
	x=((tss->window_right-tss->window_left+x0)/2-k*2) & 0xFFFFFFFC;
    }
    if (cl->flags2 & LTFLF2_PAGE_REL_Y) {
      if (cl->flags & LTFLF_TOP_Y)
	y-=cl->page_line_num;
      else if (cl->flags & LTFLF_BOTTOM_Y)
	y+=l->page_length-cl->page_line_num;
      else if (cl->flags & LTFLF_CENTER_Y)
	y+=l->page_length/2-cl->page_line_num;
    } else {
      if (cl->flags & LTFLF_TOP_Y)
	y=y0;
      else if (cl->flags & LTFLF_BOTTOM_Y)
	y=tss->window_bottom-tss->window_top+y0;
      else if (cl->flags & LTFLF_CENTER_Y)
	y=(tss->window_bottom-tss->window_top)/2+y0;
    }

    if (extra_processing) {
      if (l->flags & LTFF_WORD_WRAP) {
	i=(right_margin+4-(x+tss->window_left))/4;  //Space left ON line
	if (cl->btype==LTFT_TEXT) {
	  if (l->cur_entry==cl->next && l->cur_data_col==0
	      && k==i)
	      i--;
	  if (l->cur_entry==cl) {
	    if (l->cur_data_col==i ||
	       (l->cur_data_col==i+1 && cl->display[i]==32))
	    i--;
	  }
	  if (k>i) {
	    for (j=i;j>8;j--)
	      if (cl->display[j]==32) {
		i=j+1;
		j=0;
	      }
	    if (k>i && i>0) {
	      cl2=MAllocIdentical(cl,mem_tss);
	      cl2->display=NewString(cl->display+i,mem_tss);
	      InsQue(cl2,cl);
	      if (l->cur_entry==cl && l->cur_data_col>=i) {
		l->cur_entry=cl2;
		l->cur_data_col=l->cur_data_col-i;
	      }
	      cl->display[i]=0;
	      ptr=NewString(cl->display,mem_tss);
	      Free(cl->display,mem_tss);
	      cl->display=ptr;
	      cl2=MAllocZ(sizeof(LtfEntryBase),mem_tss);
	      cl2->type=LTFT_SOFT_CR | (cl->type & 0xFFFFFF00);
	      cl2->flags=cl->flags;
	      cl2->flags2=cl->flags2;
	      cl2->x=x;
	      cl2->y=y;
	      cl2->indent=l->indent;
	      cl2->page_line_num=l->page_line_num;
	      cl2->left_margin=l->left_margin;
	      cl2->right_margin=l->right_margin;
	      InsQue(cl2,cl);
	      goto skip_soft_cr;
	    }
	  }
	}
	if (k>=i && cl->btype!=LTFT_SOFT_CR && cl->btype!=LTFT_CR
		 && cl->btype!=LTFT_CURSOR_MOVEMENT) {
	  if ((cl->last->btype)!=LTFT_SOFT_CR &&
	      (cl->last->btype)!=LTFT_CR &&
	      (cl->last->btype)!=LTFT_CURSOR_MOVEMENT) {
	    cl2=MAllocZ(sizeof(LtfEntryBase),mem_tss);
	    cl2->type=LTFT_SOFT_CR | (cl->type & 0xFFFFFF00);
	    cl2->flags2=LTFLF2_WORD_WRAP |
	      (cl->flags2 & (LTFLF2_INVERTED|LTFLF2_UNDERLINED|
	       LTFLF2_BLINK|LTFLF2_SKIP));
	    cl2->x=x;
	    cl2->y=y;
	    cl2->indent=l->indent;
	    cl2->page_line_num=l->page_line_num;
	    cl2->left_margin=l->left_margin;
	    cl2->right_margin=l->right_margin;
	    InsQue(cl2,cl->last);
	    if (l->left_margin==LTF_DEFAULT)
	      x=l->indent;
	    else
	      x=l->left_margin+l->indent;
	    y++;
	  }
	}
skip_soft_cr:
      }
    }
    cl->x=x;
    cl->y=y;
    cl->indent=l->indent;
    cl->page_line_num=l->page_line_num;
    cl->left_margin=l->left_margin;
    cl->right_margin=l->right_margin;
    cl->type=(w & 0xFF00) | (cl->type & 0xFFFF00FF);
    if (l->flags & LTFF_WORD_WRAP)
      cl->flags2|=LTFLF2_WORD_WRAP;
    else
      cl->flags2&=~LTFLF2_WORD_WRAP;

    if (l->flags & LTFF_UNDERLINED) {
      cl->flags2|=LTFLF2_UNDERLINED;
      w|=LTFLT_UNDERLINED;
    } else {
      cl->flags2&=~LTFLF2_UNDERLINED;
      w&=~LTFLT_UNDERLINED;
    }

    if (l->flags & LTFF_INVERTED) {
      cl->flags2|=LTFLF2_INVERTED;
      w|=LTFLT_INVERTED;
    } else {
      cl->flags2&=~LTFLF2_INVERTED;
      w&=~LTFLT_INVERTED;
    }
    if (l->flags & LTFF_BLINK) {
      cl->flags2|=LTFLF2_BLINK;
      w|=LTFLT_BLINK;
    } else {
      cl->flags2&=~LTFLF2_BLINK;
      w&=~LTFLT_BLINK;
    }

    if (x<l->min_x) l->min_x=x;
    if (y<l->min_y) l->min_y=y;

    D=LtfDist(x,y,l->x,l->y);
    col=0;
    col2=0;
    w=(w &0xFC00FF00)|
      ((l->shifted_x & 0x1F)<<16)|
      ((l->shifted_y & 0x1F)<<21);
    switch (cl->btype) {
      case LTFT_LINK:
	w1=(w & 0xFFFF0000) | (l->link_attribute<<8);
	break;
      case LTFT_MACRO:
      case LTFT_MENU_VALUE:
	w1=(w & 0xFFFF0000) | (l->macro_attribute<<8);
	break;
      case LTFT_ANCHOR:
	w1=(w & 0xFFFF0000) | (l->anchor_attribute<<8);
	break;
      case LTFT_TREE:
	w1=(w & 0xFFFF0000) | (l->tree_attribute<<8);
	break;
      case LTFT_HIDE_START:
      case LTFT_HIDE_END:
	w1=(w & 0xFFFF0000) | (l->hidden_attribute<<8);
	break;
      default:
	w1=w;
    }
    w1=(w1 & 0xFFFFFF00) | (cl->type & 0xF3FF0000);
    if (cl==l->cur_entry && cl->btype!=LTFT_TEXT)
	w1^=0xFF00;

    if (cl->flags2 & LTFLF2_REFRESH_DATA) {
      if (cl->btype==LTFT_DATA || cl->btype==LTFT_CHECK_BOX) {
	LtfFormatData(cl);
	if (cl->btype==LTFT_DATA)
	  cl->max_col=StrLen(cl->display);
      }
    }

    ptr=cl->display;
    if (cl->flags2 & LTFLF2_TREE) {
      if (StrLen(ptr)>=2) {
	if (cl->flags2 & LTFLF2_COLLAPSED)
	  *ptr++='+';
	else
	  *ptr++='-';
	*ptr++=']';
      }
    }
    if (cl->btype==LTFT_CHECK_BOX) {
      if (StrLen(ptr)>=3) {
	*ptr++='[';
	if (cl->flags2 & LTFLF2_CHECKED)
	  *ptr++='X';
	else
	  *ptr++=' ';
	*ptr++=']';
      }
    } else if (cl->btype==LTFT_HIDE_START) {
      if (StrLen(ptr)>=2) {
	*ptr++='<';
	if (cl->flags2 & LTFLF2_COLLAPSED)
	  *ptr++='+';
	else
	  *ptr++='-';
      }
    } else if (cl->btype==LTFT_HIDE_END) {
      if (StrLen(ptr)>=1)
	*ptr++='>';
    }

    if (Bt(ltf_display_types,cl->btype)) {
      if (cl->flags & LTFLF_SCROLLING_X) {
	j=StrLen(cl->display);
	if (j && cl->scroll_len) {
	  i=jiffies*FONT_WIDTH*tss->scroll_speed/SYS_TIMER_FREQ;
	  i=i % (j*FONT_WIDTH);
	  w1=(w1 & 0xFFE0FF00)|
	    ((FONT_WIDTH-1-(i%FONT_WIDTH))<<16);
	  i/=FONT_WIDTH;
	  ptr=cl->display;
	  for (k=0;k<cl->scroll_len;k++) {
	    ch=ptr[(i+k)%j];
	    if (!Bt(displayable_chars_bitmap,ch)) ch='.';
	    if (to_screen) {
	      if (cl->flags2 & LTFLF2_BORDER_PLOT)
		PlotBorderChar(w1+ch,x-x0,y-y0);
	      else
		PlotWindowChar(w1+ch,x-x0,y-y0);
	    }
	    x+=4;
	  }
	}
	D=LtfDist(cl->x,cl->y,l->x,l->y);
	col=cl->min_col;
	col2=cl->scroll_len;  //TODO This is flawed
      } else {
	ptr=cl->display;
	if (cl->flags2 & LTFLF2_PASSWORD) {
	  while (ch=*ptr++) {
	    if (ch!=CH_TAB) {
	      if (ptr-1-cl->display>=cl->min_col) {
		if (!(cl->flags2 & LTFLF2_HAS_TERMINATOR) ||
		  ptr-cl->display!=StrLen(cl->display))
		  ch='*';
	      }
	      if (to_screen) {
		if (cl->flags2 & LTFLF2_BORDER_PLOT)
		  PlotBorderChar(w1+ch,x-x0,y-y0);
		else
		  PlotWindowChar(w1+ch,x-x0,y-y0);
	      }
	      d2=LtfDist(x,y,l->x,l->y);
	      if (d2<D) {
		D=d2;
		col=col2;
	      }
	      col2++;
	      x+=4;
	    } else {
	      i=(x+32) & 0xFFFFFFE0;
	      while (x<i) {
		if (to_screen) {
		  if (cl->flags2 & LTFLF2_BORDER_PLOT)
		    PlotBorderChar(w1+0x20,x-x0,y-y0);
		  else
		    PlotWindowChar(w1+0x20,x-x0,y-y0);
		}
		d2=LtfDist(x,y,l->x,l->y);
		if (d2<D)
		  D=d2;
		x+=4;
	      }
	    }
	  }
	} else {
	  if (cl->flags2 & LTFLF2_BORDER_PLOT) {
	    while (ch=*ptr++) {
	      if (ch!=CH_TAB) {
		if (to_screen)
		  PlotBorderChar(w1+ch,x-x0,y-y0);
		d2=LtfDist(x,y,l->x,l->y);
		if (d2<D) {
		  D=d2;
		  col=col2;
		}
		col2++;
		x+=4;
	      } else {
		i=(x+32) & 0xFFFFFFE0;
		while (x<i) {
		  if (to_screen)
		    PlotBorderChar(w1+0x20,x-x0,y-y0);
		  d2=LtfDist(x,y,l->x,l->y);
		  if (d2<D)
		    D=d2;
		  x+=4;
		}
	      }
	    }
	  } else {
	    if (to_screen) {
	      while (ch=*ptr++) {
		if (ch!=CH_TAB) {
		  PlotWindowChar(w1+ch,x-x0,y-y0);
		  d2=LtfDist(x,y,l->x,l->y);
		  if (d2<D) {
		    D=d2;
		    col=col2;
		  }
		  col2++;
		  x+=4;
		} else {
		  i=(x+32) & 0xFFFFFFE0;
		  while (x<i) {
		    PlotWindowChar(w1+0x20,x-x0,y-y0);
		    d2=LtfDist(x,y,l->x,l->y);
		    if (d2<D)
		      D=d2;
		    x+=4;
		  }
		}
	      }
	    } else {
	      while (ch=*ptr++) {
		if (ch!=CH_TAB) {
		  d2=LtfDist(x,y,l->x,l->y);
		  if (d2<D) {
		    D=d2;
		    col=col2;
		  }
		  col2++;
		  x+=4;
		} else {
		  i=(x+32) & 0xFFFFFFE0;
		  while (x<i) {
		    d2=LtfDist(x,y,l->x,l->y);
		    if (d2<D)
		      D=d2;
		    x+=4;
		  }
		}
	      }
	    }
	  }
	}
      }
    }
      switch (cl->btype) {
	case LTFT_HEX_EDIT:
	  if (cl->flags2 & LTFLF2_DATA_IS_PTR)
	    bptr=cl->data;
	  else
 	    bptr=&cl->data;
	  k=cl->display; //columns
	  for (i=0;i<cl->len;i=i+k) {
	    if (cl->flags2 & LTFLF2_ZERO_BASED)
	      SPrintF(buf,"%08X ",i);
	    else
	      SPrintF(buf,"%08X ",bptr);
	    ptr=buf;
	    while (ch=*ptr++) {
	      if (to_screen) {
		if (cl->flags2 & LTFLF2_BORDER_PLOT)
		  PlotBorderChar(w1+ch,x-x0,y-y0);
		else
		  PlotWindowChar(w1+ch,x-x0,y-y0);
	      }
	      d2=LtfDist(x,y,l->x,l->y);
	      if (d2<D) {
		D=d2;
		col=i*3;
	      }
	      x+=4;
	    }
	    if (i+k>cl->len) k=cl->len-i;
	    for (j=0;j<k;j++) {
	      SPrintF(buf,"%02X",*bptr++);
	      ptr=buf;
	      while (ch=*ptr++) {
		if (to_screen) {
		  if (cl->flags2 & LTFLF2_BORDER_PLOT)
		    PlotBorderChar(w1+ch,x-x0,y-y0);
		  else
		    PlotWindowChar(w1+ch,x-x0,y-y0);
		}
		d2=LtfDist(x,y,l->x,l->y);
		if (d2<D) {
		  D=d2;
		  col=col2;
		}
		col2++;
		x+=4;
	      }
	      x+=4;
	    }
	    bptr-=j;
	    x+=(cl->display-k)*12;
	    for (j=0;j<k;j++) {
	      ch=*bptr++;
	      if (!Bt(displayable_chars_bitmap,ch)) ch='.';
	      if (to_screen) {
		if (cl->flags2 & LTFLF2_BORDER_PLOT)
		  PlotBorderChar(w1+ch,x-x0,y-y0);
		else
		  PlotWindowChar(w1+ch,x-x0,y-y0);
	      }
	      d2=LtfDist(x,y,l->x,l->y);
	      if (d2<D) {
		D=d2;
		col=col2;
	      }
	      col2++;
	      x+=4;
	    }
	    y++;
	    x-=cl->display*12+4*k+36;
	  }
	  break;
	case LTFT_TAB:
	  i=(x+32) & 0xFFFFFFE0;
	  if (cl->flags2 & LTFLF2_BORDER_PLOT) {
	    while (x<i) {
	      if (to_screen)
		PlotBorderChar(w1+0x20,x-x0,y-y0);
	      d2=LtfDist(x,y,l->x,l->y);
	      if (d2<D)
		D=d2;
	      x+=4;
	    }
	  } else {
	    while (x<i) {
	      if (to_screen)
		PlotWindowChar(w1+0x20,x-x0,y-y0);
	      d2=LtfDist(x,y,l->x,l->y);
	      if (d2<D)
		D=d2;
	      x+=4;
	    }
	  }
	  break;
	case LTFT_CR:
	case LTFT_SOFT_CR:
	  if (l->left_margin==LTF_DEFAULT)
	    x=l->indent;
	  else
	    x=l->indent+l->left_margin;
	  y++;
	  l->page_line_num++;
	  if (l->footer==LTF_DEFAULT) {
	    if (l->page_line_num>=l->page_length) {
	      if (l->header==LTF_DEFAULT)
		l->page_line_num=0;
	      else {
		l->page_line_num=l->header;
		y+=l->header;
	      }
	    }
	  } else {
	    if (l->page_line_num>=l->page_length-l->footer) {
	      y+=l->footer;
	      if (l->header==LTF_DEFAULT)
		l->page_line_num=0;
	      else {
		l->page_line_num=l->header;
		y+=l->header;
	      }
	    }
	  }
	  break;
	case LTFT_CURSOR_MOVEMENT:
	  x+=4*cl->cursor_x_offset;
	  y+=cl->cursor_y_offset;
	  if (cl->flags2 & LTFLF2_PAGE_REL_Y) {
	    if (cl->flags & LTFLF_TOP_Y)
	      l->page_line_num=0;
	    else if (cl->flags & LTFLF_BOTTOM_Y)
	      l->page_line_num=l->page_length;
	    else if (cl->flags & LTFLF_CENTER_Y)
	      l->page_line_num=l->page_length/2;
	  }  //TODO: else
	  l->page_line_num=(l->page_line_num+
	    cl->cursor_y_offset)%l->page_length;
	  break;
	case LTFT_PAGE_BREAK:
	  x=0;
	  y+=l->page_length-cl->page_line_num;
	  l->page_line_num=0;
	  if (l->header!=LTF_DEFAULT) {
	    y+=l->header;
	    l->page_line_num=l->header;
	  }
	  break;
	case LTFT_INDENT:
	  if (cl->flags & LTFLF_LEFT_X)
	    l->indent=cl->attr*4;
	  else
	    l->indent=l->indent+cl->attr*4;
	  x=l->indent;
	  cl->indent=l->indent;
	  cl->x=0;
	  if (l->left_margin!=LTF_DEFAULT) {
	    x+=l->left_margin;
	    cl->x+=l->left_margin;
	  }
	  break;
	case LTFT_PAGE_LENGTH:
	  l->page_length=cl->attr;
	  break;
	case LTFT_LEFT_MARGIN:
	  l->left_margin=cl->attr*4;
	  cl->left_margin=l->left_margin;
	  left_margin=tss->window_left+l->left_margin;
	  break;
	case LTFT_RIGHT_MARGIN:
	  l->right_margin=cl->attr*4;
	  cl->right_margin=l->right_margin;
	  right_margin=tss->window_left+l->right_margin;
	  break;
	case LTFT_HEADER:
	  l->header=cl->attr;
	  break;
	case LTFT_FOOTER:
	  l->footer=cl->attr;
	  break;
	case LTFT_FOREGROUND_COLOR:
	  w2=w & 0xF00;
	  if (cl->attr==LTF_DEFAULT)
	    w=(w & 0xF000) | ((l->text_attribute<<8) & 0xF00);
	  else
	    w=(w & 0xF000) | (cl->attr <<8);
	  break;
	case LTFT_BACKGROUND_COLOR:
	  w2=w & 0xF000;
	  if (cl->attr==LTF_DEFAULT)
	    w=(w & 0xF00) | ((l->text_attribute<<8) & 0xF000);
	  else
	    w=(w & 0xF00) | (cl->attr <<12);
	  break;
	case LTFT_DEFAULT_FOREGROUND_COLOR:
	  if (cl->attr==LTF_DEFAULT)
	    w=(w & 0xF000) | ((l->text_attribute<<8) & 0xF00);
	  else
	    w=(w & 0xF000) | (cl->attr <<8);
	  l->text_attribute=(l->text_attribute & 0xF0) | cl->attr;
	  break;
	case LTFT_DEFAULT_BACKGROUND_COLOR:
	  if (cl->attr==LTF_DEFAULT)
	    w=(w & 0xF00) | ((l->text_attribute<<8) & 0xF000);
	  else
	    w=(w & 0xF00) | (cl->attr <<12);
	  l->text_attribute=(l->text_attribute & 0xF) | (cl->attr<<4);
	  break;
	case LTFT_LINK_FOREGROUND:
	  l->link_attribute=(l->link_attribute & 0xF0) | cl->attr;
	  break;
	case LTFT_LINK_BACKGROUND:
	  l->link_attribute=(l->link_attribute & 0xF) | (cl->attr<<4);
	  break;
	case LTFT_MACRO_FOREGROUND:
	  l->macro_attribute=(l->macro_attribute & 0xF0) | cl->attr;
	  break;
	case LTFT_MACRO_BACKGROUND:
	  l->macro_attribute=(l->macro_attribute & 0xF) | (cl->attr<<4);
	  break;
	case LTFT_ANCHOR_FOREGROUND:
	  l->anchor_attribute=(l->anchor_attribute & 0xF0) | cl->attr;
	  break;
	case LTFT_ANCHOR_BACKGROUND:
	  l->anchor_attribute=(l->anchor_attribute & 0xF) | (cl->attr<<4);
	  break;
	case LTFT_HIDDEN_FOREGROUND:
	  l->hidden_attribute=(l->hidden_attribute & 0xF0) | cl->attr;
	  break;
	case LTFT_HIDDEN_BACKGROUND:
	  l->hidden_attribute=(l->hidden_attribute & 0xF) | (cl->attr<<4);
	  break;
	case LTFT_TREE_FOREGROUND:
	  l->tree_attribute=(l->tree_attribute & 0xF0) | cl->attr;
	  break;
	case LTFT_TREE_BACKGROUND:
	  l->tree_attribute=(l->tree_attribute & 0xF) | (cl->attr<<4);
	  break;
	case LTFT_WORD_WRAP:
	  if (cl->attr)
	    l->flags|=LTFF_WORD_WRAP;
	  else
	    l->flags&=~LTFF_WORD_WRAP;
	  break;
	case LTFT_UNDERLINED:
	  if (cl->attr)
	    l->flags|=LTFF_UNDERLINED;
	  else
	    l->flags&=~LTFF_UNDERLINED;
	  break;
	case LTFT_INVERTED:
	  if (cl->attr)
	    l->flags|=LTFF_INVERTED;
	  else
	    l->flags&=~LTFF_INVERTED;
	  break;
	case LTFT_BLINK:
	  if (cl->attr)
	    l->flags|=LTFF_BLINK;
	  else
	    l->flags&=~LTFF_BLINK;
	  break;
	case LTFT_SHIFTED_X:
	  l->shifted_x=cl->attr;
	  break;
	case LTFT_SHIFTED_Y:
	  l->shifted_y=cl->attr;
	  break;
	case LTFT_CURSOR:
	  if (!(l->flags & LTFF_NO_CURSOR)) {
	    l->cur_entry=cl->next;
	    l->cur_data_col=l->cur_entry->min_col;
	  }
	  found_cu_cmd=TRUE;
	  del_cl=TRUE;
	  break;
	case LTFT_PICTURE:
	  if (!cl->bin_data)
	    cl->bin_data=LtfFindBin(l,cl->bin_num);
	  if (cl->bin_data) {
	    if (to_screen) {
	      GrReset(base);
	      base->flags|=BMF_RECORD_EXTENTS;
	      i=((w1>>12)&0xF)^0xF;
	      if (w1 & LTFLT_SELECTED)
		i^=0xF;
	      if (w1 & LTFLT_INVERTED)
		i^=0xF;
	      base->color^=i;
	      PlotGrElems(base,(x-x0)/4*FONT_WIDTH,
		(y-y0)*FONT_HEIGHT,0,
		cl->bin_data->data,i);
	      cl->eminx=base->eminx;
	      cl->emaxx=base->emaxx;
	      cl->eminy=base->eminy;
	      cl->emaxy=base->emaxy;
	    }
	    i=(l->x-x0)/4*FONT_WIDTH;
	    j=(l->y-y0)*FONT_HEIGHT;
	    if (i>=cl->eminx && i<=cl->emaxx &&
		j>=cl->eminy && j<=cl->emaxy) {
	      D=0;
	      col=cl->min_col;
	    }
	  }
	  break;
      }

    if (cl->flags2 & LTFLF2_HAS_BORDER) {
      if (cl->flags2 & LTFLF2_SOLID_BORDER)
	DrawBorder(1,cl->x-x0,x-x0-4,cl->y-y0,y-y0,w1>>8,TRUE);
      else
	DrawBorder(0,cl->x-x0,x-x0-4,cl->y-y0,y-y0,w1>>8,TRUE);
    }
    cl->max_col=(cl->flags2 & LTFLF2_TREE) ? 1:col2;
    switch (cl->btype) {
      case LTFT_CHECK_BOX:
      case LTFT_HIDE_START:
	cl->max_col=2;
	break;
      case LTFT_TREE:
      case LTFT_BUTTON:
      case LTFT_HIDE_END:
	cl->max_col=1;
	break;
    }

    if (x>l->max_x) l->max_x=x;
    if (y>l->max_y) l->max_y=y;
    if (D<best_d) {
      best_d=D;
      best_cl=cl;
      best_col=col;
    }
    if (cl->flags2 & LTFLF2_TREE) {
      if (cl->flags2 & LTFLF2_ALIAS)
	alias=cl;
      else
	alias=NULL;
      tree_collapsed=(cl->flags2 & LTFLF2_COLLAPSED);
      cl2=cl->next;
      while (cl2!=l && cl2->btype!=LTFT_INDENT && !(cl2->flags2 & LTFLF2_TREE))
	cl2=cl2->next;
      if (cl2->btype==LTFT_INDENT) {
	i=l->indent;
	j=i;
	do {
	  if (tree_collapsed)
	    cl2->flags2=cl2->flags2 | LTFLF2_SKIP;
	  else
	    cl2->flags2=cl2->flags2 & ~LTFLF2_SKIP;
	  if (alias && cl2==l->cur_entry && Bt(ltf_display_types,cl2->btype)) {
	    Free(alias->display,mem_tss);
	    alias->display=MAlloc(StrLen(cl2->display)+4,mem_tss);
	    alias->display[0]='+';
	    alias->display[1]=']';
	    alias->display[2]=32;
	    StrCpy(alias->display+3,cl2->display);
	    alias->max_col=cl2->max_col+3;
	  }
	  if (cl2->btype==LTFT_INDENT) {
	    if (cl2->flags & LTFLF_LEFT_X)
	      j=cl2->attr;
	    else
	      j+=cl2->attr;
	  }
	  cl2=cl2->next;
	} while (cl2!=l && j>i);
      }
    }
    if (cl->btype == LTFT_HIDE_START) {
      if (cl->flags2 & LTFLF2_ALIAS)
	alias=cl;
      else
	alias=NULL;
      cl2=cl->next;
      Btr(hide_collapsed,0);
      j=1;
      AssignBit(hide_collapsed,j,cl->flags2 & LTFLF2_COLLAPSED);
      while (cl2!=l && j>0) {
	if (Bt(hide_collapsed,j))
	  cl2->flags2|=LTFLF2_SKIP;
	else
	  cl2->flags2&=~LTFLF2_SKIP;
	if (cl2->btype==LTFT_HIDE_START) {
	  j++;
	  AssignBit(hide_collapsed,j,cl2->flags2 & LTFLF2_COLLAPSED);
	  if (Bt(hide_collapsed,j-1))
	    Bts(hide_collapsed,j);
	} else if (cl2->btype==LTFT_HIDE_END) {
	  j--;
	  if (Bt(hide_collapsed,j))
	    cl2->flags2|=LTFLF2_SKIP;
	  else
	    cl2->flags2&=~LTFLF2_SKIP;
	}
	cl2=cl2->next;
      }
    }

skip:
    cl2=cl->next;
    while (cl2!=l && (cl2->flags2 & LTFLF2_SKIP)) {
/*
      if (cl2==l->cur_entry) {
	l->cur_entry=cl2->next;
	l->cur_data_col=l->cur_entry->min_col;
      }
*/
      cl2->x=x;
      cl2->y=y;
      cl2->indent=l->indent;
      cl2->page_line_num=l->page_line_num;
      cl2->left_margin=l->left_margin;
      cl2->right_margin=l->right_margin;
      cl2->type=(w & 0xFF00) | (cl2->type & 0xFFFF00FF);
      if (l->flags & LTFF_WORD_WRAP)
	cl2->flags2|=LTFLF2_WORD_WRAP;
      else
	cl2->flags2&=~LTFLF2_WORD_WRAP;

      if (l->flags & LTFF_UNDERLINED) {
	cl2->flags2|=LTFLF2_UNDERLINED;
	w|=LTFLT_UNDERLINED;
      } else {
	cl2->flags2&=~LTFLF2_UNDERLINED;
	w&=~LTFLT_UNDERLINED;
      }

      if (l->flags & LTFF_INVERTED) {
	cl2->flags2|=LTFLF2_INVERTED;
	w|=LTFLT_INVERTED;
      } else {
	cl2->flags2&=~LTFLF2_INVERTED;
	w&=~LTFLT_INVERTED;
      }
      if (l->flags & LTFF_BLINK) {
	cl2->flags2|=LTFLF2_BLINK;
	w|=LTFLT_BLINK;
      } else {
	cl2->flags2&=~LTFLF2_BLINK;
	w&=~LTFLT_BLINK;
      }
      cl2=cl2->next;
    }

    if (!(cl->flags2 & LTFLF2_HOLD) &&
     (del_cl || (cl->btype==LTFT_TEXT && !cl->max_col))) {
      if (cl==l->cur_entry) {
	l->cur_entry=cl2;
	l->cur_data_col=cl2->min_col;
      }
      if (best_cl==cl) {
	best_cl=cl2;
	best_col=0;
      }
      RemQue(cl);
      LtfDelEntry2(cl,mem_tss);
    }
    cl=cl2;
  }

  //Update header
  if (!skipped_update) {
    cl->x=x;
    cl->y=y;
    cl->indent=l->indent;
    cl->page_line_num=l->page_line_num;
    cl->left_margin=l->left_margin;
    cl->right_margin=l->right_margin;
    cl->type=(w & 0xFF00) | (cl->type & 0xFFFF00FF);
    D=LtfDist(x,y,l->x,l->y);
    if (D<best_d) {
      best_d=D;
      best_cl=cl;
      best_col=0;
    }
  }
  if (to_screen && (l->flags & LTFF_MIN_SIZE)) {
    if (tss->window_right!=tss->window_left+l->max_x+4) {
      tss->window_right=tss->window_left+l->max_x-l->min_x+4;
      Bts(&sys_flags,SYSf_CLEAR_SCREEN_TEXT);
    }
    if (tss->window_bottom!=tss->window_top+l->max_y+1) {
      tss->window_bottom=tss->window_top+l->max_y-l->min_y+1;
      Bts(&sys_flags,SYSf_CLEAR_SCREEN_TEXT);
    }
  }
  if (find_cur_entry && !found_cu_cmd) {
    l->cur_entry=best_cl;
    l->cur_data_col=best_col;
  }
  if ((l->cur_entry->btype)!=LTFT_HEX_EDIT) {
    l->y=l->cur_entry->y;
    l->x=l->cur_entry->x+l->cur_data_col*4;
  } else {
    l->y=l->cur_entry->y+l->cur_data_col/3/l->cur_entry->display;
    x=l->cur_data_col%(l->cur_entry->display*3);
    i=x/l->cur_entry->display;
    l->x=l->cur_entry->x+36;
    if (i<2)
      l->x+=x/2*12+(x&1)*4;
    else
      l->x+=l->cur_entry->display*12+(x-2*l->cur_entry->display)*4;
  }
  l->line=l->y+1;
  l->col=l->x/4+1;
  if (has_cursor) {
    if (l->cur_top_line_num+tss->window_bottom-tss->window_top>l->max_y)
      l->cur_top_line_num=l->max_y-(tss->window_bottom-tss->window_top);
    if (l->cur_top_line_num<l->min_y)
      l->cur_top_line_num=l->min_y;

    if (l->y-l->cur_top_line_num>tss->window_bottom-tss->window_top)
      l->cur_top_line_num=l->y-(tss->window_bottom-tss->window_top);
    if (l->y-l->cur_top_line_num<0)
      l->cur_top_line_num=l->y;

    if (l->line_start_col+tss->window_right-tss->window_left>l->max_x)
      l->line_start_col=l->max_x-(tss->window_right-tss->window_left);
    if (l->line_start_col<l->min_x)
      l->line_start_col=l->min_x;

    if (l->x-l->line_start_col>tss->window_right-tss->window_left)
      l->line_start_col=l->x-(tss->window_right-tss->window_left);
    if (l->x-l->line_start_col<0)
      l->line_start_col=l->x;
  }
  if (recalc)
    l->recalc_start=NULL;
  if (to_screen && has_cursor) {
    tss->cursor_vert=l->y-l->cur_top_line_num+tss->window_top;
    tss->cursor_hor=l->x-l->line_start_col+tss->window_left;
    if (jiffies % (SYS_TIMER_FREQ/4) > (SYS_TIMER_FREQ/4)/2) {
      Btr(&Fs->crt_flags,CRTf_CURSOR_ON);
      CursorOn;
    }
    tss->scroll_x=(((l->line_start_col-l->min_x)*(tss->window_right-tss->window_left+4)/
      (l->max_x-l->min_x+1))&0xFFFFFFFC);
    tss->scroll_y=(l->cur_top_line_num-l->min_y)*(tss->window_bottom-tss->window_top+1)/
      (l->max_y-l->min_y+1);
    PlotBorderChar(140+(tss->border_attribute<<8),
      (tss->window_right-tss->window_left+4),tss->scroll_y);
    PlotBorderChar(140+(tss->border_attribute<<8),
      tss->scroll_x,(tss->window_bottom-tss->window_top+1));
  }
  GrDel(base);
}

public void LtfRecalc(Ltf *l)
{
  LtfUpdateWindowJoin(l,FALSE,FALSE,TRUE,FALSE);
}
ext[EXT_LTF_RECALC]=&LtfRecalc;

public void LtfCenter(Ltf *l)
{
  TssStruct *tss=l->tss;
  LtfRecalc(l);
  l->cur_top_line_num=l->y-(tss->window_bottom-tss->window_top)/2;
}

public void LtfBottom(Ltf *l)
{
  l->cur_entry=l;
  l->cur_data_col=0;
  l->recalc_start=l;
  LtfRecalc(l);
}

public Ltf *LtfNew()
{
  Ltf *l;
  l=MAllocZ(sizeof(Ltf));
  StrCpy(l->filename.name,sys_temp_filename);
  l->file_attr=0;
  l->find_replace=MAllocZ(sizeof(EditFindTextStruct));
  l->find_replace->scan_forward=1;
  l->find_replace->match_case=1;
  l->EditPlugIns=Fs->EditPlugIns;
  l->dollar_buf_size=84;
  l->dollar_buf=MAlloc(l->dollar_buf_size);
  l->max_entries=0x7FFFFFFF;
  l->ww_lines_back=16;
  l->tss=Fs;
  l->mem_tss=Fs;
  LtfReset(l,FALSE,FALSE);
  return l;
}


void ParseLtfFlags(LexStruct *l,DWORD *flags,DWORD *flags2,DWORD *type)
{
  int i;
  BOOL turn_on;
  while (l->token=='+' || l->token=='-') {
    turn_on=(l->token=='+');
    if (Lex(l)==TK_IDENT) {
      i=MatchSysTextEntry(l->ident,"ST_LTF_FLAGS",MLE_EXACT);
      if (i>=0)
	AssignBit(flags,i,turn_on);
      else {
	i=MatchSysTextEntry(l->ident,"ST_LTF_FLAGS2",MLE_EXACT);
	if (i<0)
	  *type=LTFT_ERROR;
	else {
	  AssignBit(flags2,i,turn_on);
	  if (i==LTFLf2_SELECTED)
	    AssignBit(type,30,turn_on);
	  else if (i==LTFLf2_UNDERLINED)
	    AssignBit(type,31,turn_on);
	  else if (i==LTFLf2_INVERTED)
	    AssignBit(type,29,turn_on);
	  else if (i==LTFLf2_BLINK)
	    AssignBit(type,28,turn_on);
	}
      }
      Lex(l);  //skip flag
    }
  }
}

void LtfDefaultFlags(DWORD *type,DWORD *f1,DWORD *f2)
{
  switch (*type & 255) {default_flags
    case LTFT_TREE:
      *f2=LTFLF2_COLLAPSED|LTFLF2_TREE;
      *type=*type | LTFLT_UNDERLINED;
      break;
    case LTFT_DATA:
      *f2=LTFLF2_DATA_IS_PTR | LTFLF2_HAS_TERMINATOR;
      *f1=LTFLF_AUX_STRING;
      break;
    case LTFT_CURSOR_MOVEMENT:
      *f1=LTFLF_LEFT_EXP | LTFLF_RIGHT_EXP;
      break;
    case LTFT_LINK:
      *f1=LTFLF_AUX_STRING;
      *type=*type | LTFLT_UNDERLINED;
      break;
    case LTFT_ANCHOR:
      *f1=LTFLF_AUX_STRING;
      break;
    case LTFT_BUTTON:
      *f1=LTFLF_ESC | LTFLF_LEFT_EXP;
      *f2=LTFLF2_HAS_BORDER;
      break;
    case LTFT_CHECK_BOX:
      *f2=LTFLF2_DATA_IS_PTR;
      break;
    case LTFT_MACRO:
      *f1=LTFLF_ESC | LTFLF_LEFT_MACRO;
      *type=*type | LTFLT_UNDERLINED;
      break;
    case LTFT_MENU_VALUE:
      *f1=LTFLF_ESC | LTFLF_LEFT_EXP;
      *type=*type | LTFLT_UNDERLINED;
      break;
    case LTFT_HEX_EDIT:
      *f2=LTFLF2_DATA_IS_PTR | LTFLF2_ZERO_BASED;
      break;
    case LTFT_PICTURE:
      *f1=LTFLF_HAS_BIN;
      break;
    case LTFT_INSERT_BINARY:
    case LTFT_INSERT_BINARY_TYPE:
    case LTFT_INSERT_BINARY_SIZE:
      *f1=LTFLF_HAS_BIN;
      break;
    case LTFT_HIDE_START:
      *f2=LTFLF2_COLLAPSED;
      *type=*type | LTFLT_UNDERLINED;
      break;
  }
}

char *LtfToPlainText(LtfEntry *ll)
{
  int i,j;
  DWORD type=ll->btype,f1=0,f2=0,flags;
  char *buf,*buf2;

  if (ll->btype==LTFT_ERROR)
    return NewString(ll->plain_text);

  LtfDefaultFlags(&type,&f1,&f2);

  buf=NewString(SysTextSub(ll->btype,"ST_LTF_CMDS"));
  for (i=0;i<32;i++)
    if (Bt(&f1,i)!=Bt(&ll->flags,i)) {
      if (Bt(&ll->flags,i))
	buf=Add2String(buf,"+");
      else
	buf=Add2String(buf,"-");
      buf=Add2String(buf,SysTextSub(i,"ST_LTF_FLAGS"));
    }

  flags=ll->flags2 & ~(LTFLF2_WORD_WRAP |LTFLF2_UNDERLINED |
	 LTFLF2_INVERTED | LTFLF2_BLINK | LTFLF2_SKIP);
  for (i=0;i<32;i++)
    if (Bt(&f2,i)!=Bt(&flags,i)) {
      if (Bt(&flags,i))
	buf=Add2String(buf,"+");
      else
	buf=Add2String(buf,"-");
      buf=Add2String(buf,SysTextSub(i,"ST_LTF_FLAGS2"));
    }

  for (i=28;i<32;i++)
    if (Bt(&type,i)!=Bt(&ll->type,i)) {
      if (Bt(&ll->type,i))
	buf=Add2String(buf,"+");
      else
	buf=Add2String(buf,"-");
      switch (i) {
	case 28: j=LTFLf2_BLINK; break;
	case 29: j=LTFLf2_INVERTED; break;
	case 30: j=LTFLf2_SELECTED; break;
	case 31: j=LTFLf2_UNDERLINED; break;
      }
      buf=Add2String(buf,SysTextSub(j,"ST_LTF_FLAGS2"));
    }
  buf=Add2String(buf,",");
  switch (ll->btype) {
    case LTFT_TEXT:
    case LTFT_LINK:
    case LTFT_ANCHOR:
    case LTFT_MENU_VALUE:
    case LTFT_BUTTON:
    case LTFT_CHECK_BOX:
    case LTFT_TREE:
    case LTFT_PICTURE:
    case LTFT_INSERT_BINARY:
    case LTFT_INSERT_BINARY_TYPE:
    case LTFT_INSERT_BINARY_SIZE:
      buf=Add2String(buf,"\"");
      if (i==LTFT_CHECK_BOX) {
	buf=Add2String(buf,ll->display+4);
      } else {
	if (ll->flags2 & LTFLF2_TREE)
	  buf=Add2String(buf,ll->display+3);
	else
	  buf=Add2String(buf,ll->display);
      }
      buf=Add2String(buf,"\",");
      break;
    case LTFT_DATA:
      buf2=MSPrintF("%s%d,",buf,ll->len);
      Free(buf); buf=buf2;
      break;
    case LTFT_HEX_EDIT:
      buf2=MSPrintF("%s%d,",buf,ll->len);
      Free(buf); buf=buf2;
      buf2=MSPrintF("%s%d,",buf,ll->display);
      Free(buf); buf=buf2;
      break;
    case LTFT_PAGE_LENGTH:
    case LTFT_LEFT_MARGIN:
    case LTFT_RIGHT_MARGIN:
    case LTFT_HEADER:
    case LTFT_FOOTER:
    case LTFT_INDENT:
    case LTFT_FOREGROUND_COLOR:
    case LTFT_BACKGROUND_COLOR:
    case LTFT_DEFAULT_FOREGROUND_COLOR:
    case LTFT_DEFAULT_BACKGROUND_COLOR:
    case LTFT_LINK_FOREGROUND:
    case LTFT_LINK_BACKGROUND:
    case LTFT_MACRO_FOREGROUND:
    case LTFT_MACRO_BACKGROUND:
    case LTFT_ANCHOR_FOREGROUND:
    case LTFT_ANCHOR_BACKGROUND:
    case LTFT_HIDDEN_FOREGROUND:
    case LTFT_HIDDEN_BACKGROUND:
    case LTFT_TREE_FOREGROUND:
    case LTFT_TREE_BACKGROUND:
    case LTFT_WORD_WRAP:
    case LTFT_UNDERLINED:
    case LTFT_INVERTED:
    case LTFT_BLINK:
    case LTFT_SHIFTED_X:
    case LTFT_SHIFTED_Y:
      if (ll->attr!=LTF_DEFAULT) {
	buf2=MSPrintF("%s%d,",buf,ll->attr);
	Free(buf); buf=buf2;
      }
      break;
  }
  flags=ll->flags;
  while (flags) {
    j=Bsf(flags);
    Btr(&flags,j);
    switch (j) {
      case LTFLf_SCROLLING_X:
	buf2=MSPrintF("%s%d",buf,ll->scroll_len);
	Free(buf); buf=buf2;
	break;
      case LTFLf_SHIFTED_X:
	j=(ll->type>>16)&0x1F;
	if (j&0x10) j|=0xFFFFFFF0;
	buf2=MSPrintF("%s%d",buf,j);
	Free(buf); buf=buf2;
	break;
      case LTFLf_SHIFTED_Y:
	j=(ll->type>>21)&0x1F;
	if (j&0x10) j|=0xFFFFFFF0;
	buf2=MSPrintF("%s%d",buf,j);
	Free(buf); buf=buf2;
	break;
      case LTFLf_AUX_STRING:
	buf2=MSPrintF("%s\"%Q\"",buf,ll->aux_string);
	Free(buf); buf=buf2;
	break;
      case LTFLf_LEFT_EXP:
	buf2=MSPrintF("%s%d",buf,ll->left_exp);
	Free(buf); buf=buf2;
	break;
      case LTFLf_LEFT_MACRO:
	buf2=MSPrintF("%s\"%Q\"",buf,ll->left_macro);
	Free(buf); buf=buf2;
	break;
      case LTFLf_RIGHT_EXP:
	buf2=MSPrintF("%s%d",buf,ll->right_exp);
	Free(buf); buf=buf2;
	break;
      case LTFLf_RIGHT_MACRO:
	buf2=MSPrintF("%s\"%Q\"",buf,ll->right_macro);
	Free(buf); buf=buf2;
	break;
      case LTFLf_HAS_BIN:
	buf2=MSPrintF("%s%d",buf,ll->bin_num);
	Free(buf); buf=buf2;
	break;
    }
    buf=Add2String(buf,",");
  }
  buf[StrLen(buf)-1]=0;  //Kill last comma
  buf2=NewString(buf); //exact allocation
  Free(buf);
  return buf2;
}


LtfEntry *ParseDollarCmd(char *st,TssStruct *tss)
{
  int i,j,size,flags;
  char *ptr,*st;
  LtfEntry *ll=NULL;
  LexStruct *l=LexNew(st,LF_DONT_FREE_BUFFER);
  Lex(l);
  if (l->token==TK_IDENT) {
    i=MatchSysTextEntry(l->ident,"ST_LTF_CMDS",MLE_IGNORE_CASE);
    if (i<0)
      i=LTFT_ERROR;
    Lex(l); //skip cmd code
    ll=MAllocZ(sizeof(LtfEntry),tss);
    ll->type=i;
    ll->plain_text=NewString(st,tss);
    LtfDefaultFlags(&ll->type,&ll->flags,&ll->flags2);
    ParseLtfFlags(l,&ll->flags,&ll->flags2,&ll->type);

    if (l->token==',')
      Lex(l);
    switch (i) {
      case LTFT_TEXT:
      case LTFT_LINK:
      case LTFT_ANCHOR:
      case LTFT_MENU_VALUE:
      case LTFT_BUTTON:
      case LTFT_CHECK_BOX:
      case LTFT_TREE:
      case LTFT_PICTURE:
      case LTFT_INSERT_BINARY:
      case LTFT_INSERT_BINARY_TYPE:
      case LTFT_INSERT_BINARY_SIZE:
	if (l->token==TK_STRING) {
	  st=LexExtendString(l,&size);
	  if (i==LTFT_CHECK_BOX) {
	    ll->display=MSPrintF("[X] %s",st);
	    ll->min_col=1;
	  } else {
	    if (ll->flags2 & LTFLF2_TREE) {
	      ll->display=MSPrintF("+] %s",st);
	      ll->min_col=1;
	    } else
	      ll->display=st;
	  }
	} else {
	  if (i>=LTFT_PICTURE && i<=LTFT_INSERT_BINARY_SIZE) {
	    ll->display=NewString("");
	  } else {
	    ll->display=0;
	    ll->type=LTFT_ERROR;
	  }
	}
	break;
      case LTFT_HIDE_START:
	ll->display=NewString("<-");
	ll->min_col=1;
	break;
      case LTFT_HIDE_END:
	ll->display=NewString(">");
	break;
      case LTFT_DATA:
	ll->flags=ll->flags | LTFLF_AUX_STRING; //don't allow switched off
	ll->len=Expression(l);
	break;
      case LTFT_HEX_EDIT:
	ll->len=Expression(l);
	if (l->token==',')
	  Lex(l);
	ll->display=Expression(l); //TODO union
	break;
      case LTFT_PAGE_LENGTH:
      case LTFT_LEFT_MARGIN:
      case LTFT_RIGHT_MARGIN:
      case LTFT_HEADER:
      case LTFT_FOOTER:
      case LTFT_INDENT:
      case LTFT_FOREGROUND_COLOR:
      case LTFT_BACKGROUND_COLOR:
      case LTFT_DEFAULT_FOREGROUND_COLOR:
      case LTFT_DEFAULT_BACKGROUND_COLOR:
      case LTFT_LINK_FOREGROUND:
      case LTFT_LINK_BACKGROUND:
      case LTFT_MACRO_FOREGROUND:
      case LTFT_MACRO_BACKGROUND:
      case LTFT_ANCHOR_FOREGROUND:
      case LTFT_ANCHOR_BACKGROUND:
      case LTFT_HIDDEN_FOREGROUND:
      case LTFT_HIDDEN_BACKGROUND:
      case LTFT_TREE_FOREGROUND:
      case LTFT_TREE_BACKGROUND:
      case LTFT_WORD_WRAP:
      case LTFT_UNDERLINED:
      case LTFT_INVERTED:
      case LTFT_BLINK:
      case LTFT_SHIFTED_X:
      case LTFT_SHIFTED_Y:
	if (!l->token)
	  ll->attr=LTF_DEFAULT;
	else
	  ll->attr=Expression(l);
	break;
      case LTFT_ERROR:
	ll->flags=0;
	ll->flags2=0;
	ll->type=LTFT_ERROR;
	break;
    }
 
    flags=ll->flags;
    while (flags) {
      j=Bsf(flags);
      Btr(&flags,j);
      if (l->token==',')
	Lex(l);
      switch (j) {  //TODO: Might check for expression errors
	case LTFLf_SCROLLING_X:
	  ll->scroll_len=Expression(l);
	  break;
	case LTFLf_SHIFTED_X:
	  ll->type|=((Expression(l) & 0x1F)<<16);
	  break;
	case LTFLf_SHIFTED_Y:
	  ll->type|=((Expression(l) & 0x1F)<<21);
	  break;
	case LTFLf_AUX_STRING:
	  if (l->token==TK_STRING) {
	    ll->aux_string=LexExtendString(l,&size);
	    if (i==LTFT_MACRO && !ll->display)
	      ll->display=NewString(ll->aux_string,tss);
	    if (i==LTFT_DATA) {
	      if (ptr=StrStr(ll->aux_string,":"))
		ll->min_col=ptr-ll->aux_string+1;
	      ll->display=MAlloc(ll->len+ll->min_col+2,tss);
	    }
	  } else
	    ll->type=LTFT_ERROR;
	  break;
	case LTFLf_LEFT_EXP:
	  ll->left_exp=Expression(l);
	  break;
	case LTFLf_LEFT_MACRO:
	  if (l->token==TK_STRING) {
	    ll->left_macro=LexExtendString(l,&size);
	    if (i==LTFT_MACRO && !ll->display)
	      ll->display=NewString(ll->left_macro,tss);
	  } else
	    ll->type=LTFT_ERROR;
	  break;
	case LTFLf_RIGHT_EXP:
	  ll->right_exp=Expression(l);
	  break;
	case LTFLf_RIGHT_MACRO:
	  if (l->token==TK_STRING) {
	    ll->right_macro=LexExtendString(l,&size);
	    if (i==LTFT_MACRO && !ll->display)
	      ll->display=NewString(ll->right_macro,tss);
	  } else
	    ll->type=LTFT_ERROR;
	  break;
	case LTFLf_HAS_BIN:
	  if (!l->token)
	    ll->bin_num=0;
	  else
	    ll->bin_num=Expression(l);
	  break;
      }
    }
  } else if (!ll) {
    ll=MAllocZ(sizeof(LtfEntry),tss);
    ll->type=LTFT_ERROR;
    ll->plain_text=NewString(st,tss);
  }
  LexDel(l);
  return ll;
}

void LtfInsert(Ltf *l,LtfEntry *ll)
{
  char *dst;
  LtfEntry *cl=l->cur_entry,*nl;

  ll->x=cl->x;
  ll->y=cl->y;
  ll->indent=cl->indent;
  ll->page_line_num=cl->page_line_num;
  ll->left_margin=cl->left_margin;
  ll->right_margin=cl->right_margin;
  if (l->cur_data_col>0 &&
      cl->btype==LTFT_TEXT &&
      l->cur_data_col<cl->max_col) {
    nl=MAllocZ(sizeof(LtfEntryBase)+4,l->mem_tss);
    nl->type=LTFT_TEXT|(cl->type & 0xFFFFFF00);
    nl->x=cl->x;
    nl->y=cl->y;
    nl->indent=cl->indent;
    nl->page_line_num=cl->page_line_num;
    nl->left_margin=cl->left_margin;
    nl->right_margin=cl->right_margin;
    nl->flags=cl->flags;
    nl->flags2=cl->flags2;
    dst=cl->display+l->cur_data_col;
    nl->display=NewString(dst,l->mem_tss);
    *dst=0;
    cl->max_col=l->cur_data_col;
    InsQue(nl,cl);
    l->cur_data_col=0;
    cl=nl;
    cl->max_col=StrLen(cl->display);
  }
  if (cl->btype==LTFT_TEXT && l->cur_data_col>=cl->max_col) {
    InsQue(ll,cl);
    l->cur_entry=ll->next;
  } else {
    InsQue(ll,cl->last);
    l->cur_entry=cl;
  }
  l->cur_data_col=l->cur_entry->min_col;
}


public LtfEntry *LtfPutS(Ltf *l,char *st)
{
  char ch,*ptr=st,*ptr2,*st2,*ptr3,*ptr4,*src;
  BOOL old_preempt=Preempt(OFF);
  LtfEntry *ll=NULL,*result=NULL,*cl=l->cur_entry;
  l->recalc_start=l; //TODO:This might be optimized
  if (!st) {
    Preempt(old_preempt);
    return NULL;
  }
  while (*ptr) {
    ptr2=ptr;
    ch=*ptr++;
    if (l->flags & LTFF_PLAIN_TEXT_WITH_TABS) {
      while (ch && ch!=CH_CR && ch!=CH_LINE_FEED)
	ch=*ptr++;
    } else if (l->flags & LTFF_PLAIN_TEXT) {
      while (ch && ch!=CH_CR && ch!=CH_LINE_FEED && ch!=CH_TAB && ch!=CH_CURSOR && ch!=CH_FORM_FEED)
	ch=*ptr++;
    } else {
      while (ch && ch!=CH_CR && ch!=CH_LINE_FEED && ch!=CH_TAB && ch!=CH_CURSOR && ch!=CH_FORM_FEED && ch!='$')
	ch=*ptr++;
    }
    ptr--;
    if (!ch) {
      if (ptr!=ptr2) {
	ll=MAllocZ(sizeof(LtfEntryBase)+4,l->mem_tss);
	ll->type=LTFT_TEXT | (l->text_attribute << 8);
	if (l->flags & LTFF_NO_CURSOR) {
	  src=NewString(ptr2);
	  StringUtil(src,SU_REMOVE_CTRL_CHARS);
	} else
	  src=ptr2;
	ll->display=NewString(src,l->mem_tss);
	ll->max_col=StrLen(src);
	LtfInsert(l,ll);
	if (l->flags & LTFF_NO_CURSOR)
	  Free(src);
      }
    } else {
      if (ptr!=ptr2) {
	*ptr=0;
	ll=MAllocZ(sizeof(LtfEntryBase)+4,l->mem_tss);
	ll->type=LTFT_TEXT | (l->text_attribute << 8);
	if (l->flags & LTFF_NO_CURSOR) {
	  src=NewString(ptr2);
	  StringUtil(src,SU_REMOVE_CTRL_CHARS);
	} else
	  src=ptr2;
	ll->display=NewString(src,l->mem_tss);
	ll->max_col=StrLen(src);
	LtfInsert(l,ll);
	if (l->flags & LTFF_NO_CURSOR)
	  Free(src);
	*ptr=ch;
      }
      if (ch==CH_CURSOR) { //cursor
	ll=MAllocZ(sizeof(LtfEntryBase),l->mem_tss);
	ll->type=LTFT_CURSOR | (l->text_attribute << 8);
	LtfInsert(l,ll);
	ptr++;
      } else if (ch==CH_FORM_FEED) {
	ll=MAllocZ(sizeof(LtfEntryBase),l->mem_tss);
	ll->type=LTFT_PAGE_BREAK | (l->text_attribute << 8);
	LtfInsert(l,ll);
	ptr++;
      } else if (ch==CH_TAB) {
	ll=MAllocZ(sizeof(LtfEntryBase),l->mem_tss);
	ll->type=LTFT_TAB | (l->text_attribute << 8);
	LtfInsert(l,ll);
	ptr++;
      } else if (ch=='$') {
	ptr++; //skip first dollar
	ptr2=ptr;
	while (*ptr && *ptr!='$')
	  ptr++;
	if (*ptr) {
	  *ptr=0; //zero second dollar
	  if (ptr==ptr2) {
	    ll=MAllocZ(sizeof(LtfEntryBase)+4,l->mem_tss);
	    ll->type=LTFT_TEXT | (l->text_attribute << 8);
	    ll->max_col=1;
	    if (l->flags & LTFF_DOUBLE_DOLLARS)
	      ll->display=NewString("$$",l->mem_tss);
	    else
	      ll->display=NewString("$",l->mem_tss);
   	    LtfInsert(l,ll);
	  } else {
	    st2=MAlloc(ptr-ptr2+1);
	    ptr3=ptr2;
	    ptr4=st2;
	    while (*ptr3) {
	      ch=*ptr3++;
	      if (ch==CH_CURSOR) {
		ll=MAllocZ(sizeof(LtfEntryBase),l->mem_tss);
		ll->type=LTFT_CURSOR | (l->text_attribute << 8);
		LtfInsert(l,ll);
	      } else if (ch==CH_FORM_FEED) {
		ll=MAllocZ(sizeof(LtfEntryBase),l->mem_tss);
		ll->type=LTFT_PAGE_BREAK | (l->text_attribute << 8);
		LtfInsert(l,ll);
	      } else
		*ptr4++=ch;
	    }
	    *ptr4=0;
	    if (ll=ParseDollarCmd(st2,l->mem_tss)) {
	      result=ll;
   	      LtfInsert(l,ll);
	    }
	    Free(st2);
	  }
	  *ptr++='$';
	}
      } else {
	ll=MAllocZ(sizeof(LtfEntryBase),l->mem_tss);
	ll->type=LTFT_CR | (l->text_attribute << 8);
   	LtfInsert(l,ll);
	if (ch==CH_CR)
	  while (*ptr==CH_CR)
	    ptr++;
	if (*ptr==CH_LINE_FEED)
	  ptr++;
	while (*ptr==CH_CR)
	  ptr++;
      }
    }
  }
  Preempt(old_preempt);
  return result;
}


public LtfEntry *LtfPrintF(Ltf *l,char *src,...)
{
  LtfEntry *result;
  char *buf=SPrintFJoin(NULL,src,argc,argv);
  result=LtfPutS(l,buf);
  Free(buf);
  return result;
}

public void LtfSetMax(DWORD i)
{
  Ltf *l=Fs->cur_ltf;
  l->max_entries=i;
}

public void LtfSafeInsert(Ltf *l,char *st)
{ //This is necessary when hidden text might screw-up
  //inserts.  It does them all-at-once.
  BOOL old_preempt=Preempt(OFF);
  DWORD old_flags=l->flags;
  l->flags|=LTFF_NO_CURSOR;
  LtfPutS(l,st);
  LtfRecalc(l);
  l->flags=old_flags;
  Preempt(old_preempt);
}

extern void EditInsertLtf(Ltf *l,Ltf *b);
extern Ltf *LtfRead(char *name,DWORD flags=0);

public void Type(char *name)
{
  Ltf *l=LtfRead(name);
  EditInsertLtf(Fs->cur_ltf,l);
  LtfDel(l);
}


