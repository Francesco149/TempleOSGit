#help_index "Math"
public U0 R2P(F64 *mag=NULL,F64 *arg=NULL,F64 x,F64 y)
{ //Rect to polar
  //returns angle in range (-pi,pi]
  if (arg)
    *arg=Arg(x,y);
  if (mag)
    *mag=Sqrt(x*x+y*y);
}

public U0 P2R(F64 *x=NULL,F64 *y=NULL,F64 mag,F64 arg)
{ //Polar to Rect
  if (x)
    *x=mag*Cos(arg);
  if (y)
    *y=mag*Sin(arg);
}

public F64 Unwrap(F64 theta,F64 base=-pi)
{ //returns angle in range [base,base+2*pi)
  F64 result=theta%(2*pi);
  if (result>=base+2*pi)
    result-=2*pi;
  else if (result<base)
    result+=2*pi;
  return result;
}

public I64 DistI64(I64 x1,I64 y1,I64 x2,I64 y2)
{
  I64 dx=x1-x2,dy=y1-y2;
  return dx*dx+dy*dy;
}

public F64 ASin(F64 s)
{
  F64 c;
  c=s*s;
  if (c>=1.0)
    return pi/2.0;
  c=Sqrt(1.0-c);
  return ATan(s/c);
}

public F64 ACos(F64 c)
{
  F64 s;
  if (!c)
    return pi/2.0;
  s=c*c;
  if (s>=1.0)
    return 0.0;
  s=Sqrt(1.0-s);
  return ATan(s/c);
}

#help_index "Math/Complex"
public Complex *CAdd(Complex *n1,Complex *n2,Complex *sum)
{
  sum->x=n1->x+n2->x;
  sum->y=n1->y+n2->y;
  return sum;
}

public Complex *CSub(Complex *n1,Complex *n2,Complex *diff)
{
  diff->x=n1->x-n2->x;
  diff->y=n1->y-n2->y;
  return diff;
}

public Complex *CMul(Complex *n1,Complex *n2,Complex *prod)
{
  prod->x=n1->x*n2->x-n1->y*n2->y;
  prod->y=n1->x*n2->y+n1->y*n2->x;
  return prod;
}

public Complex *CDiv(Complex *n1,Complex *n2,Complex *quot)
{
  F64 m1,a1,m2,a2;
  R2P(&m1,&a1,n1->x,n1->y);
  R2P(&m2,&a2,n2->x,n2->y);
  m1/=m2;
  a1-=a2;
  quot->x=m1*Cos(a1);
  quot->y=m1*Sin(a1);
  return quot;
}

public Complex *CScale(Complex *dst,F64 s)
{
  dst->x*=s;
  dst->y*=s;
  return dst;
}

public Complex *CCopy(Complex *dst,Complex *src)
{
  dst->x=src->x;
  dst->y=src->y;
  return dst;
}

public Complex *CEqu(Complex *dst,F64 x,F64 y)
{
  dst->x=x;
  dst->y=y;
  return dst;
}

public Complex *CPoly(Complex *dst,Complex *x,Complex *zeros,I64 n)
{
  I64 i;
  Complex n1,n2;
  if (n>0) {
    CSub(x,&zeros[0],dst);
    for (i=1;i<n;i++) {
      CCopy(&n1,dst);
      CSub(x,&zeros[i],&n2);
      CMul(&n1,&n2,dst);
    }
  } else
    CEqu(dst,1.0,0.0);
  return dst;
}

#help_index ""
