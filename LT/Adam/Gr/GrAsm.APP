asm {
USE64
GR_TEXT_BASE::	DU64	0;
GR_WIN_Z_BUF::	DU64	0;
// ************************************
_PLOT_SCREEN_U8::
	ENTER	0
	MOV	RBX,U64 SF_ARG2[RBP]
	MOV	RAX,U64 SF_ARG3[RBP]
	OR	RBX,RBX
	JS	@@05
	OR	RAX,RAX
	JS	@@05
	CMP	RBX,TEXT_COLS
	JGE	@@05
	CMP	RAX,TEXT_ROWS
	JGE	@@05
	IMUL2	RAX,TEXT_COLS
	ADD	RBX,RAX
	SHL	RBX,2
	ADD	RBX,U64 [GR_TEXT_BASE]
	MOV	RAX,U64 SF_ARG1[RBP]
	MOV	U32 [RBX],EAX

	MOV	RAX,1
	LEAVE
	RET1	24
@@05:	XOR	RAX,RAX
	LEAVE
	RET1	24
// ************************************
_PLOT_WIN_U8::
	ENTER	0
	MOV	RCX,U64 SF_ARG1[RBP]
	MOV	RBX,U64 TaskStruct.win_scroll_x[RCX]
	SAR	RBX,3
	ADD	RBX,U64 SF_ARG3[RBP]
	MOV	RAX,U64 TaskStruct.win_scroll_y[RCX]
	SAR	RAX,3
	ADD	RAX,U64 SF_ARG4[RBP]

	OR	RBX,RBX
	JS	@@05
	ADD	RBX,U64 TaskStruct.win_left[RCX]
	CMP	RBX,U64 TaskStruct.win_right[RCX]
	JG	@@05
	OR	RBX,RBX
	JS	@@05
	CMP	RBX,TEXT_COLS
	JGE	@@05

	OR	RAX,RAX
	JS	@@05
	ADD	RAX,U64 TaskStruct.win_top[RCX]
	CMP	RAX,U64 TaskStruct.win_bottom[RCX]
	JG	@@05
	OR	RAX,RAX
	JS	@@05
	CMP	RAX,TEXT_ROWS
	JGE	@@05

	IMUL2	RAX,TEXT_COLS
	ADD	RBX,RAX
	SHL	RBX,2
	ADD	RBX,U64 [GR_TEXT_BASE]
	MOV	RAX,U64 SF_ARG2[RBP]
	MOV	U32 [RBX],EAX

	MOV	RAX,1
	LEAVE
	RET1	32
@@05:	XOR	RAX,RAX
	LEAVE
	RET1	32
// ************************************
/*
BoolI8 PlotWinStr2(TaskStruct *task,U8 *s,I64 len,
		   U64 attr,I64 x,I64 y)
*/
_PLOT_WIN_STR2::
	ENTER	0
	MOV	R9,U64 [GR_TEXT_BASE]
	PUSH	RSI
	PUSH	RDI
	MOV	RBX,U64 SF_ARG1[RBP]
	MOV	RSI,U64 SF_ARG2[RBP]
	MOV	RDI,U64 TaskStruct.win_scroll_x[RBX]
	SAR	RDI,3
	ADD	RDI,U64 SF_ARG5[RBP]
	MOV	RCX,U64 SF_ARG3[RBP]

	OR	RDI,RDI
	JNS	@@05
	ADD	RCX,RDI
	SUB	RSI,RDI
	XOR	RDI,RDI
@@05:	ADD	RDI,U64 TaskStruct.win_left[RBX]
	MOV	RDX,RCX
	ADD	RDX,RDI
	DEC	RDX
	CMP	RDX,U64 TaskStruct.win_right[RBX]
	JLE	@@10
	MOV	RAX,RDX
	SUB	RAX,U64 TaskStruct.win_right[RBX]
	SUB	RDX,RAX
	SUB	RCX,RAX
@@10:	OR	RDI,RDI
	JNS	@@15
	ADD	RCX,RDI
	SUB	RSI,RDI
	XOR	RDI,RDI
@@15:	INC	RDX
	SUB	RDX,TEXT_COLS
	JLE	@@20
	SUB	RCX,RDX
@@20:	CMP	RCX,1
	JL	@@30

	MOV	RAX,U64 TaskStruct.win_scroll_y[RBX]
	SAR	RAX,3
	ADD	RAX,U64 SF_ARG6[RBP]
	OR	RAX,RAX
	JS	@@30
	ADD	RAX,U64 TaskStruct.win_top[RBX]
	CMP	RAX,U64 TaskStruct.win_bottom[RBX]
	JG	@@30
	OR	RAX,RAX
	JS	@@30
	CMP	RAX,TEXT_ROWS
	JGE	@@30

	IMUL2	RAX,TEXT_COLS
	ADD	RDI,RAX
	SHL	RDI,2
	ADD	RDI,R9
	MOV	RAX,U64 SF_ARG4[RBP]
@@25:	LODSB
	STOSD
	DEC	RCX
	JNZ	@@25

	POP	RDI
	POP	RSI
	MOV	RAX,TRUE
	LEAVE
	RET1	48

@@30:	POP	RDI
	POP	RSI
	XOR	RAX,RAX
	LEAVE
	RET1	48
// ************************************
/*
BoolI8 PlotAttrStr2(TaskStruct *task,U32 *hl,I64 len,I64 x,I64 y)
*/
_PLOT_ATTR_STR2::
	ENTER	0
	MOV	R9,U64 [GR_TEXT_BASE]
	PUSH	RSI
	PUSH	RDI
	MOV	RBX,U64 SF_ARG1[RBP]
	MOV	RSI,U64 SF_ARG2[RBP]
	MOV	RDI,U64 TaskStruct.win_scroll_x[RBX]
	SAR	RDI,3
	ADD	RDI,U64 SF_ARG4[RBP]
	MOV	RCX,U64 SF_ARG3[RBP]

	OR	RDI,RDI
	JNS	@@05
	ADD	RCX,RDI
	SHL	RDI,2
	SUB	RSI,RDI
	XOR	RDI,RDI
@@05:	ADD	RDI,U64 TaskStruct.win_left[RBX]
	MOV	RDX,RCX
	ADD	RDX,RDI
	DEC	RDX
	CMP	RDX,U64 TaskStruct.win_right[RBX]
	JLE	@@10
	MOV	RAX,RDX
	SUB	RAX,U64 TaskStruct.win_right[RBX]
	SUB	RDX,RAX
	SUB	RCX,RAX
@@10:	OR	RDI,RDI
	JNS	@@15
	ADD	RCX,RDI
	SHL	RDI,2
	SUB	RSI,RDI
	XOR	RDI,RDI
@@15:	INC	RDX
	SUB	RDX,TEXT_COLS
	JLE	@@20
	SUB	RCX,RDX
@@20:	CMP	RCX,1
	JL	@@30

	MOV	RAX,U64 TaskStruct.win_scroll_y[RBX]
	SAR	RAX,3
	ADD	RAX,U64 SF_ARG5[RBP]
	OR	RAX,RAX
	JS	@@30
	ADD	RAX,U64 TaskStruct.win_top[RBX]
	CMP	RAX,U64 TaskStruct.win_bottom[RBX]
	JG	@@30
	OR	RAX,RAX
	JS	@@30
	CMP	RAX,TEXT_ROWS
	JGE	@@30

	IMUL2	RAX,TEXT_COLS
	ADD	RDI,RAX
	SHL	RDI,2
	ADD	RDI,R9
@@25:	MOVSD
	DEC	RCX
	JNZ	@@25

	POP	RDI
	POP	RSI
	MOV	RAX,TRUE
	LEAVE
	RET1	40

@@30:	POP	RDI
	POP	RSI
	XOR	RAX,RAX
	LEAVE
	RET1	40
// ************************************
/*
BoolI8 PlotAttr(TaskStruct *task,I64 len,
		U64 attr,I64 x,I64 y)
*/
_PLOT_ATTR::
	ENTER	0
	MOV	R9,U64 [GR_TEXT_BASE]
	PUSH	RSI
	PUSH	RDI
	MOV	RBX,U64 SF_ARG1[RBP]
	MOV	RDI,U64 TaskStruct.win_scroll_x[RBX]
	SAR	RDI,3
	ADD	RDI,U64 SF_ARG4[RBP]
	MOV	RCX,U64 SF_ARG2[RBP]

	OR	RDI,RDI
	JNS	@@05
	ADD	RCX,RDI
	XOR	RDI,RDI
@@05:	ADD	RDI,U64 TaskStruct.win_left[RBX]
	MOV	RDX,RCX
	ADD	RDX,RDI
	DEC	RDX
	CMP	RDX,U64 TaskStruct.win_right[RBX]
	JLE	@@10
	MOV	RAX,RDX
	SUB	RAX,U64 TaskStruct.win_right[RBX]
	SUB	RDX,RAX
	SUB	RCX,RAX
@@10:	OR	RDI,RDI
	JNS	@@15
	ADD	RCX,RDI
	XOR	RDI,RDI
@@15:	INC	RDX
	SUB	RDX,TEXT_COLS
	JLE	@@20
	SUB	RCX,RDX
@@20:	CMP	RCX,1
	JL	@@35

	MOV	RAX,U64 TaskStruct.win_scroll_y[RBX]
	SAR	RAX,3
	ADD	RAX,U64 SF_ARG5[RBP]
	OR	RAX,RAX
	JS	@@35
	ADD	RAX,U64 TaskStruct.win_top[RBX]
	CMP	RAX,U64 TaskStruct.win_bottom[RBX]
	JG	@@35
	OR	RAX,RAX
	JS	@@35
	CMP	RAX,TEXT_ROWS
	JGE	@@35

	IMUL2	RAX,TEXT_COLS
	ADD	RDI,RAX
	SHL	RDI,2
	ADD	RDI,R9
	MOV	RBX,U64 SF_ARG3[RBP]
	MOV	RSI,RDI
@@25:	LODSD
	OR	AL,AL
	JNZ	@@30
	MOV	RAX,RBX
	STOSD
	DEC	RCX
	JNZ	@@25

@@30:	POP	RDI
	POP	RSI
	MOV	RAX,TRUE
	LEAVE
	RET1	40

@@35:	POP	RDI
	POP	RSI
	XOR	RAX,RAX
	LEAVE
	RET1	40
// ************************************
_PLOT_BORDER_U8::
	ENTER	0
	MOV	R9,U64 [GR_TEXT_BASE]
	MOV	RCX,U64 SF_ARG1[RBP]
	MOV	RBX,U64 TaskStruct.win_scroll_x[RCX]
	SAR	RBX,3
	ADD	RBX,U64 SF_ARG3[RBP]
	MOV	RAX,U64 TaskStruct.win_scroll_y[RCX]
	SAR	RAX,3
	ADD	RAX,U64 SF_ARG4[RBP]

	MOV	RDX,-1
	CMP	RBX,RDX
	JL	@@05
	ADD	RBX,U64 TaskStruct.win_left[RCX]
	MOV	RDX,U64 TaskStruct.win_right[RCX]
	INC	RDX
	CMP	RBX,RDX
	JG	@@05
	OR	RBX,RBX
	JS	@@05
	CMP	RBX,TEXT_COLS
	JGE	@@05

	MOV	RDX,-1
	CMP	RAX,RDX
	JL	@@05
	ADD	RAX,U64 TaskStruct.win_top[RCX]
	MOV	RDX,U64 TaskStruct.win_bottom[RCX]
	INC	RDX
	CMP	RAX,RDX
	JG	@@05
	OR	RAX,RAX
	JS	@@05
	CMP	RAX,TEXT_ROWS
	JGE	@@05

	IMUL2	RAX,TEXT_COLS
	ADD	RBX,RAX
	SHL	RBX,2
	ADD	RBX,R9
	MOV	RAX,U64 SF_ARG2[RBP]
	MOV	U32 [RBX],EAX

	MOV	RAX,TRUE
	LEAVE
	RET1	32
@@05:	XOR	RAX,RAX
	LEAVE
	RET1	32
// ************************************
_GR_UPDATE_LINE32::
	ENTER	0
	PUSH	RSI
	PUSH	RDI

	MOV	RAX,U64 SF_ARG2[RBP]
	MOV	RSI,U64 [RAX]	//rsi=src2
	MOV	RBX,U64 [&reverse_bits_table]
	MOV	RCX,U64 SF_ARG3[RBP] //rcx=d5
	MOV	RAX,U64 SF_ARG4[RBP]
	MOV	RDI,U64 [RAX]	//rdi=vga image

	MOV	RAX,U64 SF_ARG1[RBP]
	MOV	R8,U64 [RAX]	//rbp=vga dst

@@05:	LODSD
	CMP	U32 [RDI],EAX
	JE	@@10
	MOV	U32 [RDI],EAX
	XLATB
	ROR	EAX,8
	XLATB
	ROR	EAX,8
	XLATB
	ROR	EAX,8
	XLATB
	ROR	EAX,8
	MOV	U32 [R8],EAX
@@10:	ADD	RDI,4
	ADD	R8,4
	DEC	RCX
	JNZ	@@05

	MOV	RAX,U64 SF_ARG1[RBP]
	MOV	U64 [RAX],R8
	MOV	RAX,U64 SF_ARG4[RBP]
	MOV	U64 [RAX],RDI
	MOV	RAX,U64 SF_ARG2[RBP]
	MOV	U64 [RAX],RSI
	POP	RDI
	POP	RSI
	LEAVE
	RET1	32
// ************************************
_GR_UPDATE_LINE32_FLUSH_CACHE::
	ENTER	0
	PUSH	RSI
	PUSH	RDI

	MOV	RAX,U64 SF_ARG2[RBP]
	MOV	RSI,U64 [RAX]	//rsi=src2
	MOV	RBX,U64 [&reverse_bits_table]
	MOV	RCX,U64 SF_ARG3[RBP] //rcx=d5
	MOV	RAX,U64 SF_ARG4[RBP]
	MOV	RDI,U64 [RAX]	//rdi=vga image

	MOV	RAX,U64 SF_ARG1[RBP]
	MOV	R8,U64 [RAX]	//rbp=vga dst

@@05:	LODSD
	MOV	U32 [RDI],EAX
	XLATB
	ROR	EAX,8
	XLATB
	ROR	EAX,8
	XLATB
	ROR	EAX,8
	XLATB
	ROR	EAX,8
	MOV	U32 [R8],EAX
	ADD	RDI,4
	ADD	R8,4
	DEC	RCX
	JNZ	@@05

	MOV	RAX,U64 SF_ARG1[RBP]
	MOV	U64 [RAX],R8
	MOV	RAX,U64 SF_ARG4[RBP]
	MOV	U64 [RAX],RDI
	MOV	RAX,U64 SF_ARG2[RBP]
	MOV	U64 [RAX],RSI
	POP	RDI
	POP	RSI
	LEAVE
	RET1	32
// ************************************
_GR_PLOT_U8::
	ENTER	0
	PUSH	RSI
	PUSH	RDI
	MOV	RDX,1 //EDX=plane
	MOV	RBX,U64 SF_ARG4[RBP]	//RBX=d1
	MOV	RAX,U64 SF_ARG3[RBP]
	MOV	RDI,U64 [RAX]		//RDI=dst2
@@05:	MOV	RSI,U64 SF_ARG1[RBP]	//RSI=font_ptr2
	TEST	U64 SF_ARG2[RBP],RDX
	JZ	@@15

@@10:	LODSQ
	OR	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	OR	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	OR	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	OR	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	OR	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	OR	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	OR	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	OR	U8 [RDI],AL
	ADD	RDI,RBX
	JMP	@@20

@@15:	LODSQ
	NOT	RAX
	AND	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	AND	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	AND	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	AND	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	AND	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	AND	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	AND	U8 [RDI],AL
	ADD	RDI,RBX
	ROR	RAX,8
	AND	U8 [RDI],AL
	ADD	RDI,RBX

@@20:	ADD	RDI,U64 SF_ARG5[RBP]
	SHL1	RDX
	CMP	RDX,0x10
	JNE	U32 @@05

	MOV	RAX,U64 SF_ARG3[RBP]
	MOV	U64 [RAX],RDI
	POP	RDI
	POP	RSI
	LEAVE
	RET1	40
// ************************************
_GR_PLOT_BACKGROUND::
	ENTER	0
	PUSH	RDI
	MOV	RDX,0x10 //EDX=plane
	MOV	RBX,U64 SF_ARG3[RBP]	//RBX=d1
	MOV	RAX,U64 SF_ARG2[RBP]	//RDI=dst
	MOV	RDI,U64 [RAX]		//RDI=dst

@@05:	XOR	RAX,RAX
	TEST	U64 SF_ARG1[RBP],RDX
	JZ	@@10
	DEC	RAX

@@10:	MOV	U8 [RDI],AL
	ADD	RDI,RBX
	MOV	U8 [RDI],AL
	ADD	RDI,RBX
	MOV	U8 [RDI],AL
	ADD	RDI,RBX
	MOV	U8 [RDI],AL
	ADD	RDI,RBX
	MOV	U8 [RDI],AL
	ADD	RDI,RBX
	MOV	U8 [RDI],AL
	ADD	RDI,RBX
	MOV	U8 [RDI],AL
	ADD	RDI,RBX
	MOV	U8 [RDI],AL
	ADD	RDI,RBX

	ADD	RDI,U64 SF_ARG4[RBP]
	SHL1	RDX
	CMP	RDX,0x100
	JNE	@@05

	MOV	RAX,U64 SF_ARG2[RBP]
	MOV	U64 [RAX],RDI
	POP	RDI
	LEAVE
	RET1	32
// ************************************
_IS_PIXEL_COVERED0::
	ENTER	0
#assert FONT_WIDTH==FONT_HEIGHT==8
	MOV	RCX,U64 SF_ARG3[RBP]
	SAR	RCX,3
	MOV	RAX,U64 SF_ARG2[RBP]
	SAR	RAX,3
	MOV	RDX,U64 SF_ARG1[RBP]
	IMUL2	RCX,TEXT_COLS
	MOV	RBX,U64 [GR_WIN_Z_BUF]
	MOV	DX,U16 TaskStruct.win_z_num[RDX]
	ADD	RCX,RAX
	XOR	RAX,RAX
	CMP	DX,U16 [RBX+RCX*2]
	JAE	@@05	//Jump not covered
	INC	RAX
@@05:	LEAVE
	RET1	24
}

#help_index "Graphics/Char;Char/Graphics"
public LTextern GR_TEXT_BASE	U32 *gr_text_base;
public LTextern GR_WIN_Z_BUF	U16 *gr_win_z_buf;
#help_index "Graphics"

//No clipping
public LTextern _IS_PIXEL_COVERED0 BoolI64 IsPixelCovered0(TaskStruct *task,I64 x,I64 y);

LTextern _GR_UPDATE_LINE32 U0 GrUpdateLine32(U32 **dst3,U32 **src2,U64 d5b,
				    U0 **vga);
LTextern _GR_UPDATE_LINE32_FLUSH_CACHE U0 GrUpdateLine32FlushCache(U32 **dst3,U32 **src2,U64 d5b,
				    U0 **vga);
LTextern _GR_PLOT_U8 U0 GrPlotU8(U8 *font_ptr,U8 attr,U8 **dst2,U64 d1,U64 d2);
LTextern _GR_PLOT_BACKGROUND U0 GrPlotBackground(U8 attr,U8 **dst,U64 d1,U64 d2);

#help_index "Graphics/Char;Char/Graphics"
public LTextern _PLOT_SCREEN_U8 BoolI64 PlotScreenU8(U64 w,I64 x,I64 y);
public LTextern _PLOT_WIN_U8 BoolI64 PlotWinU8(TaskStruct *task,U64 w,I64 x,I64 y);
public LTextern _PLOT_WIN_STR2	BoolI64 PlotWinStr2(
	   TaskStruct *task,U8 *s,I64 len,U64 attr,I64 x,I64 y);
public LTextern _PLOT_ATTR_STR2 BoolI64 PlotAttrStr2(
	   TaskStruct *task,U32 *hl,I64 len,I64 x,I64 y);

public LTextern _PLOT_ATTR	  BoolI64 PlotWinAttr(
	   TaskStruct *task,I64 len,U64 attr,I64 x,I64 y);
public LTextern _PLOT_BORDER_U8 BoolI64 PlotBorderU8(TaskStruct *task,U64 w,I64 x,I64 y);
#help_index ""
