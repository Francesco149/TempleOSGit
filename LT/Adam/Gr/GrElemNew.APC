#help_index "Graphics/GrElem"
#help_file "::/LT/Doc/GrElem"

I64 gr_elem_base_size[GRET_NUM_TYPES]=
{
offset(GrElem.x1)-offset(GrElem.start), //GRET_END
0,
1+offset(GrElem.color4)-offset(GrElem.start), //GRET_COLOR4
0,
offset(GrElem.x2)-offset(GrElem.start), //GRET_POINT
offset(GrElem.linespeed)-offset(GrElem.start), //GRET_LINE
offset(GrElem.y1)-offset(GrElem.start), //GRET_POLYLINE
offset(GrElem.y1)-offset(GrElem.start), //GRET_POLYPOINT
offset(GrElem.y1)-offset(GrElem.start), //GRET_WIDTH
offset(GrElem.x2)-offset(GrElem.start), //GRET_SHIFT
offset(GrElem.y1)-offset(GrElem.start), //GRET_BSPLINE2
offset(GrElem.y1)-offset(GrElem.start), //GRET_BSPLINE3
offset(GrElem.y1)-offset(GrElem.start), //GRET_BSPLINE2_CLOSED
offset(GrElem.y1)-offset(GrElem.start), //GRET_BSPLINE3_CLOSED
offset(GrElem.y1)-offset(GrElem.start), //GRET_SPEEDLINE
offset(GrElem.sides)-offset(GrElem.start), //GRET_SPEEDLINE_POINT
0, //GRET_SPEEDLINE_SPEED
offset(GrElem.linespeed)-offset(GrElem.start), //GRET_RECT
offset(GrElem.y2)-offset(GrElem.start), //GRET_CIRCLE
offset(GrElem.x2)-offset(GrElem.start), //GRET_FLOOD_FILL_NOT
offset(GrElem.x2)-offset(GrElem.start), //GRET_FLOOD_FILL
offset(GrElem.sides)-offset(GrElem.start), //GRET_BITMAP4
offset(GrElem.sides)-offset(GrElem.start), //GRET_BITMAP4_TRANSPARENT
offset(GrElem.st)-offset(GrElem.start), //GRET_TEXT
offset(GrElem.sides)-offset(GrElem.start), //GRET_ELLIPSE
sizeof(GrElem)-offset(GrElem.start), //GRET_REG_POLY
offset(GrElem.linespeed)-offset(GrElem.start), //GRET_PLANAR_SYMMETRY
1+offset(GrElem.dither_color4)-offset(GrElem.start), //GRET_DITHER_COLOR4
offset(GrElem.sides)-offset(GrElem.start), //GRET_ROTATED_RECT
offset(GrElem.x2)-offset(GrElem.start), //GRET_MESH
offset(GrElem.shiftable_triangle_cnt)+sizeof(I32)-offset(GrElem.start), //GRET_SHIFTABLE_MESH
offset(GrElem.x1)-offset(GrElem.start), //GRET_TRANSFORM_ON
offset(GrElem.x1)-offset(GrElem.start), //GRET_TRANSFORM_OFF
offset(GrElem.linespeed)-offset(GrElem.start), //GRET_ARROW
offset(GrElem.st)-offset(GrElem.start), //GRET_TEXT_BOX
offset(GrElem.st)-offset(GrElem.start), //GRET_TEXT_DIAMOND
};

I64 gr_elem_queued_base_size[GRET_NUM_TYPES]=
{
offset(GrElem.x1),//GRET_END
0,
1+offset(GrElem.color4), //GRET_COLOR4
0,
offset(GrElem.x2), //GRET_POINT
offset(GrElem.linespeed), //GRET_LINE
offset(GrElem.y1), //GRET_POLYLINE
offset(GrElem.y1), //GRET_POLYPOINT
offset(GrElem.y1), //GRET_WIDTH
offset(GrElem.x2), //GRET_SHIFT
offset(GrElem.y1), //GRET_BSPLINE2
offset(GrElem.y1), //GRET_BSPLINE3
offset(GrElem.y1), //GRET_BSPLINE2_CLOSED
offset(GrElem.y1), //GRET_BSPLINE3_CLOSED
offset(GrElem.y1), //GRET_SPEEDLINE
offset(GrElem.sides), //GRET_SPEEDLINE_POINT
0, //GRET_SPEEDLINE_SPEED
offset(GrElem.linespeed), //GRET_RECT
offset(GrElem.y2), //GRET_CIRCLE
offset(GrElem.x2), //GRET_FLOOD_FILL_NOT
offset(GrElem.x2), //GRET_FLOOD_FILL
offset(GrElem.sides), //GRET_BITMAP4
offset(GrElem.sides), //GRET_BITMAP4_TRANSPARENT
offset(GrElem.st), //GRET_TEXT
offset(GrElem.sides), //GRET_ELLIPSE
sizeof(GrElem), //GRET_REG_POLY
offset(GrElem.linespeed), //GRET_PLANAR_SYMMETRY
1+offset(GrElem.dither_color4), //GRET_DITHER_COLOR4
offset(GrElem.sides), //GRET_ROTATED_RECT
offset(GrElem.x2), //GRET_MESH
offset(GrElem.shiftable_triangle_cnt)+sizeof(I32), //GRET_SHIFTABLE_MESH
offset(GrElem.x1), //GRET_TRANSFORM_ON
offset(GrElem.x1), //GRET_TRANSFORM_OFF
offset(GrElem.linespeed), //GRET_ARROW
offset(GrElem.st), //GRET_TEXT_BOX
offset(GrElem.st), //GRET_TEXT_DIAMOND
};


U64 GrElemSize(GrElem *tempg)
{
  U64 i=gr_elem_base_size[tempg->type];
  switch (tempg->type) {
    case GRET_POLYLINE:
      i+=tempg->num<<1*sizeof(I32);
      break;
    case GRET_TEXT:
    case GRET_TEXT_BOX:
    case GRET_TEXT_DIAMOND:
      i+=StrLen(tempg->st)+1;
      break;
    case GRET_SPEEDLINE:
      i+=tempg->num*(2*sizeof(I32)+sizeof(F64));
      break;
    case GRET_BITMAP4:
    case GRET_BITMAP4_TRANSPARENT:
      i+=((tempg->width+7)&~7)*tempg->height*4/8;
      break;
    case GRET_POLYPOINT:
      i+=sizeof(I32)<<1+(tempg->num*3+7)>>3;
      break;
    case GRET_BSPLINE2:
    case GRET_BSPLINE3:
    case GRET_BSPLINE2_CLOSED:
    case GRET_BSPLINE3_CLOSED:
      i+=tempg->num*sizeof(P3I32);
      break;
    case GRET_MESH:
      i+=tempg->vertex_cnt*sizeof(P3I32)+tempg->triangle_cnt*sizeof(GrMeshTri);
      break;
    case GRET_SHIFTABLE_MESH:
      i+=tempg->shiftable_vertex_cnt*sizeof(P3I32)+tempg->shiftable_triangle_cnt*sizeof(GrMeshTri);
      break;
  }
  return i;
}

public I64 GrElemsSize(U8 *elems)
{
  GrElem *tempg=elems-offset(GrElem.start),*tempg1=tempg;
  while (tempg->type)
    tempg><(U8 *)+=GrElemSize(tempg);
  return tempg><(U8 *)-tempg1><(U8 *)+gr_elem_base_size[GRET_END];
}

I64 GrElemsTypeMask(U8 *elems)
{
  I64 result=0;
  GrElem *tempg=elems-offset(GrElem.start);
  while (tempg->type) {
    Bts(&result,tempg->type);
    tempg><(U8 *)+=GrElemSize(tempg);
  }
  return result;
}

public U8 *GrBitMap2GrElems(GrBitMap *tempb)
{
  GrElem *tempg;
  GrBitMap *tempb1;
  BoolI8 temp_bitmap;
  if (tempb->type!=BMT_COLOR4) {
    tempb1=GrNew(BMT_COLOR4,tempb->width,tempb->height,Fs);
    tempb1->color=WHITE;
    GrBlot(tempb1,0,0,tempb);
    temp_bitmap=TRUE;
  } else {
    tempb1=tempb;
    temp_bitmap=FALSE;
  }
  tempg=CAlloc(gr_elem_base_size[GRET_BITMAP4]+
	      tempb1->width_internal*tempb1->height/2+
	   gr_elem_base_size[GRET_END])
	><(U8 *)-offset(GrElem.start);
  tempg->bkcolor=tempb1->bkcolor;
  if (tempb->color.c0.rop==ROPB_TRANSPARENT)
    tempg->type=GRET_BITMAP4_TRANSPARENT;
  else
    tempg->type=GRET_BITMAP4;
  tempg->width=tempb1->width;
  tempg->height=tempb1->height;
  tempg->x2=0;
  tempg->y2=0;
  MemCpy(tempg><(U8 *)+offset(GrElem.sides),tempb1->body,
    tempb1->width_internal*tempb1->height/2);
  if (temp_bitmap)
    GrDel(tempb1);
  return tempg><(U8 *)+offset(GrElem.start);
}

public U8 *GrElem2Text(GrElem *tempg)
{ //Study [::/LT/Demo/Graphics/GrElem4.CPZ] ::/LT/Demo/Graphics/GrElem4.CPZ.
  U8 buf[256],buf2[256];
  I32 *ptr;
  SPrintF(buf,"%Z",tempg->type,"ST_GRELEM_TYPES");
  *buf2=0;
  switch (tempg->type) {
    case GRET_COLOR4:
      SPrintF(buf2," %Z",tempg->color4&15,"ST_COLORS");
      break;
    case GRET_POINT:
    case GRET_FLOOD_FILL:
    case GRET_FLOOD_FILL_NOT:
    case GRET_SHIFT:
      SPrintF(buf2," %d,%d",tempg->x1,tempg->y1);
      break;
    case GRET_LINE:
    case GRET_ARROW:
    case GRET_PLANAR_SYMMETRY:
    case GRET_RECT:
    case GRET_ROTATED_RECT:
      SPrintF(buf2," (%d,%d)-(%d,%d)",
	  tempg->x1,tempg->y1,tempg->x2,tempg->y2);
      break;
    case GRET_CIRCLE:
      SPrintF(buf2," %d,%d:%dR",
	  tempg->x1,tempg->y1,tempg->x2);
      break;
    case GRET_WIDTH:
      SPrintF(buf2," %d",tempg->width);
      break;
    case GRET_TEXT:
    case GRET_TEXT_BOX:
    case GRET_TEXT_DIAMOND:
      SPrintF(buf2," %d,%d:%16tQ",tempg->x1,tempg->y1,tempg->st);
      break;
    case GRET_DITHER_COLOR4:
      SPrintF(buf2," %Z,%Z",tempg->dither_color4&15,"ST_COLORS",
	  tempg->dither_color4>>4&15,"ST_COLORS");
      break;
    case GRET_POLYLINE:
    case GRET_SPEEDLINE:
    case GRET_POLYPOINT:
      ptr=&tempg->y1;
      SPrintF(buf2," %d %d,%d",tempg->num,ptr[0],ptr[1]);
      break;
    case GRET_ELLIPSE:
    case GRET_REG_POLY:
    case GRET_BITMAP4:
      SPrintF(buf2," %dW,%dH:%d,%d",
	  tempg->width,tempg->height,tempg->x2,tempg->y2);
      break;
    case GRET_BITMAP4_TRANSPARENT:
      SPrintF(buf2," %dW,%dH:%d,%d:%Z",
	  tempg->width,tempg->height,tempg->x2,tempg->y2,
	  tempg->bkcolor&15,"ST_COLORS");
      break;
    case GRET_BSPLINE2:
    case GRET_BSPLINE3:
    case GRET_BSPLINE2_CLOSED:
    case GRET_BSPLINE3_CLOSED:
      SPrintF(buf2," %d",tempg->num);
      break;
    case GRET_MESH:
      SPrintF(buf2," %dV,%dT",tempg->vertex_cnt,tempg->triangle_cnt);
      break;
    case GRET_SHIFTABLE_MESH:
      SPrintF(buf2," %dV,%dT",tempg->shiftable_vertex_cnt,tempg->shiftable_triangle_cnt);
      break;
  }
  StrCat(buf,buf2);
  return StrNew(buf);
}
