If you insist on doing statically compiled, old school, programs instead of  
just-in-time compiled programs, this directory tree has some examples.  The 
main reason to do static programs is to make closed-source applications.  Why 
not do it like the programs in /LT/Apps instead?

See [::/LT/Doc/ImportExports.TXZ] Scoping and Linkages for details on extern,
import, LTextern, LTimport, 
etc.

Demo1 is a quick start making statically compiled programs.  It uses
#include "::/LT/OSMain/StaticAdam.HPZ"
to instantly have all functions, classes, etc. which are currently active in 
the Adam task's sym table declared as externs.  If you think about this, 
you'll see it varies from machine to machine based on what the user has
loaded 
into his Adam Task.
  

Demo2 is the same as Demo1 but uses
#include "::/LT/OSMain/Static.HPZ"
to conventionally compile headers in OSMain.  It requires adding declarations 
for code such as Ltf routines.  There are no headers for Ltf routines, but 
they could be made.


Demo3 shows a multiple file static module.


Demo4 shows a multiple module project.  If you #include the MakeFile you'll 
see a clear example of how syms are exported and imported by modules and
bound 
to syms in task's hash tables.

 
