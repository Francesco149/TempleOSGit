//This is demonstrates symmetry.
//Right-click and draw line of symmetry.
//If the line of symmetry is a point, symmetry is turned-off.

U0 SymmetryDemo()
{
  I64 msg_code,x1,y1,x2,y2,p1,p2,color=BLACK;
  GrBitMap *base=GrAlias(gr_persistent_base,Fs);
  base->color=ROP_XOR+color;

  SettingsPush; //See [C:/LT/Adam/TaskSettings.APZ,3] SettingsPush
  Fs->win_inhibit=WIF_ALL-WIF_BORDER;

  WinMax;
  GrClear;
  PutS("$CL$");
  base->flags|=BMF_SYMMETRY;
  GrSetSymmetry(base,Fs->win_pixel_width/2,0,Fs->win_pixel_width/2,1);
  do {
    msg_code=GetMsg(&p1,&p2,
      1<<MSG_KEY_DOWN+1<<MSG_IP_L_DOWN+
      1<<MSG_IP_R_DOWN);
    switch (msg_code) {
      case MSG_IP_R_DOWN:
	base->flags&=~BMF_SYMMETRY;
	base->color=RED+ROP_XOR;
	x1=p1; y1=p2;
	x2=p1; y2=p2;
	while (msg_code!=MSG_IP_R_UP) {
	  GrLine3(base,x1,y1,0,x2,y2,0);
	  msg_code=GetMsg(&p1,&p2,
  	    1<<MSG_IP_R_UP+1<<MSG_IP_MOVE);
	  GrLine3(base,x1,y1,0,x2,y2,0);
	  x2=p1; y2=p2;
	}
	GrLine3(base,x1,y1,0,x2,y2,0);
	if (GrSetSymmetry3(base,x1,y1,0,x2,y2,0,x2,y2,1))
	  base->flags|=BMF_SYMMETRY;
	base->color=BLACK+ROP_XOR;
	break;
      case MSG_IP_L_DOWN:
	x1=p1; y1=p2;
	x2=p1; y2=p2;
	while (msg_code!=MSG_IP_L_UP) {
	  GrLine3(base,x1,y1,0,x2,y2,0);
	  msg_code=GetMsg(&p1,&p2,
  	    1<<MSG_IP_L_UP+1<<MSG_IP_MOVE);
	  GrLine3(base,x1,y1,0,x2,y2,0);
	  x2=p1; y2=p2;
	}
	GrLine3(base,x1,y1,0,x2,y2,0);
	break;
      case MSG_KEY_DOWN:
	break;
    }
  } while (msg_code!=MSG_KEY_DOWN || !p1);
  GrClear;
  GrDel(base);
  SettingsPop;
}

SymmetryDemo;  //Execute when #included
