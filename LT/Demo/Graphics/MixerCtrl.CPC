/*
There are no stock ctrls at this point.
It's conceptually easy to do a ctrl,
but tedious.  You have complete freedom.

See [C:/LT/OSMain/Adam1a.HPZ,2909] Ctrl.

Create a callback routine to draw it.
Create a callback routine for left, right or wheel clicks.
Create a routine to refresh it's derived vals.
Insert it into the task's ctrls queue.
*/

#define MIXER_SPACING 20
#define MIXER_RANGE   30
#define MIXER_BORDER  2

class MixerState
{
  I64 left_pos,right_pos;
} glbl_state;

U0 DrawMixerCtrl(GrBitMap *base,Ctrl *c)
{
  MixerState *s=c->state;

  base->color=LTRED;
  GrRect(base, c->left,c->top,MIXER_SPACING*3+2,MIXER_SPACING*2+MIXER_RANGE);
  base->color=BLUE;
  GrRect(base, c->left+MIXER_BORDER,c->top+MIXER_BORDER,
    MIXER_SPACING*3+2-2*MIXER_BORDER,MIXER_SPACING*2+MIXER_RANGE-2*MIXER_BORDER);
  base->color=BLACK;
  GrLine(base,c->left+MIXER_SPACING,c->top+MIXER_SPACING,
	      c->left+MIXER_SPACING,c->top+MIXER_SPACING+MIXER_RANGE-1);
  GrLine(base,c->left+2*MIXER_SPACING+1,c->top+MIXER_SPACING,
	      c->left+2*MIXER_SPACING+1,c->top+MIXER_SPACING+MIXER_RANGE-1);

  base->color=LTRED;
  GrPrintF(base,c->left+MIXER_SPACING-FONT_WIDTH/2,
	      c->top+MIXER_SPACING+MIXER_RANGE+3,
    "%d",s->left_pos*10/MIXER_RANGE);
  GrPrintF(base,c->left+2*MIXER_SPACING+1-FONT_WIDTH/2,
	      c->top+MIXER_SPACING+MIXER_RANGE+3,
    "%d",s->right_pos*10/MIXER_RANGE);
  GrRect(base,c->left+MIXER_SPACING-3,	 c->top+MIXER_SPACING+MIXER_RANGE-1-s->left_pos-2 ,7,5);
  GrRect(base,c->left+2*MIXER_SPACING+1-3,c->top+MIXER_SPACING+MIXER_RANGE-1-s->right_pos-2,7,5);
  base->color=YELLOW;
  GrRect(base,c->left+MIXER_SPACING-2,	 c->top+MIXER_SPACING+MIXER_RANGE-1-s->left_pos-1 ,5,3);
  GrRect(base,c->left+2*MIXER_SPACING+1-2,c->top+MIXER_SPACING+MIXER_RANGE-1-s->right_pos-1,5,3);
}

U0 UpdateDerivedMixerCtrl(Ctrl *c)
{
  MixerState *s=c->state;
  c->left=c->win_task->win_pixel_width/2-(MIXER_SPACING*3+2)/2;
  c->right=c->left+MIXER_SPACING*3+2;
  c->top=c->win_task->win_pixel_height/2-(MIXER_SPACING*2+MIXER_RANGE)/2;
  c->bottom=c->top+MIXER_SPACING*2+MIXER_RANGE;
  s->left_pos =LimitI64(s->left_pos,0,MIXER_RANGE-1);
  s->right_pos=LimitI64(s->right_pos,0,MIXER_RANGE-1);
}

U0 LeftClickMixer(Ctrl *c,I64 x,I64 y,BoolI8 down)
{
  nounusedwarn down;
  MixerState *s=c->state;
  if (x<(c->right+c->left)/2)
    s->left_pos=MIXER_RANGE-1-(y-(c->top+MIXER_SPACING));
  else
    s->right_pos=MIXER_RANGE-1-(y-(c->top+MIXER_SPACING));
  if (c->update_derived_vals)
    (*c->update_derived_vals)(c);
}

Ctrl *MixerNew()
{
  BoolI8 old_preempt;
  Ctrl *c=CAlloc(sizeof(Ctrl));
  c->win_task=Fs;
  c->flags=CTRLF_SHOW|CTRLF_CAPTURE_LEFT_IP;
  c->type=CTRLT_GENERIC;
//  c->state=CAlloc(sizeof(MixerState));
  c->state=&glbl_state;
  MemSet(&glbl_state,0,sizeof(glbl_state));
  c->draw_it=&DrawMixerCtrl;
  c->left_click=&LeftClickMixer;
  c->update_derived_vals=&UpdateDerivedMixerCtrl;
  old_preempt=Preempt(OFF);
  InsQue(c,Fs->last_ctrl);
  TaskDerivedValsUpdate;
  Preempt(old_preempt);
  return c;
}

U0 MixerDel(Ctrl *c)
{
  BoolI8 old_preempt=Preempt(OFF);
  RemQue(c);
  Preempt(old_preempt);
//  Free(c->state);
  Free(c);
}

U0 DoIt()
{
  PutS("This is to demo ctrls.  "
	"There is no vol ctrl "
	"for internal PC speakers and "
	"they are mono.\r\n");
  Ctrl *c=MixerNew;
  PressAKey;
  MixerDel(c);
  LtfBottom;
  PrintF("Left: %d  Right: %d\r\n",
    glbl_state.left_pos*10/MIXER_RANGE,
    glbl_state.right_pos*10/MIXER_RANGE);

}

DoIt;
