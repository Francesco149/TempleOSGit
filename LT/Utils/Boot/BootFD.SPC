asm {
#define BOOT_ADDRESS	0x040000
#define BLK_SIZE_BITS		9
#define BLK_SIZE 		(1<<BLK_SIZE_BITS)

#define MODULE_SIZE		1*BLK_SIZE
#define STACK_SIZE		BLK_SIZE
#define BOOT_HIGH_LOC	((0xA0000-(STACK_SIZE+MODULE_SIZE))>>4)

#define BOOT_CODE_FLOPPY	1
#define BOOT_CODE_HARDDRIVE	2
#define BOOT_CODE_CDROM		3
#define BOOT_CODE_RAM		4

	USE16
BFD_START::
	DU1	32 DUP(0);
BFD_CODE::
	CLI
	CLD
	MOV	AX,0xB800
	MOV	FS,AX
	MOV	AX,BOOT_HIGH_LOC
	MOV	SS,AX
	MOV	ES,AX
	MOV	SP,MODULE_SIZE+STACK_SIZE
	STI

	CALL	GET_IP
GET_IP:
	POP	BX
	SUB	BX,GET_IP
	SAR	BX,4
	MOV	AX,CS		//COPY HIGH
	ADD	AX,BX
	MOV	DS,AX
	MOV	CX,MODULE_SIZE
	XOR	SI,SI
	XOR	DI,DI
	REP_MOVSB

	MOV	AX,ES
	MOV	DS,AX

	DU1	0xEA;
	DU2	BFD_HISTART,BOOT_HIGH_LOC;

BFD_HISTART::
	XOR	AX,AX
	XOR	DX,DX
	INT	0x13

BFD_RESTART::
	MOV	CX,512	       //patched with Blk cnt
	MOV	DX,512	       //patched with sector#
	MOV	AX,BOOT_ADDRESS/16
	MOV	GS,AX

BFD_LOOP:
	PUSH	CX

	MOV	AH,0x70
	MOV	AL,CH
	CALL	CVTHEX
	MOV	U2  FS:[0],AX
	MOV	AL,CL
	SHR	AL,4
	CALL	CVTHEX
	MOV	U2  FS:[2],AX
	MOV	AL,CL
	CALL	CVTHEX
	MOV	U2  FS:[4],AX

	MOV	AX,DX
	PUSH	DX
	XOR	DX,DX
	MOV	BX,18
	DIV	BX
	MOV	CL,DL		//CL=sector
	INC	CL
	MOV	DH,AL
	AND	DH,1		//DH=head
	SHR	AX,1
	MOV	CH,AL		//CH=cyl
	XOR	DL,DL		//DL=Drive
	MOV	AX,GS
	MOV	ES,AX
	ADD	AX,BLK_SIZE/16
	PUSH	AX
	XOR	BX,BX		//ES:[BX]=buf
	MOV	AH,2		//AH=read code
	MOV	AL,1		//1 blk
	PUSH	FS
	PUSH	GS

	INT	0x13

	POP	GS
	POP	FS

	POP	GS
	POP	DX
	INC	DX
	POP	CX
	LOOP	BFD_LOOP

	MOV	EBX,BOOT_CODE_FLOPPY
	DU1	0xEA;
	DU2	0,BOOT_ADDRESS/16;

CVTHEX: AND	AL,15
	CMP	AL,9
	JBE	@@1
	ADD	AL,'A'-'9'-1
@@1:	ADD	AL,'0'
	RET
BFD_END::
	END
}