asm {
#define BOOT_ADDRESS	0x040000
#define BLK_SIZE_BITS		9
#define BLK_SIZE 		(1<<BLK_SIZE_BITS)
#define CD_BLK_SIZE 	2048

#define MODULE_SIZE		1*CD_BLK_SIZE
#define STACK_SIZE		BLK_SIZE
#define BOOT_HIGH_LOC	((0xA0000-(STACK_SIZE+MODULE_SIZE))>>4)

#define BOOT_CODE_FLOPPY	1
#define BOOT_CODE_HARDDRIVE	2
#define BOOT_CODE_CDROM		3
#define BOOT_CODE_RAM		4

#define WIN_NOP				0x00
#define WIN_DEV_RESET			0x08
#define WIN_PACKETCMD			0xA0 /* Send a packet cmd. */
#define WIN_READ_NATIVE_MAX		0xF8 /* return the native maximum address */
#define WIN_SET_MAX			0xF9

#define ERR_STAT		0x01
#define DRQ_STAT		0x08
#define SEEK_STAT		0x10
#define READY_STAT		0x40
#define BUSY_STAT		0x80

#define DRIVE_READY		(READY_STAT  | SEEK_STAT)
#define DATA_READY		(DRQ_STAT)

#define IDE_PRIMARY_BASE	0x1F0
#define IDE_SECONDARY_BASE	0x170

#define IDE_DATA_REG	(0)
#define IDE_FEATURE_REG (1)
#define IDE_NSECTOR_REG (2)
#define IDE_SECTOR_REG	(3)
#define IDE_LCYL_REG	(4)
#define IDE_HCYL_REG	(5)
#define IDE_SELECT_REG	(6)
#define IDE_STATUS	(7)
#define IDE_CMD		(7)
#define IDE_CONTROL_REG (0x3F6-0x1F0)

	USE16
BCD_START::
	CLI
	CLD
	MOV	AX,BOOT_HIGH_LOC
	MOV	ES,AX
	MOV	SS,AX
	MOV	SP,STACK_SIZE+MODULE_SIZE

	CALL	U2 GET_IP
GET_IP:
	POP	BX
	SUB	BX,GET_IP
	SHR	BX,4
	MOV	AX,CS		//COPY HIGH
	ADD	AX,BX
	MOV	DS,AX
	MOV	CX,MODULE_SIZE
	XOR	SI,SI
	XOR	DI,DI
	REP_MOVSB

	MOV	AX,SS
	MOV	DS,AX

	DU1	0xEA;
	DU2	BCD_MAIN,BOOT_HIGH_LOC;

BCD_STAT::
	MOV	DX,SI
	ADD	DX,IDE_STATUS
	IN	AL,DX
	RET

BCD_SELECT_UNIT::
	MOV	DX,SI
	ADD	DX,IDE_SELECT_REG
BCD_UNIT_VALUE::
	MOV	AL,0xF0	//Gets patched
	OUT	DX,AL
	RET
BCD_SELECT_CONTROL::
	MOV	AL,8
	MOV	DX,SI
	ADD	DX,IDE_CONTROL_REG
	OUT	DX,AL
	RET
BCD_CMD::
	MOV	AH,AL
	XOR	AL,AL
	MOV	DX,SI
	ADD	DX,IDE_FEATURE_REG
	OUT	DX,AL
	MOV	AL,AH
	MOV	DX,SI
	ADD	DX,IDE_CMD
	OUT	DX,AL
	RET

BCD_PKT::
	PUSH	AX
	PUSH	ECX
	MOV	ECX,5000
@@1:	DEC	ECX
	JZ	@@10
	CALL	BCD_STAT
	AND	AL,DRQ_STAT
	JZ	@@1
@@10:	POP	ECX
	POP	BX
	MOV	AL,BH
	MOV	AH,BL
	MOV	DX,SI
	ADD	DX,IDE_DATA_REG
	OUT	DX,AX
	RET

BCD_WAIT_NOT_BUSY_5mS::
	MOV	ECX,5000
BCD_WAIT_NOT_BUSY::
@@1:	DEC	ECX
	JZ	@@100
	CALL	BCD_STAT
	AND	AL,BUSY_STAT
	JNZ	@@1
	OR	AL,1
@@100:	RET

BCD_START_STOP::
	CALL	BCD_SELECT_CONTROL
	CALL	BCD_SELECT_UNIT
	MOV	AL,WIN_PACKETCMD
	CALL	BCD_CMD
	MOV	AX,0x1B00
	CALL	BCD_PKT
	XOR	AX,AX
	CALL	BCD_PKT
	MOV	AX,0x0100
	CALL	BCD_PKT
	XOR	AX,AX
	CALL	BCD_PKT
	XOR	AX,AX
	CALL	BCD_PKT
	XOR	AX,AX
	CALL	BCD_PKT
	CALL	BCD_WAIT_NOT_BUSY_5mS
	RET

BCD_RESET::
	PUSH	ECX
	CALL	BCD_SELECT_UNIT
	MOV	AL,WIN_DEV_RESET
	CALL	BCD_CMD
	CALL	BCD_WAIT_NOT_BUSY_5mS
	JZ	@@100

	CALL	BCD_SELECT_CONTROL
	CALL	BCD_SELECT_UNIT
	MOV	AL,WIN_READ_NATIVE_MAX
	CALL	BCD_CMD
	CALL	BCD_WAIT_NOT_BUSY_5mS
	JZ	@@100
	MOV	AL,WIN_SET_MAX
	CALL	BCD_CMD
	CALL	BCD_WAIT_NOT_BUSY_5mS
	JZ	@@100

	CALL	BCD_START_STOP
@@100:	POP	ECX
	RET

BCD_ATAPI_WAIT_READY::
	CALL	BCD_WAIT_NOT_BUSY_5mS
	JZ	@@100
	MOV	ECX,300000
@@1:	CALL	BCD_SELECT_UNIT
	MOV	AL,WIN_NOP
	CALL	BCD_CMD
@@2:	DEC	ECX
	JZ	@@100
	CALL	BCD_STAT
	TEST	AL,BUSY_STAT
	JNZ	@@2
	TEST	AL,READY_STAT
	JZ	@@1
	MOV	DX,SI
	ADD	DX,IDE_FEATURE_REG
	IN	AL,DX
	OR	AL,AL
	JNZ	@@1
	OR	AL,1
@@100:	RET

BCD_SEND_READ::
	CALL	BCD_SELECT_CONTROL
	CALL	BCD_SELECT_UNIT
	MOV	AL,0
	MOV	DX,SI
	ADD	DX,IDE_LCYL_REG
	OUT	DX,AL
	MOV	AL,8
	INC	DX	//IDE_HCYL_REG
	OUT	DX,AL
	MOV	AL,WIN_PACKETCMD
	CALL	BCD_CMD
	MOV	AX,0xA800
	CALL	BCD_PKT
BCD_BLK_HI::
	MOV	AX,512
	CALL	BCD_PKT
BCD_BLK_LO::
	MOV	AX,512
	CALL	BCD_PKT
	XOR	AX,AX	//cnt_hi
	CALL	BCD_PKT
BCD_BLK_CNT::
	MOV	AX,512
	PUSH	AX
	CALL	BCD_PKT
	XOR	EAX,EAX
	CALL	BCD_PKT
	POP	AX	//cnt
	SHL	EAX,10
	MOV	EBX,EAX

	MOV	ECX,300000

@@10:	DEC	ECX
	JZ	@@100
	CALL	BCD_STAT
	TEST	AL,DRQ_STAT
	JZ	@@10
	MOV	DX,SI
	ADD	DX,IDE_HCYL_REG
	IN	AL,DX
	OR	AL,AL
	JNZ	@@100
	MOV	DX,SI
	ADD	DX,IDE_LCYL_REG
	IN	AL,DX
	OR	AL,AL
	JZ	@@10
@@100:	RET

BCD_SCAN_ONE::
	CALL	BCD_RESET
	JZ	@@100
	CALL	BCD_ATAPI_WAIT_READY
//	JZ	@@100
	MOV	DX,SI
	ADD	DX,IDE_STATUS
@@11:	IN	AL,DX
	AND	AL,DATA_READY
	JNZ	@@11
	CALL	BCD_SEND_READ
@@100:	RET

BCD_MAIN::
	MOV	AX,0xB800
	MOV	ES,AX
	MOV	U4 ES:[4],0

	MOV	U4 ES:[0],('S'+0x2000)+('0'+0x2000)<<16
	MOV	SI,IDE_SECONDARY_BASE
	MOV	U1 [BCD_UNIT_VALUE+1],0xE0
	CALL	BCD_SCAN_ONE
	JNZ	BCD_READ

	MOV	U4 ES:[0],('S'+0x2000)+('1'+0x2000)<<16
	MOV	SI,IDE_SECONDARY_BASE
	MOV	U1 [BCD_UNIT_VALUE+1],0xF0
	CALL	BCD_SCAN_ONE
	JNZ	BCD_READ

	MOV	U4 ES:[0],('P'+0x1000)+('1'+0x1000)<<16
	MOV	SI,IDE_PRIMARY_BASE
	MOV	U1 [BCD_UNIT_VALUE+1],0xF0
	CALL	BCD_SCAN_ONE
	JNZ	BCD_READ

	MOV	U4 ES:[0],('P'+0x1000)+('0'+0x1000)<<16
	MOV	SI,IDE_PRIMARY_BASE
	MOV	U1 [BCD_UNIT_VALUE+1],0xE0
	CALL	BCD_SCAN_ONE
	JNZ	BCD_READ
	JMP	U2 BCD_MAIN

BCD_READ::
	MOV	AX,BOOT_ADDRESS/16
	MOV	ES,AX
	XOR	DI,DI		//ES:[DI]=DEST
	JMP	@@15

@@10:	CALL	BCD_STAT
	AND	AL,DRQ_STAT
	JZ	@@10

@@15:	XOR	ECX,ECX
	MOV	DX,SI
	ADD	DX,IDE_HCYL_REG
	IN	AL,DX
	MOV	CH,AL
	MOV	DX,SI
	ADD	DX,IDE_LCYL_REG
	IN	AL,DX
	MOV	CL,AL
	SHR1	CX
	JZ	@@10
	CMP	CX,0x7F00
	JB	@@20
	MOV	CX,0x7F00
@@20:	PUSH	CX
	MOV	DX,SI
	ADD	DX,IDE_DATA_REG
	REP_INSW

	MOV	AX,DI
	SHR	AX,4
	MOV	DX,AX
	MOV	AX,ES
	ADD	AX,DX
	MOV	ES,AX
	AND	DI,0xF

	POP	CX
	SUB	EBX,ECX
	JA	@@10

@@100:	MOV	ECX,5000000
	CALL	BCD_WAIT_NOT_BUSY

	MOV	AX,SI
	SHL	EAX,16
	MOV	AH,U1 [BCD_UNIT_VALUE+1]
	MOV	AL,BOOT_CODE_CDROM
	MOV	EBX,EAX

	DU1	0xEA;
BCD_JMP_START::
	DU2	0,BOOT_ADDRESS/16;
//Continues here [::/LT/OSMain/OSStartUp.ASZ,1] ::/LT/OSMain/OSStartUp.ASZ
BCD_END::
	END
}