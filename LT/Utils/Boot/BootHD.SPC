asm {
#define BOOT_ADDRESS	0x040000
#define BLK_SIZE_BITS		9
#define BLK_SIZE 		(1<<BLK_SIZE_BITS)

#define MODULE_SIZE		1*BLK_SIZE
#define STACK_SIZE		BLK_SIZE
#define BOOT_HIGH_LOC	((0xA0000-(STACK_SIZE+MODULE_SIZE))>>4)

#define BOOT_CODE_FLOPPY	1
#define BOOT_CODE_HARDDRIVE	2
#define BOOT_CODE_CDROM		3
#define BOOT_CODE_RAM		4

#define WIN_MULTREAD		0xC4 /* read sectors using multiple mode*/
#define WIN_DEV_RESET		0x08
#define WIN_READ_NATIVE_MAX	0xF8
#define WIN_SET_MAX		0xF9

#define ERR_STAT		0x01
#define INDEX_STAT		0x02
#define ECC_STAT		0x04	/* Corrected error */
#define DRQ_STAT		0x08
#define SEEK_STAT		0x10
#define WRERR_STAT		0x20
#define READY_STAT		0x40
#define BUSY_STAT		0x80

#define BAD_R_STAT		(BUSY_STAT   | ERR_STAT)
#define BAD_W_STAT		(BAD_R_STAT  | WRERR_STAT)
#define BAD_STAT		(BAD_R_STAT  | DRQ_STAT)
#define DRIVE_READY		(READY_STAT  | SEEK_STAT)
#define DATA_READY		(DRQ_STAT)

#define IDE_DATA_REG	0
#define IDE_FEATURE_REG 1
#define IDE_NSECTOR_REG 2
#define IDE_SECTOR_REG	3
#define IDE_LCYL_REG	4
#define IDE_HCYL_REG	5
#define IDE_SELECT_REG	6
#define IDE_STATUS	7
#define IDE_CMD		7
#define IDE_CONTROL_REG 0


	USE16
BHD_START::
	DU1	32 DUP(0);
BHD_CODE::
	CLI
	CLD

	MOV	AX,0xB800 //This is text video mem address
	MOV	FS,AX
	MOV	U4 FS:[4],0
	MOV	U4 FS:[0],('B'+0x2000)+('3'+0x2000)<<16

	MOV	AX,BOOT_HIGH_LOC
	MOV	SS,AX
	MOV	ES,AX
	MOV	SP,STACK_SIZE+MODULE_SIZE
	CALL	U2 GET_IP
GET_IP:
	POP	BX
	SUB	BX,GET_IP
	SHR	BX,4
	MOV	AX,CS		//COPY HIGH
	ADD	AX,BX
	MOV	DS,AX
	MOV	CX,MODULE_SIZE
	XOR	SI,SI
	XOR	DI,DI
	REP_MOVSB

	MOV	AX,ES
	MOV	DS,AX

	DU1	0xEA;
	DU2	BHD_HISTART,BOOT_HIGH_LOC;

BHD_WAIT_BUSY:
	MOV	DX,U2 [BHD_BASE0]
	ADD	DX,IDE_STATUS
	IN	AL,DX
	AND	AL,BUSY_STAT
	JNZ	BHD_WAIT_BUSY
	RET

BHD_ATA_CMD:
	PUSH	AX
	MOV	DX,U2 [BHD_BASE0]
	ADD	DX,IDE_FEATURE_REG
	XOR	AL,AL
	OUT	DX,AL
	POP	AX
	ADD	DX,IDE_CMD-IDE_FEATURE_REG
	OUT	DX,AL
	RET

BHD_BASE0::	DU2	0x1F0;
BHD_BASE1::	DU2	0x3F6;
BHD_UNIT::	DU1	0xE0;
BHD_BLK::	DU4	0;

BHD_HISTART:
//Init Drive
	MOV	DX,U2 [BHD_BASE0]
	ADD	DX,IDE_SELECT_REG
	MOV	AL,U1 [BHD_UNIT]
	OUT	DX,AL
	MOV	AL,WIN_DEV_RESET
	CALL	BHD_ATA_CMD
	CALL	BHD_WAIT_BUSY

	MOV	AL,WIN_READ_NATIVE_MAX
	CALL	BHD_ATA_CMD
	CALL	BHD_WAIT_BUSY

	MOV	AL,WIN_SET_MAX
	CALL	BHD_ATA_CMD
	CALL	BHD_WAIT_BUSY

BHD_RESTART::
	MOV	CX,512	       //Gets patched
	MOV	AX,BOOT_ADDRESS/16
	MOV	ES,AX

@@1:	MOV	DX,U2 [BHD_BASE0]
	ADD	DX,IDE_STATUS
@@11:	IN	AL,DX
	AND	AL,DATA_READY
	JNZ	@@11

	XOR	DI,DI
	PUSH	CX

//READ BLK
	MOV	DX,U2 [BHD_BASE1]
	ADD	DX,IDE_CONTROL_REG
	MOV	AL,8
	OUT	DX,AL
	MOV	DX,U2 [BHD_BASE0]
	ADD	DX,IDE_SECTOR_REG
	MOV	AL,U1 [BHD_BLK]
	OUT	DX,AL
	ADD	DX,IDE_NSECTOR_REG-IDE_SECTOR_REG
	MOV	AL,1	//Blk Cnt
	OUT	DX,AL
	ADD	DX,IDE_LCYL_REG-IDE_NSECTOR_REG
	MOV	AL,U1 [BHD_BLK+1]
	OUT	DX,AL
	ADD	DX,IDE_HCYL_REG-IDE_LCYL_REG
	MOV	AL,U1 [BHD_BLK+2]
	OUT	DX,AL
	ADD	DX,IDE_SELECT_REG-IDE_HCYL_REG
	MOV	AL,U1 [BHD_BLK+3]
	OR	AL,U1 [BHD_UNIT]
	OUT	DX,AL
	MOV	AL,WIN_MULTREAD
	CALL	BHD_ATA_CMD

	MOV	DX,U2 [BHD_BASE0]
	ADD	DX,IDE_STATUS
@@10:	IN	AL,DX
	AND	AL,DATA_READY
	JZ	@@10
	MOV	CX,BLK_SIZE/2
	ADD	DX,IDE_DATA_REG-IDE_STATUS
	REP_INSW
	CALL	BHD_WAIT_BUSY

	POP	CX
	INC	U4 [BHD_BLK]
	MOV	AX,ES
	ADD	AX,BLK_SIZE/16
	MOV	ES,AX
	DEC	CX
	JNZ	U2 @@1

	MOV	EBX,BOOT_CODE_HARDDRIVE
	DU1	0xEA;
	DU2	0,BOOT_ADDRESS/16;
//Continues here [::/LT/OSMain/OSStartUp.ASZ,1] ::/LT/OSMain/OSStartUp.ASZ
BHD_END::
	END
}