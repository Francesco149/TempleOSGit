//This only boots to primary IDE, unit 0
asm {
#define BLK_SIZE_BITS		9
#define BLK_SIZE 		(1<<BLK_SIZE_BITS)

#define MODULE_SIZE		2*BLK_SIZE
#define STACK_SIZE		BLK_SIZE
#define BOOT_HIGH_LOC	((0xA0000-(STACK_SIZE+MODULE_SIZE))>>4)

#define WIN_MULTREAD		0xC4 /* read sectors using multiple mode*/

#define ERR_STAT		0x01
#define INDEX_STAT		0x02
#define ECC_STAT		0x04	/* Corrected error */
#define DRQ_STAT		0x08
#define SEEK_STAT		0x10
#define WRERR_STAT		0x20
#define READY_STAT		0x40
#define BUSY_STAT		0x80

#define BAD_R_STAT		(BUSY_STAT   | ERR_STAT)
#define BAD_W_STAT		(BAD_R_STAT  | WRERR_STAT)
#define BAD_STAT		(BAD_R_STAT  | DRQ_STAT)
#define DRIVE_READY		(READY_STAT  | SEEK_STAT)
#define DATA_READY		(DRQ_STAT)

#define IDE_DATA_REG	0
#define IDE_FEATURE_REG 1
#define IDE_NSECTOR_REG 2
#define IDE_SECTOR_REG	3
#define IDE_LCYL_REG	4
#define IDE_HCYL_REG	5
#define IDE_SELECT_REG	6
#define IDE_STATUS	7
#define IDE_CMD		7
#define IDE_CONTROL_REG 0

	USE16
BMHD2_START::
	MOV	U4 FS:[0],('B'+0x2000)+('2'+0x2000)<<16

	MOV	AX,BOOT_HIGH_LOC
	MOV	SS,AX
	MOV	ES,AX
	MOV	SP,STACK_SIZE+MODULE_SIZE
	MOV	AX,CS		//COPY HIGH
	MOV	DS,AX
	MOV	U4 [BMHD2_OLD_CS_IP],EBX

	MOV	CX,MODULE_SIZE
	XOR	SI,SI
	XOR	DI,DI
	REP_MOVSB

	MOV	AX,ES
	MOV	DS,AX

	DU1	0xEA;
	DU2	BMHD2_HISTART,BOOT_HIGH_LOC;

BMHD2_PUTS:
	LODSB
	OR	AL,AL
	JZ	BMHD2_RET
	MOV	AH,0x0E
	MOV	BX,0x07
	INT	0x10
	JMP	BMHD2_PUTS

BMHD2_GETCHAR:
	XOR	AH,AH
	INT	0x16
	PUSH	AX
	MOV	AH,0x0E
	MOV	BX,0x07
	INT	0x10
	POP	AX
BMHD2_RET:
	RET

BMHD2_WAIT_BUSY:
	MOV	DX,U2 [BMHD2_BASE0]
	ADD	DX,IDE_STATUS
	IN	AL,DX
	AND	AL,BUSY_STAT
	JNZ	BMHD2_WAIT_BUSY
	RET

BMHD2_ATA_CMD:
	PUSH	AX
	MOV	DX,U2 [BMHD2_BASE0]
	ADD	DX,IDE_FEATURE_REG
	XOR	AL,AL
	OUT	DX,AL
	POP	AX
	ADD	DX,IDE_CMD-IDE_FEATURE_REG
	OUT	DX,AL
	RET

BMHD2_BOOT_MSG::
	DU1	256 DUP(0);

BMHD2_BASE0::	DU2	0x1F0;
BMHD2_BASE1::	DU2	0x3F6;
BMHD2_UNIT::	DU1	0xE0;

BMHD2_BLK::	DU4	0;

BMHD2_BLK_ARRAY:: DU4 8 DUP(0);

BMHD2_HISTART:
	IN	AL,0x21
	PUSH	AX
	IN	AL,0xA1
	PUSH	AX

	MOV	AL,0xFD
	OUT	0x21,AL	//mask all but keyboard
	MOV	AL,0xFF
	OUT	0xA1,AL
	STI

	MOV	U4 FS:[0],0
	MOV	SI,BMHD2_BOOT_MSG
	CALL	BMHD2_PUTS
	CALL	BMHD2_GETCHAR
	AND	EAX,7
	MOV	EAX,U4 BMHD2_BLK_ARRAY[EAX*4]
	MOV	U4 [BMHD2_BLK],EAX

	CLI
	MOV	AX,U2 [BMHD2_OLD_CS_IP]
	SHR	AX,4
	ADD	AX,U2 [BMHD2_OLD_CS_IP+2]
	MOV	ES,AX

@@1:	MOV	DX,U2 [BMHD2_BASE0]
	ADD	DX,IDE_STATUS
@@11:	IN	AL,DX
	AND	AL,DATA_READY
	JNZ	@@11

	XOR	DI,DI

//READ BLK
	MOV	DX,U2 [BMHD2_BASE1]
	ADD	DX,IDE_CONTROL_REG
	MOV	AL,8
	OUT	DX,AL
	MOV	DX,U2 [BMHD2_BASE0]
	ADD	DX,IDE_SECTOR_REG
	MOV	AL,U1 [BMHD2_BLK]
	OUT	DX,AL
	ADD	DX,IDE_NSECTOR_REG-IDE_SECTOR_REG
	MOV	AL,1	//Blk Cnt
	OUT	DX,AL
	ADD	DX,IDE_LCYL_REG-IDE_NSECTOR_REG
	MOV	AL,U1 [BMHD2_BLK+1]
	OUT	DX,AL
	ADD	DX,IDE_HCYL_REG-IDE_LCYL_REG
	MOV	AL,U1 [BMHD2_BLK+2]
	OUT	DX,AL
	ADD	DX,IDE_SELECT_REG-IDE_HCYL_REG
	MOV	AL,U1 [BMHD2_BLK+3]
	OR	AL,U1 [BMHD2_UNIT]
	OUT	DX,AL
	MOV	AL,WIN_MULTREAD
	CALL	BMHD2_ATA_CMD

	MOV	DX,U2 [BMHD2_BASE0]
	ADD	DX,IDE_STATUS
@@10:	IN	AL,DX
	AND	AL,DATA_READY
	JZ	@@10
	MOV	CX,BLK_SIZE/2
	ADD	DX,IDE_DATA_REG-IDE_STATUS
	REP_INSW
	CALL	BMHD2_WAIT_BUSY

	MOV	AL,0x20
	MOV	CX,16
@@20:	OUT	0xA0,AL
	OUT	0x20,AL
	LOOP	@@20

	POP	AX
	OUT	0xA1,AL
	POP	AX
	OUT	0x21,AL
	STI

	DU1	0xEA;
BMHD2_OLD_CS_IP:
	DU2	0,0;
BMHD2_END::
//Continues here [::/LT/Utils/Boot/BootHD.SPZ,START] ::/LT/Utils/Boot/BootHD.SPZ

	END
}
