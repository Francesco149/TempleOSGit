/*
In this file, symbols defined OSMain assembly
files are given C+ definitions.  This file
is included when you compile the kernel, after
the assembly files have been assembled, making
the C+ definitions available for the C+ OSMain
files.	It is also included as part of booting.

The assembly global labels are stored as HTT_SYS_SYMBOL
entries in the hash table.  These symols are placed
into the OSMain binary module and added to the
symbol hash table at boot before this file
gets #included during boot.

See
[::/LT/OSMain/OS.SPZ,AdamK2] AdamK2 for where it is included during compiling the kernel.
[::/LT/OSMain/AdamK.APZ,AdamK2] AdamK2 for where it is included during boots.
[::/LT/OSMain/OSEnd.CPZ,AddOsMapSymbols] AddOsMapSymbols for where the OSMain symbols are added to the hash tables.
 
*/

#define EC_FS			0x011
#define EC_GS			0x012

#define EC_CLI	 		0x046
#define EC_STI	 		0x047
#define EC_DISABLE_CACHE	0x048
#define EC_ENABLE_CACHE		0x049
#define EC_WBINVD		0x04A
#define EC_INVD			0x04B

#define EC_GET_FLAGS		0x04C
#define EC_SET_FLAGS		0x04D
#define EC_GET_BASE_PTR		0x04E
#define EC_SET_BASE_PTR		0x04F
#define EC_GET_STACK_PTR	0x050
#define EC_SET_STACK_PTR	0x051
#define EC_SET_RAX		0x052

#define EC_BT			0x053
#define EC_BTS	 		0x054
#define EC_BTR	 		0x055
#define EC_BTC	 		0x056
#define EC_BSF			0x057
#define EC_BSR			0x058
#define EC_INSQUE		0x059
#define EC_INSQUE_REV		0x05A
#define EC_REMQUE		0x05B
#define EC_STRLEN		0x05C
#define EC_MEMCPY		0x05D
#define EC_MEMSET		0x05E
#define EC_INPD			0x05F
#define EC_INPW			0x060
#define EC_INP	 		0x061
#define EC_OUTPD		0x062
#define EC_OUTPW		0x063
#define EC_OUTP			0x064
#define EC_RDTSC		0x065
#define EC_LBTS	 		0x081
#define EC_LBTR	 		0x082
#define EC_LBTC	 		0x083
#define EC_ABSI8		0x090
#define EC_PREEMPT		0x092

#help_index "Misc"
public LTextern SYS_FLAGS U8 sys_flags[1];
public LTextern SYS_BOOT_BASE U4 sys_boot_base;
LTextern SYS_BOOT_CODE U4 sys_boot_code;
public LTextern SYS_BOOT_HEADER_BASE U4 sys_boot_header_base;
LTextern SYS_CUR_FOCUS_TASK TssStruct *sys_cur_focus_task;
LTextern SYS_CUR_SCAN_CODE U8 sys_cur_scan_code;
public LTextern SYS_PROGRESS1 U8 progress1;
public LTextern SYS_PROGRESS2 U8 progress2;
public LTextern SYS_PROGRESS3 U8 progress3;
public LTextern SYS_PROGRESS4 U8 progress4;

#help_index "Graphics"
LTextern SYS_TEXTBASE	U4 *textbase;

#help_index "Bit"
#help_file "::/LT/Doc/Bit.TXZ"
public LTintern EC_BT BoolU8 Bt(void *bit_field,U8 bit);
public LTintern EC_BTS BoolU8 Bts(void *bit_field,U8 bit);
public LTintern EC_BTR BoolU8 Btr(void *bit_field,U8 bit);
public LTintern EC_BTC BoolU8 Btc(void *bit_field,U8 bit);

//Locked for (for multitple CPU's)
public LTintern EC_LBTS BoolU8 LBts(void *bit_field,U8 bit);
public LTintern EC_LBTR BoolU8 LBtr(void *bit_field,U8 bit);
public LTintern EC_LBTC BoolU8 LBtc(void *bit_field,U8 bit);

//Scan U8 sized item forward for first set bit.
//Return -1 if not found.
public LTintern EC_BSF I8 Bsf(U8 bit_field_value);

//Scan U8 sized item reverse for first set bit.
//Return -1 if not found.
public LTintern EC_BSR I8 Bsr(U8 bit_field_value);

public LTextern OR_U4_BIT_FIELD void OrU4BitField(
	 void *bit_field,U8 bit,U4 pattern);
public LTextern EXTRACT_U4_BIT_FIELD U4 ExtractU4BitField(
	 void *bit_field,U8 bit,U8 size);

#help_index "Circular Queue"
#help_file "::/LT/Doc/Queue.TXZ"

//Insert item into queue after predicessor.
public LTintern EC_INSQUE void InsQue(void *entry,void *pred);

//Reversed insert into queue.  Insert
//item into queue before successor.
public LTintern EC_INSQUE_REV void InsQueRev(void *entry,void *succ);

//Remove item from queue.
public LTintern EC_REMQUE void RemQue(void *entry);

#help_index "Task"
public LTintern EC_PREEMPT BoolU8 Preempt(BoolU4 val);

#help_index "Processor/IO Port"
public LTintern EC_INP U1 InP(U8 port);
public LTintern EC_OUTP void OutP(U8 port, U8 val);
public LTintern EC_INPW U8 InPW(U8 port);
public LTintern EC_OUTPW void OutPW(U8 port, U8 val);
public LTintern EC_INPD U8 InPD(U8 port);
public LTintern EC_OUTPD void OutPD(U8 port, U8 val);
public LTextern CP_REP_INSB void RepInSB(void *buf,U8 cnt,U8 port);
public LTextern CP_REP_INSW void RepInSW(void *buf,U8 cnt,U8 port);
public LTextern CP_REP_OUTSB void RepOutSB(void *buf,U8 cnt,U8 port);
public LTextern CP_REP_OUTSW void RepOutSW(void *buf,U8 cnt,U8 port);

#help_index "Memory"
public LTintern EC_MEMCPY void MemCpy(void *dst,void *src,U8 cnt);
public LTintern EC_MEMSET void MemSet(void *dst,U8 val,U8 cnt);
LTextern SYS_MEM_FREE_LIST MemBlk *mem_free_list;
LTextern SYS_MEM_FREE_2MEG_LIST MemBlk *mem_free_2Meg_list;
LTextern SYS_FREE_PAGE_HASH MemBlk *free_page_hash[FREE_PAGE_HASH_SIZE];
LTextern SYS_FREE_PAGE_HASH2 MemBlk *free_page_hash2[64];
public LTextern SYS_HEAP_BASE U4 sys_heap_base;
public LTextern SYS_HEAP_LIMIT U4 sys_heap_limit;

#help_index "Char/Operations"
public LTintern EC_STRLEN U8 StrLen(I1 *st);
public LTextern CP_STRCMP I8 StrCmp(I1 *st1,I1 *st2);
public LTextern CP_STRICMP I8 StrICmp(I1 *st1,I1 *st2);
public LTextern CP_STRNCMP I8 StrNCmp(I1 *st1,I1 *st2,U8 n);
public LTextern CP_STRNICMP I8 StrNICmp(I1 *st1,I1 *st2,U8 n);
public LTextern CP_STRSTR I1 *StrStr(I1 *st,I1 *pattern);
public LTextern CP_STRISTR I1 *StrIStr(I1 *st,I1 *pattern);
public LTextern CP_STRCPY void StrCpy(I1 *dest,I1 *src);
public LTextern CP_STRCAT void StrCat(I1 *dest,I1 *src);

#help_index "Processor"
public LTextern CP_CPUID void CpuId(U4 rax,RaxRbxRcxRdx *result);
public LTextern CP_GETCR0 U8 GetCR0();
public LTextern CP_SETCR0 void SetCR0(U8 d);
public LTextern CP_LTR void SetTR(U8 d);
public LTextern CP_GETCR3 U8 GetCR3();
public LTextern CP_SETCR3 void SetCR3(U8 d);
public LTextern CP_GETCR4 U8 GetCR4();
public LTextern CP_SETCR4 void SetCR4(U8 d);
LTextern IRQ_VECTORS U4 sys_irq_vectors[MAXIDT]; //changing these will not change interrupts
public LTintern EC_CLI void Cli();
public LTintern EC_STI void Sti();
public LTintern EC_GET_FLAGS U8 GetFlags();
public LTintern EC_SET_FLAGS void SetFlags(U8 d);
public LTintern EC_GET_STACK_PTR void *GetStackPtr();
public LTintern EC_SET_STACK_PTR void SetStackPtr(void *d);
public LTintern EC_GET_BASE_PTR void *GetBasePtr();
public LTintern EC_SET_BASE_PTR void SetBasePtr(U8 d);
LTextern SYS_SEMA_IRQS	sema sema_irqs[NUM_IRQ_SEMAS];
LTextern SYS_SEMA_IRQ_BUSY	sema sema_irq_busy[NUM_IRQ_SEMAS];
LTextern SYS_FREE_GDT_LIST U4 free_gdt_list;
LTextern SYS_GDTTAB GdtTabStruct gdttab[MAXGDT];
#help_index "Processor;MultiCore;Boot"
public LTextern CP_HLT void Hlt();

#help_index "Processor/Cache;Memory/Cache;MultiCore/Cache"
//Invalidate cache
public LTintern EC_INVD void Invd();
//Write back and invalidate cache.
public LTintern EC_WBINVD void WbInvd();
public LTintern EC_DISABLE_CACHE void DisableCache();
public LTintern EC_ENABLE_CACHE void EnableCache();
//Flush cache line.
public LTextern CP_CLFLUSH void ClFlush(U1 *b);

#help_index "MultiCore"
#help_file "::/LT/Doc/MultiCore.TXZ"
LTextern CP_PUT_GS_BASE void SetGs(CPUStruct *c);
LTextern SYS_UNCACHED_MP_CNT U8 *uncached_mp_cnt;
public LTextern SYS_MP_CNT U8 mp_cnt;
LTextern SYS_TEMP_CPU0_STRUCT CPUStruct sys_temp_cpu0_struct;
public LTextern SYS_MP_CPU_STRUCTS CPUStruct *mp_cpu_structs;
LTextern RESTORE_CONTEXT void RestoreContext();
public LTintern EC_GS CPUStruct *Gs();
LTextern SYS_SEMAS sema sys_semas[NUM_SYS_SEMAS];

#help_index "Time/CPU Cycles"
public LTintern EC_RDTSC U8 GetTimeStamp();
#help_index "Time/Jiffies;Task"
LTextern SYS_TIMER U8 sys_timer;
LTextern SYS_JIFFIES U8 sys_jiffies;

#help_index "Math"
public LTintern EC_ABSI8 I8 AbsI8(I8 i);
public LTextern CP_FSQRT double Sqrt(double d);
public LTextern CP_FSIN double Sin(double d);
public LTextern CP_FCOS double Cos(double d);
public LTextern CP_FTAN double Tan(double d);
public LTextern CP_ARG double Arg(double x,double y);
public LTextern CP_FATAN double ATan(double d);
public LTextern CP_ROUND double Round(double d);
public LTextern CP_TRUNC double Trunc(double d);
public LTextern CP_FLOOR double Floor(double d);
public LTextern CP_CEILING double Ceiling(double d);
public LTextern CP_POW10 double Pow10(double d);
public LTextern CP_LOG2 double Log2(double d);
public LTextern CP_LOG10 double Log10(double d);
public LTextern CP_LN double Ln(double d);
public LTextern CP_EXP double Exp(double d);
LTextern CP_FLDCW void Fldcw(U2 w);
LTextern CP_FCLEX void Fclex();
LTextern CP_FSTCW U2 Fstcw();
LTextern CP_FSTSW U2 Fstsw();
public LTextern FC_1 double one;
public LTextern FC_PI double pi;
public LTextern FC_PI2 double pi2;
public LTextern FC_E double e;	//not implemented
public LTextern FC_LOG2_10 double log2_10;
public LTextern FC_LOG2_E double log2_E;
public LTextern FC_LOG10_2 double log10_2;
public LTextern FC_LOGE_2 double logE_2;

#help_index "Task"
public LTextern SWAP_IN_NEXT void SwapInNext();
public LTextern CP_DEACTIVATE_USER TssStruct *DeactivateUser();
public LTextern CP_ACTIVATE_NEXT_USER void ActivateNextUser();
public LTintern EC_FS TssStruct *Fs();

#help_index "Hash"
#help_file "::/LT/Doc/Hash.TXZ"
public LTextern CP_HASH_STR U8 HashStr(I1 *st);
public LTextern CP_FIND_HASH_ENTRY SysHashEntry *
  FindHashEntry(I1 *st,SysHashTable *table,U8 mask);
public LTextern CP_FIND_HASH_BUCKET SysHashEntry **
  FindHashBucket(I1 *st,SysHashTable *table);
public LTextern CP_ADD_SYS_HASH_ENTRY void AddSysHashEntry(SysHashEntry *temph,SysHashTable *table);
public LTextern CP_FIND_EXTERN void *FindExtern(I1 *st);

#help_index "Char/Output"
public LTextern CRLF void CrLf();
#help_index "Char/BitMaps"
public LTextern SYS_ALPHA_BITMAP U1 alpha_bitmap[1];
public LTextern SYS_ALPHA_NUMERIC_BITMAP U1 alpha_numeric_bitmap[1];
public LTextern SYS_DEC_NUMERIC_BITMAP U1 dec_numeric_bitmap[1];
public LTextern SYS_HEX_NUMERIC_BITMAP U1 hex_numeric_bitmap[1];
public LTextern SYS_PRINTABLE_CHARS_BITMAP U1 printable_chars_bitmap[1];
public LTextern SYS_SAFE_DOLLAR_CHARS_BITMAP U1 safe_dollar_chars_bitmap[1];
public LTextern SYS_FILENAME_CHARS_BITMAP U1 filename_chars_bitmap[1];
public LTextern SYS_DISPLAYABLE_CHARS_BITMAP U1 displayable_chars_bitmap[1];

#help_index "Compression"
LTextern CP_ARC_DETERMINE_COMPRESSION_TYPE
	I8 ArcDetermineCompressionType(void *src,U8 size);

//This is just an XOR checksum.
LTextern CP_ARC_CHECK_SUM U8 ArcCheckSum(U1 *buf,U8 size);

LTextern CP_ARC_GET_TABLE_ENTRY
	void ArcGetTableEntry(ArcCs *c);

#help_index "Call"
public LTextern CP_CALL U8 Call(void *s);
public LTextern CP_INDCALL void CallInd(void *fun_add,...);

//This is just an array of pointers
//to functions.
//See [C:/LT/OSMain/Adam1a.HPZ,499] Extern Number Definitions
public LTextern SYS_EXTERN_TABLE void **ext;
public LTextern CP_CALLEXTNUM void CallExtNum(U8 num,...);

//Search symbol table for function name
//and pass it parameters
public LTextern CP_CALLEXTSTR void CallExtStr(I1 *name,...);


#help_index ""

