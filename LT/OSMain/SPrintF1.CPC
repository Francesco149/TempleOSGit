I1 *SPrintFJoin(I1 *dst,I1 *fmt,I8 argc,I8 *argv)
{
  if (ext[EXT_SPRINTF_JOIN])
    return CallExtNum(EXT_SPRINTF_JOIN,dst,fmt,argc,argv);
  else {
    coutln fmt,"ERROR: SPrintF not Loaded.";
    return NULL;
  }
}

void GetFJoin(I1 *src,I1 *fmt,I8 argc,I8 *argv)
{
  if (ext[EXT_GETF_JOIN])
    CallExtNum(EXT_GETF_JOIN,src,fmt,argc,argv);
  else {
    cout fmt;
    PutErr;
    coutln "GetF not Loaded.";
  }
}



void SPrintF(I1 *dst,I1 *fmt,...)
{
  SPrintFJoin(dst,fmt,argc,argv);
}

void GetF(I1 *src,I1 *fmt,...)
//Pass pointer to data,
//For %s pass pointer to pointer (be careful because address
//  of array is the same as array--create ptr to array and take address
{
  GetFJoin(src,fmt,argc,argv);
}


void PrintF(I1 *fmt,...)
{[::/LT/Doc/Differences.TXZ,PrintF_Codes] printF codes
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  PutS(buf);
  Free(buf);
}

asm {CP_PUT_FLOAT:}
void PutFloat(double d)
{
  PrintF("%15e",d);
}


I1 *MSPrintF(I1 *fmt,...)
{
  I1 *result,*buf=SPrintFJoin(NULL,fmt,argc,argv);
  result=NewStr(buf);
  Free(buf);
  return result;
}

void PrintFErr(I1 *fmt,...)
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  PutErr;
  PutS(buf);
  Free(buf);
}

void PrintFWarn(I1 *fmt,...)
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  PutWarn;
  PutS(buf);
  Free(buf);
}

U8 Adam(I1 *fmt,...)
//Sends text to the adam task which gets
//compiled and run.
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  U8 result;
  BoolU4 old_preempt=Preempt(OFF);
  TssCmdStruct *tempc;
  WaitTskIdle(adam_tss);
  tempc=QueueTaskRequest(adam_tss,Fs,buf,
    (1<<TSSCf_WAKE_MASTER));
  Preempt(old_preempt);
  GetRequestResult(tempc,&result);
  Free(buf);
  return result;
}

void AdamLog(I1 *fmt,...)
//Sends text to the adam task which gets
//displayed.
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  if (Fs!=adam_tss)
    Adam("PutS(\"%Q\");",buf);
  else
    PutS(buf);
  Free(buf);
}

void AdamErr(I1 *fmt,...)
//Sends text to the adam task which gets
//displayed as red and blinking.
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv),
     *buf1=MSPrintF("%S%s",
       "ST_ERROR",buf);
  if (Fs!=adam_tss)
    Adam("PutS(\"%Q\");",buf1);
  else
    PutS(buf1);
  Free(buf1);
  Free(buf);
}

void XTalk(TssStruct *tss,I1 *fmt,...)
//Sends text to another task's input
//buffer.
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv),
     *buf1=MSPrintF("PutS(\"%Q\");",buf);
  QueueTextInput(tss,0,buf1,0);
  Free(buf1);
  Free(buf);
}

void XTalkWithWait(TssStruct *tss,I1 *fmt,...)
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv),
     *buf1=MSPrintF("PutS(\"%Q\");",buf);
  QueueTextInput(tss,0,buf1,0);
  Free(buf1);
  Free(buf);
  WaitTskIdle(tss);
}

void Auto(I1 *fmt,...)
//Sends text to one's own input buffer
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv),
     *buf1=MSPrintF("PutS(\"%Q\");",buf);
  if (Bt(&Fs->task_flags,TSSf_INPUT_FILTER_TASK))
    CallExtNum(EXT_EXECUTE_STR,buf1);
  else
    QueueTextInput(Fs,0,buf1,1<<TSSCf_HIGHEST_PRIORITY);
  Free(buf1);
  Free(buf);
}


U8 System(I1 *fmt,...)
//Spawns an invisible task and sends text
//which gets compiled and run.
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  U8 result=0;
  TssCmdStruct *tempc;
  TssStruct *tss=Spawn(&SysCmdLine,"SYSTEM TASK",Fs);
  WaitTskIdle(tss);
  tempc=QueueTaskRequest(tss,Fs,buf,
    (1<<TSSCf_WAKE_MASTER));
  GetRequestResult(tempc,&result);
  Kill(tss,FALSE);
  Free(buf);
  return result;
}

U8 ServantUser(I1 *fmt,...)
//Spawns a visible task and sends text
//which gets compiled and run.
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  U8 result=0;
  TssCmdStruct *tempc;
  TssStruct *tss=Spawn(&ServantUserCmdLine,"SERVANT TASK",Fs);
  Fs->popup_tss=tss;
  tempc=QueueTaskRequest(tss,Fs,buf,
    1<<TSSCf_WAKE_MASTER | 1<<TSSCf_FOCUS_MASTER);
  GetRequestResult(tempc,&result);
  Fs->popup_tss=NULL;
  Kill(tss,FALSE);
  Free(buf);
  return result;
}

void AutoStr(I1 *fmt,...)
//Sends text in the nature of an AutoFile to one's
//own input buffer.
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  if (Bt(&Fs->task_flags,TSSf_INPUT_FILTER_TASK))
    CallExtNum(EXT_EXECUTE_STR,buf);
  else
    QueueTextInput(Fs,0,buf,1<<TSSCf_HIGHEST_PRIORITY);
  Free(buf);
}

void AutoFile(I1 *filename)
{
  I1 *name2=DefaultExtension(filename,"AUZ");
  if (Bt(&Fs->task_flags,TSSf_INPUT_FILTER_TASK))
    CallExtNum(EXT_EXECUTE_FILE,name2);
  else
    AutoStr("%F",name2);
  Free(name2);
}


//This sends text of an AutoFile nature to a
//task's input buffer.
void XTalkStr(TssStruct *tss,I1 *fmt,...)
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  QueueTextInput(tss,0,buf,0);
  Free(buf);
}

void XTalkStrWithWait(TssStruct *tss,I1 *fmt,...)
{
  I1 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  QueueTextInput(tss,0,buf,0);
  Free(buf);
  WaitTskIdle(tss);
}

void GetFFlags(U8 *f,I1 *list,I1 *st)
{
  I8 i;
  I1 *st2=MAlloc(StrLen(st)+1),*ptr;
  if (st) {
    while (*st) {
      while (*st && *st!='+' && *st!='-')
	st++;
      if (*st=='+') {
	st++;
	if (*st) {
	  ptr=st2;
	  while (*st && *st!='+' && *st!='-' && *st!=CH_SPACE && *st!=CH_SHIFT_SPACE)
	    *ptr++=*st++;
	  *ptr=0;
	  i=MatchListEntry(st2,list);
	  if (i>=0)
	    Bts(f,i);
	}
      } else if (*st=='-') {
	st++;
	if (*st) {
	  ptr=st2;
	  while (*st && *st!='+' && *st!='-' && *st!=CH_SPACE && *st!=CH_SHIFT_SPACE)
	    *ptr++=*st++;
	  *ptr=0;
	  i=MatchListEntry(st2,list);
	  if (i>=0)
	    Btr(f,i);
	}
      }
    }
  }
  Free(st2);
}

I1 *SPrintFFlags(I1 *dst,I1 *systext_list,U8 flags0,U8 flags1=0)
{
  I8 i;
  I1 *list;
  *dst=0;
  list=SysText(systext_list);
  for (i=0;i<=31;i++)
    if (Bt(&flags0,i)) {
      StrCat(dst,"+");
      StrCat(dst,PointAtListEntry(i,list));
    }
  for (i=0;i<=31;i++)
    if (Bt(&flags1,i)) {
      StrCat(dst,"+");
      StrCat(dst,PointAtListEntry(i+32,list));
    }
  return dst;
}

void D(U1 *buf,U8 cnt=0x80,BoolU4 show_offset=TRUE)
//Dump memory, showing offsets.
//See [C:/LT/Adam/Ltf/LtfMain.APZ,698] LtfD() for a live dump.
{
  U8 i,j,ch;
  U1 *b=buf;
  while (cnt) {
    if (show_offset)
      cout b-buf," ";
    else
      cout b," ";
    j=(cnt>16) ? 16:cnt;
    for (i=0;i<j;i++)
      cout b[i]," ";
    for (;i<16;i++)
      cout "   ";
    for (i=0;i<j;i++) {
      ch=b[i];
      if (ch<CH_SHIFT_SPACE || ch>0x7E) ch='.';
      PutChar(ch);
      if (ch=='$')
	PutChar(ch);
    }
    CrLf;
    cnt-=j;
    b+=j;
  }
}

void Dm(U1 *buf,U8 cnt=0x80)
//Show memory address, not offsets
{
  D(buf,cnt,FALSE);
}
