/* Project: OSMain */

U8 hex_digits[16]="0123456789ABCDEF";
U8 *Bin2Hex(U8 *dst,U64 n;U64 width)
{
  U8 *result=dst+width;
  dst=result;
  while (width--) {
    *--dst=hex_digits[n&15];
    n>>=4;
  }
  return result;
}

U0 PutHex(U64 n,U64 width)
{
  U8 buf[17];
  if (width>16) width=16;
  *Bin2Hex(buf,n,width)=0;
  PutS(buf);
}

asm {
USE64
// ************************************
// IN:	RAX=NUM TO PRINT
PUT_HEX_U64::
	PUSH_C_REGS
	PUSH	16
	PUSH	RAX
	CALL	&PutHex
	POP_C_REGS
	RET
PUT_HEX::
PUT_HEX_U32::
	PUSH_C_REGS
	PUSH	8
	PUSH	RAX
	CALL	&PutHex
	POP_C_REGS
	RET
PUT_HEX_U16::
	PUSH_C_REGS
	PUSH	4
	PUSH	RAX
	CALL	&PutHex
	POP_C_REGS
	RET
PUT_HEX_U8::
	PUSH_C_REGS
	PUSH	2
	PUSH	RAX
	CALL	&PutHex
	POP_C_REGS
	RET
// ************************************
PUT_CHAR::
// IN:	RAX=Char
	PUSH_C_REGS
	PUSH	RAX
	CALL	&PutChar
	POP_C_REGS
	RET
PUT_STR::
// IN:	RSI=String
	PUSH_C_REGS
	PUSH	RSI
	CALL	&PutS
	POP_C_REGS
	RET
// ************************************
_STRCAT::
	ENTER	0
	PUSH	RSI
	PUSH	RDI
	MOV	RSI,U64 SF_ARG1[RBP]
@@05:	LODSB
	OR	AL,AL
	JNZ	@@05
	MOV	RDI,RSI
	DEC	RDI
	MOV	RSI,U64 SF_ARG2[RBP]
@@10:	LODSB
	STOSB
	OR	AL,AL
	JNZ	@@10
	POP	RDI
	POP	RSI
	LEAVE
	RET1	16
// ************************************
_STRCPY::
	ENTER	0
	PUSH	RSI
	PUSH	RDI
	MOV	RSI,U64 SF_ARG2[RBP]
	MOV	RDI,U64 SF_ARG1[RBP]
@@05:	LODSB
	STOSB
	OR	AL,AL
	JNZ	@@05
	POP	RDI
	POP	RSI
	LEAVE
	RET1	16
// ************************************
_STRCMP::
	ENTER	0
	PUSH	RSI
	PUSH	RDI
	MOV	RSI,U64 SF_ARG2[RBP]
	MOV	RDI,U64 SF_ARG1[RBP]
@@05:	LODSB
	OR	AL,AL
	JZ	@@20
	SCASB
	JE	@@05
	JA	@@15
@@10:	MOV	RAX,1
	JMP	@@25
@@15:	MOV	RAX,-1
	JMP	@@25
@@20:	SCASB
	JNE	@@10
	XOR	RAX,RAX
@@25:	POP	RDI
	POP	RSI
	LEAVE
	RET1	16
// ************************************
TO_UPPER::
	CMP	AL,'a'
	JB	@@05
	CMP	AL,'z'
	JA	@@05
	ADD	AL,'A'-'a'
@@05:	RET
// ************************************
_STRICMP::
	ENTER	0
	PUSH	RSI
	PUSH	RDI
	MOV	RSI,U64 SF_ARG2[RBP]
	MOV	RDI,U64 SF_ARG1[RBP]
@@05:	LODSB
	OR	AL,AL
	JZ	@@30
	CMP	AL,'a'
	JB	@@10
	CMP	AL,'z'
	JA	@@10
	ADD	AL,'A'-'a'
@@10:	MOV	BL,U8 [RDI]
	INC	RDI
	CMP	BL,'a'
	JB	@@15
	CMP	BL,'z'
	JA	@@15
	ADD	BL,'A'-'a'
@@15:	CMP	AL,BL
	JE	@@05
	JA	@@25
@@20:	MOV	RAX,1
	JMP	@@35
@@25:	MOV	RAX,-1
	JMP	@@35
@@30:	MOV	BL,U8 [RDI]
	OR	BL,BL
	JNE	@@20
	XOR	RAX,RAX
@@35:	POP	RDI
	POP	RSI
	LEAVE
	RET1	16
// ************************************
_STRNCMP::
	ENTER	0
	PUSH	RSI
	PUSH	RDI
	MOV	RCX,U64 SF_ARG3[RBP]
	MOV	RSI,U64 SF_ARG2[RBP]
	MOV	RDI,U64 SF_ARG1[RBP]
@@05:	OR	RCX,RCX
	JZ	@@25
	DEC	RCX
	LODSB
	OR	AL,AL
	JZ	@@20
	SCASB
	JE	@@05
	JA	@@15
@@10:	MOV	RAX,1
	JMP	@@30
@@15:	MOV	RAX,-1
	JMP	@@30
@@20:	MOV	BL,U8 [RDI]
	OR	BL,BL
	JNE	@@10
@@25:	XOR	RAX,RAX
@@30:	POP	RDI
	POP	RSI
	LEAVE
	RET1	24
// ************************************
_STRNICMP::
	ENTER	0
	PUSH	RSI
	PUSH	RDI
	MOV	RCX,U64 SF_ARG3[RBP]
	MOV	RSI,U64 SF_ARG2[RBP]
	MOV	RDI,U64 SF_ARG1[RBP]
@@05:	OR	RCX,RCX
	JZ	@@35
	DEC	RCX
	LODSB
	OR	AL,AL
	JZ	@@30
	CMP	AL,'a'
	JB	@@10
	CMP	AL,'z'
	JA	@@10
	ADD	AL,'A'-'a'
@@10:	MOV	BL,U8 [RDI]
	INC	RDI
	CMP	BL,'a'
	JB	@@15
	CMP	BL,'z'
	JA	@@15
	ADD	BL,'A'-'a'
@@15:	CMP	AL,BL
	JE	@@05
	JA	@@25
@@20:	MOV	RAX,1
	JMP	@@40
@@25:	MOV	RAX,-1
	JMP	@@40
@@30:	SCASB
	JNE	@@20
@@35:	XOR	RAX,RAX
@@40:	POP	RDI
	POP	RSI
	LEAVE
	RET1	24
// ************************************
_STRSTR::
	ENTER	0
	PUSH	RSI
	PUSH	RDI
	MOV	RSI,U64 SF_ARG1[RBP]
	MOV	RDI,U64 SF_ARG2[RBP]
	MOV	DL,U8 [RDI]
	OR	DL,DL
	JZ	@@20
	JMP	@@10
@@05:	INC	RSI
@@10:	LODSB
	OR	AL,AL
	JZ	@@25
	CMP	AL,DL
	JNE	@@10
	DEC	RSI
	MOV	RCX,1
@@15:	MOV	AL,U8 [RDI+RCX]
	OR	AL,AL
	JZ	@@20
	CMP	AL,U8 [RSI+RCX]
	JNE	@@05
	INC	RCX
	JMP	@@15

	DEC	RSI
@@20:	MOV	RAX,RSI
	JMP	@@30
@@25:	XOR	RAX,RAX
@@30:	POP	RDI
	POP	RSI
	LEAVE
	RET1	16
// ************************************
_STRISTR::
	ENTER	0
	PUSH	RSI
	PUSH	RDI
	MOV	RSI,U64 SF_ARG1[RBP]
	MOV	RDI,U64 SF_ARG2[RBP]
	MOV	AL,U8 [RDI]
	CALL	TO_UPPER
	MOV	DL,AL
	OR	DL,DL
	JZ	@@20
	JMP	@@10
@@05:	INC	RSI
@@10:	LODSB
	CALL	TO_UPPER
	OR	AL,AL
	JZ	@@25
	CMP	AL,DL
	JNE	@@10
	DEC	RSI
	MOV	RCX,1
@@15:	MOV	AL,U8 [RDI+RCX]
	CALL	TO_UPPER
	OR	AL,AL
	JZ	@@20
	MOV	BL,U8 [RSI+RCX]
	XCHG	AL,BL
	CALL	TO_UPPER
	CMP	AL,BL
	JNE	@@05
	INC	RCX
	JMP	@@15

	DEC	RSI
@@20:	MOV	RAX,RSI
	JMP	@@30
@@25:	XOR	RAX,RAX
@@30:	POP	RDI
	POP	RSI
	LEAVE
	RET1	16
}
LTextern _STRCMP I64 StrCmp(U8 *st1,U8 *st2);
LTextern _STRICMP I64 StrICmp(U8 *st1,U8 *st2);
LTextern _STRNCMP I64 StrNCmp(U8 *st1,U8 *st2,U64 n);
LTextern _STRNICMP I64 StrNICmp(U8 *st1,U8 *st2,U64 n);
LTextern _STRSTR U8 *StrStr(U8 *st,U8 *pattern);
LTextern _STRISTR U8 *StrIStr(U8 *st,U8 *pattern);
LTextern _STRCPY U0 StrCpy(U8 *dest,U8 *src);
LTextern _STRCAT U0 StrCat(U8 *dest,U8 *src);

/*
These bitmaps go to 0-511 so that
[C:/LT/Compiler/Lex.CPZ,755] Lex() can use them with [C:/LT/OSMain/Adam1a.HPZ,1805] Token Codes.
*/
U32 alpha_bitmap[16]=
{0x0000000,0x00000000,0x87FFFFFF,0x07FFFFFE,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
0,0,0,0,0,0,0,0};
U32 alpha_numeric_bitmap[16]=
{0x0000000,0x03FF0000,0x87FFFFFF,0x07FFFFFE,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
0,0,0,0,0,0,0,0};
U32 alpha_numeric_no_at_bitmap[16]=
{0x0000000,0x03FF0000,0x87FFFFFE,0x07FFFFFE,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
0,0,0,0,0,0,0,0};
U32 word_bitmap[16]=
{0x0000000,0x03FF0080,0x87FFFFFE,0x07FFFFFE,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
0,0,0,0,0,0,0,0};
U32 filename_chars_bitmap[16]=
{0x0000000,0x03FF73FB,0xEFFFFFFF,0x2FFFFFFF,0,0,0,0,
0,0,0,0,0,0,0,0};
U32 dec_numeric_bitmap[16]=
{0x0000000,0x03FF0000,0,0,0,0,0,0,
0,0,0,0,0,0,0,0};
U32 hex_numeric_bitmap[16]=
{0x0000000,0x03FF0000,0x7E,0x7E,0,0,0,0,
0,0,0,0,0,0,0,0};
U32 white_space_bitmap[16]=
{0x80003600,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0};
U32 non_eol_white_space_bitmap[16]=
{0x80001200,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0};
U32 zero_cr_nl_cursor_bitmap[16]=
{0x00002421,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0};
U32 zero_tab_ff_cr_nl_cursor_bitmap[16]=
{0x00003621,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0};
U32 zero_tab_ff_cr_nl_cursor_dollar_bitmap[16]=
{0x00003621,0x10,0,0,0,0,0,0,
0,0,0,0,0,0,0,0};
U32 getkey_chars_bitmap[16]=
{0x80002600,0xFFFFFFFF,0xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
0,0,0,0,0,0,0,0};
U32 printable_chars_bitmap[16]=
{0x80003600,0xFFFFFFFF,0xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
0,0,0,0,0,0,0,0};
U32 displayable_chars_bitmap[16]=
{0x80000000,0xFFFFFFFF,0xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
0,0,0,0,0,0,0,0};
U32 safe_dollar_chars_bitmap[16]=
{0x80000000,0xFFFFFFEF,0xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
0,0,0,0,0,0,0,0};//same but no dollar sign
U32 non_eol_chars_bitmap[16]=
{0xFFFFDBFE,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF};

U8 *ListEntryPoint(I64 entry_num, U8 *lst)
{//Point to list entry.
 //Not especially efficient but handy.  Use an array of U8*'s for efficiency.
  while (*lst && entry_num>0) {
    while (*lst)  // Advance to end of cur entry.
      lst++;
    lst++;    // Skip trailing zero
    entry_num--;
    if (*lst=='@') { // Check for '@' alias list entry
      entry_num++;
      lst++;
    }
  }
  if (entry_num)
    return NULL;
  else
    return lst;
}

I64 ListEntryMatch(U8 *src, U8 *lst,I64 flags=0,I64 *ambiguity_overkill_ptr=NULL)
// RETURNS: -2 if Ambiguous, -1 if not found, else entry_num
{ //Not especially efficient but handy.  Use hash tables for efficiency.
  I64 n,entry_num=0,result=-1,unutilized_src;
  U8 *s;
  BoolI8 exact_match=FALSE;

  n=StrLen(src);
  if (ambiguity_overkill_ptr)
    *ambiguity_overkill_ptr=n;
  while (*lst) {
    if (*lst=='@') { /* Check for '@' alias list entry*/
      entry_num--;
      lst++;
    }

    s=src;
    if (flags & LEF_IGNORE_CASE)
      while (*s && ToUpper(*s) == ToUpper(*lst)) {
	s++;
	lst++;
      }
    else
      while (*s && *s==*lst) {
	s++;
	lst++;
      }
    unutilized_src=n-(s-src);
    if (!*s) {	  // Did we reach end of src
      if (!*lst) {  // Did we reach end of list entrycount
	if (!ambiguity_overkill_ptr)
	  return entry_num;  // Found Exact match
	result=entry_num;
	exact_match=TRUE;
      } else {
	if (result!=-1) {
	  if (ambiguity_overkill_ptr)
	    *ambiguity_overkill_ptr=0;
	  if (!exact_match)
	    result=-2; // AMBIGUOUS RESPONSE unless later exact match
	} else {
	  if (!(flags & LEF_EXACT))
	    result=entry_num;
	}
      }
    } else {
      if (ambiguity_overkill_ptr && *ambiguity_overkill_ptr>unutilized_src-1)
	*ambiguity_overkill_ptr=unutilized_src-1;
    }

    while (*lst)  // Advance to end of cur entry.
      lst++;
    lst++;    // Skip trailing zero
    entry_num++;
  }
  if (ambiguity_overkill_ptr && result==-1)
    *ambiguity_overkill_ptr=0;
  return result;
}

U0 UndefinedDefine(U8 *name)
{
  PutS(ST_ERR_ST "Undefined Define: '");
  PutS(name);
  PutS("'.\r\n");
  throw(EXCEPT_UNDEF_DEFINE,name);
}


U8 *Define(U8 *name)
{
  DefineStrHashEntry *temph=HashFind(name,Fs->hash_table,HTT_DEFINE_STR);
  if (temph)
    return temph->data;
  else
    UndefinedDefine(name);
}

U8 *DefineSub(U64 sub,U8 *name)
{
  DefineStrHashEntry *temph=HashFind(name,Fs->hash_table,HTT_DEFINE_STR);
  if (temph)
    return ListEntryPoint(sub,temph->data);
  else
    UndefinedDefine(name);
}

I64 DefineSubCnt(U8 *name)
{
  DefineStrHashEntry *temph=HashFind(name,Fs->hash_table,HTT_DEFINE_STR);
  if (temph)
    return temph->cnt;
  else
    UndefinedDefine(name);
}

I64 DefineMatch(U8 *src,U8 *lst_name,
  U64 flags=0,I64 *ambiguity_overkill_ptr=NULL)
{
  return ListEntryMatch(src,Define(lst_name),
    flags,ambiguity_overkill_ptr);
}

U0 PutDefine(U8 *name)
{
  PutS(Define(name));
}

U0 GetOutOfDollar()
{
  Ltf *l;
  if (IsRaw) {
    if (sys_raw_dc_flags&RDCF_IN_DOLLAR)
      PutChar('$');
  } else {
    if (fp_ltf_cur && (l=(*fp_ltf_cur)(Fs)) && l->flags&LTFF_IN_DOLLAR)
      PutChar('$');
  }
}

U0 CrLf(I64 cnt=1)
{
  while (cnt-->0) {
    PutChar(CH_CR);
    PutChar(CH_LINE_FEED);
  }
}

U0 Spaces(I64 cnt=1)
{
  while (cnt-->0)
    PutChar(CH_SPACE);
}

U0 PutErr(U8 *st=NULL)
{
  GetOutOfDollar;
  PutDefine("ST_ERR");
  if (st) {
    PutS(st);
    CrLf;
  }
}

U0 PutWarn(U8 *st=NULL)
{
  GetOutOfDollar;
  PutDefine("ST_WARN");
  if (st) {
    PutS(st);
    CrLf;
  }
}

U0 PutDefineErr(U8 *st)
{
  PutErr;
  PutDefine(st);
}

U0 PutDefineWarn(U8 *st)
{
  PutWarn;
  PutDefine(st);
}

BoolI64 YorN()
{
  U64 ch;
  PutS("(y or n)? ");
  while (TRUE) {
    ch=ToUpper(GetChar(NULL,FALSE));
    if (ch=='Y') {
      PutS("$FU$YES$FG$\r\n");
      return TRUE;
    } else if (ch=='N') {
      PutS("$FU$NO$FG$\r\n");
      return FALSE;
    }
  }
}

BoolI64 PressAKey()
{
  U64 ch;
  PutDefine("ST_PRESS_A_KEY");
  ch=GetChar(NULL,FALSE);
  if (ch==CH_SHIFT_ESC || ch==CH_ESC)
    return FALSE;
  else
    return TRUE;
}

BoolI64 ExitAllApplications()
{
  U64 ch;
  PutDefine("ST_EXIT_ALL_APPLICATIONS");
  PutDefine("ST_PRESS_A_KEY");
  ch=GetChar(NULL,FALSE);
  if (ch==CH_SHIFT_ESC || ch==CH_ESC)
    return FALSE;
  else
    return TRUE;
}

BoolI64 AreYouSure()
{
  PutDefine("ST_ARE_YOU_SURE");
  return YorN;
}
DefineStrHashEntry *DefineLoad(U8 *name,U8 *st,BoolI8 replace=FALSE)
{
  DefineStrHashEntry *temph=CAlloc(sizeof(DefineStrHashEntry));
  temph->type=HTT_DEFINE_STR;
  temph->str=StrNew(name);
  temph->data=StrNew(st);
  temph->cnt=-1;
  temph->caller=Caller;
  if (replace)
    HashReplace(temph,Fs->hash_table);
  else
    HashAdd(temph,Fs->hash_table);
  return temph;
}

DefineStrHashEntry *DefineListLoad(U8 *name,U8 *st,BoolI8 replace=FALSE)
{ //Not especially efficient but handy.
  I64 cnt=0;
  U8 *ptr;
  DefineStrHashEntry *temph=CAlloc(sizeof(DefineStrHashEntry));
  temph->type=HTT_DEFINE_STR;
  temph->str=StrNew(name);
  ptr=st;
  while (*ptr) {
    while (*ptr++);
    cnt++;
  }
  temph->data=MAlloc(ptr+1-st);
  MemCpy(temph->data,st,ptr+1-st);
  temph->cnt=cnt;
  temph->caller=Caller;
  if (replace)
    HashReplace(temph,Fs->hash_table);
  else
    HashAdd(temph,Fs->hash_table);
  return temph;
}

I64 StrOcc(U8 *src, U64 ch)
{
  I64 i=0;
  while (*src)
    if (*src++==ch)
      i++;
  return i;
}

I64 Spaces2Tabs(U8 *dst2,U8 *src)
{
  U8 *src2,*dst=dst2;
  I64 i,chged=0,space_cnt,space_cnt2,col=0;
  while (*src) {
    src2=src;
    space_cnt=0;
    while (*src2==CH_SPACE) {
      space_cnt++;
      src2++;
    }
    if (space_cnt<2) {
      if (*src==CH_TAB)
	col=0;
      else {
	col++;
	if (col==8)
	  col=0;
      }
      *dst++=*src++;
    } else {
      while (col+space_cnt>=8) {
	space_cnt2=8-col;
	if (space_cnt2==1)
	  *dst++=CH_SPACE;
	else {
	  *dst++=CH_TAB;
	  chged=chged+(space_cnt2-1);
	}
	space_cnt=space_cnt-space_cnt2;
	col=0;
      }
      for (i=0;i<space_cnt;i++) {
	*dst++=CH_SPACE;
	col++;
      }
      src=src2;
    }
  }
  *dst--=0;
  return chged;
}

U8 *Tabs2Spaces(U8 *src)
{
  I64 i,j,l=StrLen(src)<<1+2,col=0;
  U8 ch,*dst=MAlloc(l),*temp;
  while (ch=*src++) {
    if (ch==CH_TAB) {
      j=(col+8) & -0x8;
      for (i=col;i<j;i++) {
	dst[i]=CH_SPACE;
	if (i>=l-2) {
	  temp=MAlloc(l<<1);
	  MemCpy(temp,dst,i+1);
	  Free(dst);
	  l<<=1;
	  dst=temp;
	}
      }
      col=j;
    } else {
      dst[col]=ch;
      if (col>=l-2) {
	temp=MAlloc(l<<1);
	MemCpy(temp,dst,col+1);
	Free(dst);
	l<<=1;
	dst=temp;
      }
      col++;
    }
  }
  dst[col]=0;
  return dst;
}

U8 *ScaleIndent(U8 *src,F64 indent_scale_factor)
{
  I64 i,col=0;
  U8 ch,*dst,*dst2;
  while (ch=*src++) {
    if (ch==CH_TAB)
      col=(col+8) & -0x8;
    else if (ch==CH_SPACE)
      col++;
    else
      break;
  }
  src--;
  col=Round(indent_scale_factor*col);
  dst=dst2=MAlloc(StrLen(src)+col/8+col&7+1);
  for (i=col/8;i>0;i--)
    *dst2++=CH_TAB;
  for (i=col&7;i>0;i--)
    *dst2++=CH_SPACE;
  StrCpy(dst2,src);
  return dst;
}

U8 *StrUtil(U8 *_src,I64 flags)
{//See [C:/LT/OSMain/Adam1a.HPZ,3613] flags
  U8 *src=_src,*dst=_src;
  U64 ch;

  if (flags & SUF_REM_LEADING)
    while (Bt(white_space_bitmap,*src))
      src++;
  while (ch=*src++) {
    if (Bt(white_space_bitmap,ch)) {
      if (!(flags & SUF_REM_SPACES)) {
	if (flags & SUF_SINGLE_SPACE) {
	  *dst++ = CH_SPACE;
	  while ((ch=*src++) && Bt(white_space_bitmap,ch));
	  src--;
	} else
	  *dst++ = ch;
      }
    } else {
      if (!(flags & SUF_REM_CTRL_CHARS) || ch>=CH_SHIFT_SPACE)
	*dst++=ch;
    }
  }
  *dst=0;

  if (flags & SUF_CAP_UNDERSCORES) {
    src=_src;
    dst=_src;
    while (*src) {
      *dst++=ToUpper(*src++);
      while (*src && *src!='_')
	*dst++=*src++;
      if (*src=='_')
	src++;
    }
    *dst=0;
  }

  if (flags & SUF_REM_TRAILING)
    while (dst!=_src && (!*dst || Bt(white_space_bitmap,*dst)))
      *dst-- =0;
  if (flags & SUF_TO_UPPER)
    for (dst=_src;*dst;dst++) {
      ch=*dst;
      if ('a'<=ch<='z')
	*dst=ch-0x20;
    }
  if (flags & SUF_TO_LOWER)
    for (dst=_src;*dst;dst++) {
      ch=*dst;
      if ('A'<=ch<='Z')
	*dst=ch+0x20;
    }
  if (flags & SUF_SAFE_DOLLAR)
    for (dst=_src;*dst;dst++) {
      ch=*dst;
      if (!Bt(safe_dollar_chars_bitmap,*dst))
	*dst='.';
    }
  if (flags & SUF_S2T)
    Spaces2Tabs(_src,_src);
  return _src;
}

U8 *MStrUtil(U8 *src,U64 flags,F64 indent_scale_factor=0)
//Return a [C:/LT/OSMain/Memory.CPZ,925] MAlloc()ed result from StrUtil
{
  U8 *dst=StrNew(src),*dst2,*temp;
  StrUtil(dst,flags);
  if (flags & SUF_T2S) {
    temp=Tabs2Spaces(dst);
    Free(dst);
    dst=temp;
  }
  if (flags & SUF_SCALE_INDENT)
    dst2=ScaleIndent(dst,indent_scale_factor);
  else
    dst2=StrNew(dst); //Shorten
  Free(dst);
  return dst2;
}

U8 *StrFirstOcc(U8 *src,U8 *marker)
{
  U8 ch;
  while ((ch=*src++) && !StrOcc(marker,ch));
  if (ch)
    return src-1;
  else
    return NULL;
}

U8 *StrFirstRem(U8 *src,U8 *marker,U8 *dst=NULL)
{
  U8 *ptr=src,*result=dst,ch;
  if (dst) {
    while ((ch=*ptr++) && !StrOcc(marker,ch))
      *dst++=ch;
    *dst=0;
  } else
    while ((ch=*ptr++) && !StrOcc(marker,ch));
  if (ch)
    StrCpy(src,ptr);
  else
    *src=0;
  return result;
}

U8 *StrLastOcc(U8 *src,U8 *marker)
{
  U8 ch,*result=NULL;
  while (ch=*src++)
    if (StrOcc(marker,ch))
      result=src-1;
  return result;
}

U8 *StrLastRem(U8 *src,U8 *marker,U8 *dst=NULL)
{
  U8 *ptr;
  if (ptr=StrLastOcc(src,marker)) {
    if (dst)
      StrCpy(dst,ptr+1);
    *ptr=0;
  } else {
    if (dst)
      StrCpy(dst,src);
    *src=0;
  }
  return dst;
}

U8 *SearchStr(U8 *src,U8 *pattern,U64 flags=0)
{
  BoolI8 cont;
  U8 *src2;
  U8 *saved_src=src;
  I64 plen=StrLen(pattern);
  do {
    cont=FALSE;
    if (flags & SRF_IGNORE_CASE)
      src=StrIStr(src,pattern);
    else
      src=StrStr(src,pattern);
    if (src && flags & SRF_WHOLE_LABELS) {
      src2=src+plen;
      if (Bt(alpha_numeric_bitmap,*src2)) {
	src++;
	if (*src)
	  cont=TRUE;
	else
	  src=NULL;
      } else {
	if (src!=saved_src) {
	  src2=src-1;
	  if (Bt(alpha_numeric_bitmap,*src2)) {
	    src++;
	    if (*src)
	      cont=TRUE;
	    else
	      src=NULL;
	  }
	}
      }
    }
  } while (cont);
  return src;
}

BoolI64 WildCardMatch(U8 *wild,U8 *src)
{
  U64 ch1,ch2;
  U8 *fall_back_src,*fall_back_wild=NULL;
  while (TRUE) {
    if (!(ch1=*src++)) {
      if (*wild)
	return FALSE;
      else
	return TRUE;
    } else {
      if (!(ch2=*wild++))
	return FALSE;
      else {
	if (ch2=='*') {
	  fall_back_wild=wild-1;
	  fall_back_src=src;
	  if (!(ch2=*wild++))
	    return TRUE;
	  while (ch2!=ch1)
	    if (!(ch1=*src++))
	      return FALSE;
	} else
	  if (ch2!='?' && ch1!=ch2) {
	    if (fall_back_wild) {
	      wild=fall_back_wild;
	      src=fall_back_src;
	      fall_back_wild=NULL;
	    } else
	      return FALSE;
	  }
      }
    }
  }
}

U8 *StrAdd(U8 *base,U8 *addition)
//Concatinates a string onto another string.
//Returns new string.
//Dbls length when it grows.
{
  U8 *result;
  I64 blen=StrLen(base),alen=StrLen(addition);
  I64 bmem=MSize(base);
  if (blen+alen+1>bmem) {
    result=MAlloc(bmem<<1+alen+4);
    MemCpy(result,base,blen);
    StrCpy(result+blen,addition);
    Free(base);
  } else {
    result=base;
    StrCpy(result+blen,addition);
  }
  return result;
}


I64 A2I(U8 *st,I64 radix=10,U8 **_end_ptr=NULL)
{ //ASCII to Int
  BoolI8 neg=FALSE;
  U8 ch;
  I64 result=0,k=0;
  if (radix<2||radix>36) return 0;
  while (Bt(white_space_bitmap,*st))
    st++;
  if (*st=='-') {
    st++;
    neg=TRUE;
  } else if (*st=='+')
    st++;
  while (ch=ToUpper(*st++)) {
    if (radix>10) {
      if ('0'<=ch<='9')
	result=result*radix+ch-'0';
      else if ('A'<=ch<='A'+radix-11)
	result=result*radix+ch-'A'+10;
      else
	break;
    } else {
      if (k==1 && !result) {
	if (ch=='X') {
	  radix=16;
	  goto ai_skip;
	} else if (ch=='B') {
	  radix=2;
	  goto ai_skip;
	} else if (ch=='O') {
	  radix=8;
	  goto ai_skip;
	} else if (ch=='D') {
	  radix=10;
	  goto ai_skip;
	}
      }
      if ('0'<=ch<='0'+radix-1)
	result=result*radix+ch-'0';
      else
	break;
    }
ai_skip:
    k++;
  }
  if (_end_ptr) *_end_ptr=st-1;
  return neg ? -result:result;
}

U0 GetFFlags(U0 *f,U8 *list,U8 *st)
{
  I64 i;
  U8 *st2,*ptr;
  if (st) {
    st2=MAlloc(StrLen(st)+1);
    while (*st) {
      while (*st && *st!='+' && *st!='-')
	st++;
      if (*st=='+') {
	st++;
	if (*st) {
	  ptr=st2;
	  while (*st && *st!='+' && *st!='-' && *st!=CH_SPACE && *st!=CH_SHIFT_SPACE)
	    *ptr++=*st++;
	  *ptr=0;
	  i=ListEntryMatch(st2,list);
	  if (i>=0)
	    LBts(f,i);
	}
      } else if (*st=='-') {
	st++;
	if (*st) {
	  ptr=st2;
	  while (*st && *st!='+' && *st!='-' && *st!=CH_SPACE && *st!=CH_SHIFT_SPACE)
	    *ptr++=*st++;
	  *ptr=0;
	  i=ListEntryMatch(st2,list);
	  if (i>=0)
	    LBtr(f,i);
	}
      }
    }
    Free(st2);
  }
}

U8 *SPrintFFlags(U8 *dst,U8 *list,U64 flags)
{
  I64 i;
  *dst=0;
  for (i=0;i<=63;i++)
    if (Bt(&flags,i)) {
      StrCat(dst,"+");
      StrCat(dst,ListEntryPoint(i,list));
    }
  return dst;
}

U8 *SPrintFJoin(U8 *dst,U8 *fmt,I64 argc,I64 *argv)
{ //See [C:/LT/OSMain2/SPrintF2.CPZ,490] SPrintFJoin2()
  if (fp_sprintf_join)
    return (*fp_sprintf_join)(dst,fmt,argc,argv);
  else { //Temp measure until loaded
    if (dst) {
      StrCpy(dst,fmt);
      return dst;
    } else
      return StrNew(fmt);
  }
}

U8 *GetFJoin(U8 *src,U8 *fmt,I64 argc,I64 *argv)
{
  if (fp_getf_join)
    return (*fp_getf_join)(src,fmt,argc,argv);
  else
    Dbg("OSMain2 not Loaded.");
}

U8 *SPrintF(U8 *dst,U8 *fmt,...)
{ //See [C:/LT/OSMain2/SPrintF2.CPZ,490] SPrintFJoin2()
  return SPrintFJoin(dst,fmt,argc,argv);
}

U8 *GetF(U8 *src,U8 *fmt,...)
//Pass ptr to data,
//For %s pass ptr to ptr (be careful because addr
//of array is the same as array--create ptr to array and take addr
{
  return GetFJoin(src,fmt,argc,argv);
}


U0 PrintF(U8 *fmt,...)
{//[::/LT/Doc/Differences.TXZ,PrintF_Codes] PrintF Extended Codes
 //See [C:/LT/OSMain2/SPrintF2.CPZ,490] SPrintFJoin2()
  U8 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  PutS(buf);
  Free(buf);
}

U8 *MSPrintF(U8 *fmt,...)
{ //See [C:/LT/OSMain2/SPrintF2.CPZ,490] SPrintFJoin2()
  U8 *result,*buf=SPrintFJoin(NULL,fmt,argc,argv);
  result=StrNew(buf);
  Free(buf);
  return result;
}

U0 DefinePrintF(U8 *name,U8 *src,...)
{
  U8 *buf=SPrintFJoin(NULL,src,argc,argv);
  DefineLoad(name,buf);
  Free(buf);
}

U0 PrintFErr(U8 *fmt,...)
{
  U8 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  PutErr;
  PutS(buf);
  Free(buf);
}

U0 PrintFWarn(U8 *fmt,...)
{
  U8 *buf=SPrintFJoin(NULL,fmt,argc,argv);
  PutWarn;
  PutS(buf);
  Free(buf);
}
