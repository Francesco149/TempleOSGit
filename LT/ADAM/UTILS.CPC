public void LtfDm(U1 *buf,U8 cnt=0x80)
{
  LtfEntry *ll;
  BoolU4 old_preempt=Preempt(OFF);
  Ltf *l=Fs->cur_ltf;
  ll=LtfPrintF(l,"$HX -Z %d 16$",cnt);
  ll->data=buf;
  l->cur_entry=ll->next;
  LtfRecalc(l);
  Preempt(old_preempt);
}

public void LtfD(U1 *buf,U8 cnt=0x80)
{
  LtfEntry *ll;
  BoolU4 old_preempt=Preempt(OFF);
  Ltf *l=Fs->cur_ltf;
  ll=LtfPrintF(l,"$HX %d 16$",cnt);
  ll->data=buf;
  l->cur_entry=ll->next;
  LtfRecalc(l);
  Preempt(old_preempt);
}

extern BoolU4 View();

public U1 *PatchBlk(U8 blk,BoolU4 write=FALSE)
{
  U1 *buf=MAlloc(BLK_SIZE);

  RBlks(Fs->cur_partition,buf,blk,1,TRUE);
  LtfD(buf,BLK_SIZE);
  if (write) {
    coutln "Edit and press ESC to write or ^Q";
    if (View) {
      coutln "Write";
      WBlks(Fs->cur_partition,buf,blk,1,TRUE);
    }
  }
  return buf;
}

public U1 *Patch(U8 c,U8 cnt=0,BoolU4 write=FALSE)
{
  U1 *buf=MAlloc(BLK_SIZE*Fs->cur_partition->spc);

  if (cnt)
    c=NextClusterNum(Fs->cur_partition,c,cnt,TRUE);
  RClusters(Fs->cur_partition,buf,c,1,TRUE);
  coutln "Cluster:",c;
  LtfD(buf,BLK_SIZE*Fs->cur_partition->spc);
  if (write) {
    coutln "Edit and press ESC to write or ^Q";
    if (View) {
      coutln "Write";
      WClusters(Fs->cur_partition,buf,c,1,TRUE);
    }
  }
  return buf;
}


public U8 UnusedSysMem()
{
  MemBlk *tempm;
  U8 i,result=0,old_flags=GetFlags;
  Cli;
  tempm=mem_free_list;
  while (tempm) {
    result=result+tempm->pages;
    tempm=tempm->next;
  }
  for (i=0;i<FREE_PAGE_HASH_SIZE;i++) {
    tempm=free_page_hash[i];
    while (tempm) {
      result+=tempm->pages;
      tempm=tempm->next;
    }
  }
  for (i=0;i<32;i++) {
    tempm=free_page_hash2[i];
    while (tempm) {
      result+=tempm->pages;
      tempm=tempm->next;
    }
  }
  SetFlags(old_flags);
  return result*PAGE_SIZE;
}

public U8 TaskAllocatedMem(TssStruct *tss=NULL)
{
  MemBlk *m;
  U8 result=0,old_flags=GetFlags;
  if (!tss) tss=Fs;
  m=tss->next_mem_blk;
  Cli;
  while (m!=&tss->next_mem_blk) {
    result+=m->pages*PAGE_SIZE-sizeof(MemBlk);
    m=m->next;
  }
  SetFlags(old_flags);
  return result;
}

public U8 TaskUnusedAllocatedMem(TssStruct *tss=NULL)
{
  U8 result=0,i,old_flags=GetFlags;
  UnusedAllocatedMem *u;
  if (!tss) tss=Fs;
  Cli;
  for (i=0;i<HEAP_HASH_SIZE>>2;i++) {
    u=tss->heap_hash[i];
    while (u) {
      result+=u->size;
      u=u->next;
    }
  }
  u=tss->malloc_free_list;
  while (u) {
    result+=u->size;
    u=u->next;
  }
  SetFlags(old_flags);
  return result;
}

I8 CompareUamPtrs(UnusedAllocatedMem **e1,
		     UnusedAllocatedMem **e2)
{
  return *e1-*e2;
}

I8 CompareUamSize(UnusedAllocatedMem **e1,
		     UnusedAllocatedMem **e2)
{
  return (*e2)->size-(*e1)->size;
}


public void HeapRep(TssStruct *tss=NULL)
{
  I8 i,cnt;
  UnusedAllocatedMem *u;
  U8 old_flags=GetFlags;

  if (!tss) tss=Fs;
  Cli;
  for (i=0;i<HEAP_HASH_SIZE>>2;i++) {
    cnt=0;
    u=tss->heap_hash[i];
    while (u) {
      cnt+=u->size;
      u=u->next;
    }
    if (cnt)
      PrintF("%03X:%08X\r\n",i<<2,cnt);
  }
  u=tss->malloc_free_list;
  while (u) {
    PrintF("%08X\r\n",u->size);
    u=u->next;
  }
  SetFlags(old_flags);
}

public BoolU4 IsInHeap(U1 *a,TssStruct *tss=NULL)
{
  MemBlk *m;
  U8 old_flags=GetFlags;
  if (!tss) tss=Fs;
  m=tss->next_mem_blk;
  Cli;
  while (m!=&tss->next_mem_blk) {
    if (a>=m && a<m+m->pages*PAGE_SIZE) {
      SetFlags(old_flags);
      return TRUE;
    }
    m=m->next;
  }
  SetFlags(old_flags);
  return FALSE;
}

public BoolU4 HeapChk(TssStruct *tss=NULL)
//This just detects one type of error--
//    when a freed value is not valid.
{
  I8 i;
  UnusedAllocatedMem *u;
  BoolU4 result=TRUE;
  U8 old_flags=GetFlags;

  if (!tss) tss=Fs;
  Cli;
  for (i=0;i<HEAP_HASH_SIZE>>2;i++) {
    u=tss->heap_hash[i];
    while (u) {
      if (!IsInHeap(u,tss))
	result=FALSE;
      u=u->next;
    }
  }
  u=tss->malloc_free_list;
  while (u) {
    if (!IsInHeap(u,tss))
      result=FALSE;
    u=u->next;
  }
  SetFlags(old_flags);
  return result;
}



//TODO:Crashes
///More of a heap check at the moment
void CollectFreedAllocatedMem(TssStruct *tss=NULL)
{
  I8 i,cnt;
//I8 j;
  UnusedAllocatedMem *u,**sort_buf;
  U8 old_flags=GetFlags;
//  U4 *dd;

  if (!tss) tss=Fs;
  Cli;
  cnt=0;
  for (i=0;i<HEAP_HASH_SIZE>>2;i++) {
    u=tss->heap_hash[i];
    while (u) {
      cnt++;
      u=u->next;
    }
  }
  u=tss->malloc_free_list;
  while (u) {
    cnt++;
    u=u->next;
  }
  SetFlags(old_flags);

  //We might disturb the Free list and irq's might Free some
  sort_buf=MAlloc(((cnt+512)&-0x100)*PTR_SIZE);

  Cli;
  cnt=0;

  for (i=0;i<HEAP_HASH_SIZE>>2;i++) {
    u=tss->heap_hash[i];
    while (u) {
      sort_buf[cnt++]=u;
      u=u->next;
    }
    tss->heap_hash[i]=NULL;
  }

  u=tss->malloc_free_list;
  while (u) {
    sort_buf[cnt++]=u;
    u=u->next;
  }
  tss->malloc_free_list=NULL;

  for (i=0;i<FREE_PAGE_HASH_SIZE;i++)
    free_page_hash[i]=NULL;

  for (i=0;i<32;i++)
    free_page_hash2[i]=NULL;

  SetFlags(old_flags);

  QSort(sort_buf,cnt,PTR_SIZE,&CompareUamPtrs);
  for (i=0;i<cnt;i++) {
    if (sort_buf[i]+sort_buf[i]->size>sort_buf[i+1])
      cout "****";
    coutln sort_buf[i]," ",sort_buf[i]->size;
  }
/*
  j=0;
  for (i=0;i<cnt;i++) {
    if (sort_buf[i]==sort_buf[j]+sort_buf[j]->size &&
	sort_buf[j]->size+sort_buf[i]->size<HEAP_HASH_SIZE)
      sort_buf[j]->size=sort_buf[j]->size+
			sort_buf[i]->size;
    else
      sort_buf[++j]=sort_buf[i];
  }
  if (cnt) {
    j++;
    QSort(sort_buf,j,PTR_SIZE,&CompareUamSize);
    for (i=0;i<j;i++) {
      sort_buf[i]->next=sort_buf[i]->size;
      Free(sort_buf[i]+4,tss);
    }
  }
*/
  Free(sort_buf);
}

void TaskRepTask(TssStruct *tss,I8 indent)
{
  TssStruct *tss1;
  I1 *st,*desc=MSPrintF("%Q",tss->task_descriptor);
  st=MSPrintF("$MA+A,\"%08X\",\"Kill(0x%X);\r\",$",tss,tss,tss);
  PrintF("%*s%s $TX+SCX,\"%Q...\",16$ %08X %04X %04X %02X\r\n",
    indent,"",st,desc,
    TaskAllocatedMem(tss),
    tss->task_flags,tss->crt_flags,
    ExceptDepth(tss));
  Free(st);
  Free(desc);
  tss1=tss->next_child_tss;
  while (tss1!=tss+&tss->next_child_tss-&tss->next_sibling_tss) {
    TaskRepTask(tss1,indent+2);
    tss1=tss1->next_sibling_tss;
  }
}

public void TaskRep()
{
  U8 old_flags=GetFlags;
  Cli;
  TaskRepTask(adam_tss,0);
  SetFlags(old_flags);
}

SysBpt *FindBpt(TssStruct *tss,U1 *a,U8 flags=-1,BoolU4 remove=FALSE)
{//Removes
  SysBpt *result=NULL;
  U8 old_flags=GetFlags;
  SysBpt *tempb,*tempb1,*tempb2;
  Cli;
  tempb1=&tss->bpt_list;
  tempb=tss->bpt_list;
  while (tempb) {
    tempb2=tempb->next;
    if (tempb->address==a && tempb->flags & flags) {
      result=tempb;
      if (remove)
	tempb1->next=tempb2;
      else
	tempb1=&tempb->next;
    } else
      tempb1=&tempb->next;
    tempb=tempb2;
  }
  SetFlags(old_flags);
  return result;
}

public BoolU4 SBpt(TssStruct *tss,U1 *a,U8 flags=SBPTF_BPT)	//set Bpt
{
  U8 old_flags=GetFlags;
  BoolU4 result=TRUE;
  SysBpt *tempb;
  Cli;
  if (!(tempb=FindBpt(tss,a,flags,FALSE))) {
    tempb=MAlloc(sizeof(SysBpt),tss);
    tempb->address=a;
    tempb->b=*a;
    tempb->flags=flags;
    result=FALSE;
    tempb->next=tss->bpt_list;
    tss->bpt_list=tempb;
    if (tss==Fs)
      *a=0xCC;
  }
  SetFlags(old_flags);
  return result;
}

public BoolU4 RBpt(TssStruct *tss,U1 *a,U8 flags=-1)
{ //remove one Bpt
  U8 old_flags=GetFlags;
  BoolU4 result=FALSE;
  SysBpt *tempb;
  Cli;
  if (tempb=FindBpt(tss,a,flags,TRUE)) {
    result=TRUE;
    Free(tempb,tss);
  }
  SetFlags(old_flags);
  return result;
}

BoolU4 DBpt(TssStruct *tss,U1 *a,U8 flags=-1) //disable one Bpt
{ //used for continuing after a bpt
  U8 old_flags=GetFlags;
  BoolU4 result=FALSE;
  SysBpt *tempb;
  Cli;
  if (tempb=FindBpt(tss,a,flags,FALSE)) {
    Bts(&tempb->flags,SBPTf_DISABLE);
    result=TRUE;
  }
  SetFlags(old_flags);
  return result;
}

public void CBpt(TssStruct *tss,U8 flags=-1)  //clear Bpts
{
  U1 *a;
  U8 old_flags=GetFlags;
  SysBpt *tempb,*tempb1,*tempb2;
  Cli;
  tempb=tss->bpt_list;
  tempb1=&tss->bpt_list;
  while (tempb) {
    tempb2=tempb->next;
    if (tempb->flags & flags) {
      a=tempb->address;
      if (tss==Fs)
	*a=tempb->b;
      Free(tempb,tss);
      tempb1->next=tempb2;
    } else
      tempb1=&tempb->next;
    tempb=tempb2;
  }
  SetFlags(old_flags);
}

public BoolU4 IsTextFile(I1 *filename)
{
  return WildFileNameList(TEXT_FILE_MASK,filename);
}

public BoolU4 IsSourceFile(I1 *filename)
{
  return WildFileNameList(SOURCE_FILE_MASK,filename);
}

public BoolU4 IsCFile(I1 *filename)
{
  return WildFileNameList(C_FILE_MASK,filename);
}

public BoolU4 IsAsmFile(I1 *filename)
{
  return WildFileNameList(ASM_FILE_MASK,filename);
}


