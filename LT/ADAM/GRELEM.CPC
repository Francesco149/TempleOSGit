I8 PopUpGrElemType(BoolU4 new_picture)
{
  I8 i;
  Ltf *l=LtfNew;
  LtfPutS(l,"$MU,\"Color (4-bit)\" GRET_COLOR4$\r\n");
  LtfPutS(l,"$MU,\"Width\" GRET_WIDTH$\r\n");
  LtfPutS(l,"$MU,\"Point\" GRET_POINT$\r\n");
  LtfPutS(l,"$MU,\"Line\" GRET_LINE$\r\n");
  LtfPutS(l,"$MU,\"PolyLine\" GRET_POLYLINE$\r\n");
  LtfPutS(l,"$MU,\"PolyPoint\" GRET_POLYPOINT$\r\n");
  LtfPutS(l,"$MU,\"BSpline2\" GRET_BSPLINE2$\r\n");
  LtfPutS(l,"$MU,\"BSpline3\" GRET_BSPLINE3$\r\n");
  LtfPutS(l,"$MU,\"BSpline2 Closed\" GRET_BSPLINE2_CLOSED$\r\n");
  LtfPutS(l,"$MU,\"BSpline3 Closed\" GRET_BSPLINE3_CLOSED$\r\n");
  LtfPutS(l,"$MU,\"End\" GRET_END$\r\n");
  if (new_picture)
    LtfPutS(l,"$MU,\"Cancel\" -1$\r\n");
  LtfPutS(l,"\r\nNote: Right-Click to get back to this menu.\r\n"
	    "Press ESC to Exit, CTRL-Q to abort.\r\n");
  i=PopUpMenu(l);
  LtfDel(l);
  return i;
}

public I8 PopUpColor()
{
  I8 i;
  Ltf *l=LtfNew;
  for (i=0;i<16;i++)
    LtfPrintF(l,"$BM %d$$MU,\"________________\" %d$\r\n",i,i);
  LtfPutS(l,"$BM WHITE$$MU,\"DEFAULT\" -1$");
  i=PopUpMenu(l);
  LtfDel(l);
  return i;
}

public I8 PopUpWidth()
{
  I8 i;
  Ltf *l=LtfNew;
  for (i=0;i<16;i++)
    LtfPrintF(l,"$MU,\"%d\" %d$\r\n",i,i);
  i=PopUpMenu(l);
  LtfDel(l);
  return i;
}

I8 GrXOffsets[8]={-1,0,1,-1,1,-1,0,1},
   GrYOffsets[8]={-1,-1,-1,0,0,1,1,1};

U8 GrElemBaseSize(I8 type,BoolU4 queue=TRUE)
{
  U8 i=(queue) ? offset(GrElem.start):0;
  switch (type) {
    case GRET_COLOR4:
      i+=1+offset(GrElem.color4)-offset(GrElem.start);
      break;
    case GRET_COLOR24:
      i+=3+offset(GrElem.color24)-offset(GrElem.start);
      break;
    case GRET_WIDTH:
      i+=offset(GrElem.y1)-offset(GrElem.start);
      break;
    case GRET_POINT:
      i+=offset(GrElem.x2)-offset(GrElem.start);
      break;
    case GRET_LINE:
      i+=sizeof(GrElem)-offset(GrElem.start);
      break;
    case GRET_POLYLINE:
    case GRET_POLYPOINT:
    case GRET_BSPLINE2:
    case GRET_BSPLINE3:
    case GRET_BSPLINE2_CLOSED:
    case GRET_BSPLINE3_CLOSED:
      i+=offset(GrElem.y1)-offset(GrElem.start);
      break;
    case GRET_SHIFT:
      i+=offset(GrElem.x2)-offset(GrElem.start);
      break;
    case GRET_END:
      i+=offset(GrElem.x1)-offset(GrElem.start);
      break;
  }
  return i;
}

U8 GrElemSize(GrElem *tempg,BoolU4 queue=TRUE)
{
  U8 i=GrElemBaseSize(tempg->type,queue);
  switch (tempg->type) {
    case GRET_POLYLINE:
      i+=tempg->num<<1*sizeof(I4);
      break;
    case GRET_POLYPOINT:
      i+=sizeof(I4)<<1+(tempg->num*3+7)>>3;
      break;
    case GRET_BSPLINE2:
    case GRET_BSPLINE3:
    case GRET_BSPLINE2_CLOSED:
    case GRET_BSPLINE3_CLOSED:
      i+=tempg->num*sizeof(P3I4);
      break;
  }
  return i;
}


//If you do not enter a color or width into
//a GrElem, you can pass a color and width
//when you plot it.  "colorbase" is the color of
//the background you are drawing on.
public void GrElemsPlot(GrBitMap *base,I8 x,I8 y,I8 z,U1 *elems,U8 colorbase)
{
  GrElem *tempg=elems-offset(GrElem.start);
  U8 i,j;
  I8 x1,y1,x2,y2;
  I4 *ptr;
  I8 cur_sub_GrElem_num=0;
  P3I4 *p;
  while (tempg->type) {
    base->cur_sub_GrElem=cur_sub_GrElem_num++;
    switch (tempg->type) {
      case GRET_COLOR4:
	base->color=colorbase^tempg->color4;
	break;
      case GRET_COLOR24:
	base->color=colorbase^tempg->color24;
	break;
      case GRET_WIDTH:
	base->pen_width=tempg->width;
	break;
      case GRET_POINT:
	GrPlot3(base,tempg->x1+x,tempg->y1+y,0);
	break;
      case GRET_SHIFT:
	x+=tempg->x1;
	y+=tempg->y1;
	break;
      case GRET_LINE:
	GrLine3(base,tempg->x1+x,tempg->y1+y,0,tempg->x2+x,tempg->y2+y,0);
	break;
      case GRET_POLYLINE:
	ptr=&tempg->y1;
	x1=ptr[0];
	y1=ptr[1];
	for (i=1;i<tempg->num;i++) {
	  x2=ptr[i<<1];
	  y2=ptr[i<<1+1];
	  GrLine3(base,x1+x,y1+y,0,x2+x,y2+y,0);
	  x1=x2;y1=y2;
	}
	break;
      case GRET_POLYPOINT:
	ptr=&tempg->y1;
	x1=ptr[0];
	y1=ptr[1];
	ptr=ptr+sizeof(I4)<<1;
	for (i=0;i<tempg->num;i++) {
	  GrPlot3(base,x1+x,y1+y,0);
	  j=Bt(ptr,i*3)+Bt(ptr,i*3+1)<<1+Bt(ptr,i*3+2)<<2;
	  x1+=GrXOffsets[j];
	  y1+=GrYOffsets[j];
	}
	break;
      case GRET_BSPLINE2:
	p=&tempg->y1;
	for (i=0;i<tempg->num;i++) {
	  p[i].x+=x;
	  p[i].y+=y;
	}
	Gr2BSpline3(base,p,tempg->num,FALSE);
	for (i=0;i<tempg->num;i++) {
	  p[i].x-=x;
	  p[i].y-=y;
	}
	break;
      case GRET_BSPLINE3:
	p=&tempg->y1;
	for (i=0;i<tempg->num;i++) {
	  p[i].x+=x;
	  p[i].y+=y;
	}
	Gr3BSpline3(base,p,tempg->num,FALSE);
	for (i=0;i<tempg->num;i++) {
	  p[i].x-=x;
	  p[i].y-=y;
	}
	break;
      case GRET_BSPLINE2_CLOSED:
	p=&tempg->y1;
	for (i=0;i<tempg->num;i++) {
	  p[i].x+=x;
	  p[i].y+=y;
	}
	Gr2BSpline3(base,p,tempg->num,TRUE);
	for (i=0;i<tempg->num;i++) {
	  p[i].x-=x;
	  p[i].y-=y;
	}
	break;
      case GRET_BSPLINE3_CLOSED:
	p=&tempg->y1;
	for (i=0;i<tempg->num;i++) {
	  p[i].x+=x;
	  p[i].y+=y;
	}
	Gr3BSpline3(base,p,tempg->num,TRUE);
	for (i=0;i<tempg->num;i++) {
	  p[i].x-=x;
	  p[i].y-=y;
	}
	break;
    }
    tempg+=GrElemSize(tempg,FALSE);
  }
}

public void GrSetOrigin(GrElem *root,I8 dx,I8 dy,I8 dz)
{
  U8 i;
  I4 *ptr;
  P3I4 *p;
  GrElem *tempg=root->next;
  while (tempg!=root) {
    switch (tempg->type) {
      case GRET_POINT:
	tempg->x1+=dx;
	tempg->y1+=dy;
	break;
      case GRET_LINE:
	tempg->x1+=dx;
	tempg->y1+=dy;
	tempg->x2+=dx;
	tempg->y2+=dy;
	break;
      case GRET_POLYLINE:
	ptr=&tempg->y1;
	ptr[0]+=dx;
	ptr[1]+=dy;
	for (i=1;i<tempg->num;i++) {
	  ptr[i<<1]+=dx;
	  ptr[i<<1+1]+=dy;
	}
	break;
      case GRET_POLYPOINT:
	ptr=&tempg->y1;
	ptr[0]+=dx;
	ptr[1]+=dy;
	break;
      case GRET_BSPLINE2:
      case GRET_BSPLINE3:
      case GRET_BSPLINE2_CLOSED:
      case GRET_BSPLINE3_CLOSED:
	p=&tempg->y1;
	for (i=0;i<tempg->num;i++) {
	  p[i].x+=dx;
	  p[i].y+=dy;
	}
	break;
    }
    tempg=tempg->next;
  }
}

void GrPolyPointPlot(GrElem *root,I8 x,I8 y,I8 z)
{
  GrElem *tempg;
  tempg=MAllocZ(GrElemBaseSize(GRET_POINT));
  tempg->type=GRET_POINT;
  tempg->x1=x;
  tempg->y1=y;
  InsQue(tempg,root->last);
}

void GrElemsDel(GrElem *root)
{
  GrElem *tempg,*tempg1;
  tempg=root->next;
  while (tempg!=root) {
    tempg1=tempg->next;
    Free(tempg);
    tempg=tempg1;
  }
}

GrElem *GrElemsFromQueue(GrElem *root,U4 *size=NULL)
{
  U8 s,my_size=GrElemBaseSize(GRET_END,FALSE);
  GrElem *tempg,*result,*dst;

  tempg=root->next;
  while (tempg!=root) {
    my_size+=GrElemSize(tempg,FALSE);
    tempg=tempg->next;
  }
  result=MAlloc(my_size);
  dst=result;
  tempg=root->next;
  while (tempg!=root) {
    s=GrElemSize(tempg,FALSE);
    MemCpy(dst,&tempg->type,s);
    dst+=s;
    tempg=tempg->next;
  }
  *dst=GRET_END;
  if (size) *size=my_size;
  return result;
}

GrElem *GrElemsToQueue(GrElem *elems)
{
  U8 s;
  GrElem *result=MAllocZ(sizeof(GrElem)),
	 *tempg=elems-offset(GrElem.start),
	 *tempg1;
  result->next=result;
  result->last=result;
  while (tempg->type) {
    tempg1=MAlloc(GrElemSize(tempg,TRUE));
    s=GrElemSize(tempg,FALSE);
    MemCpy(&tempg1->type,&tempg->type,s);
    InsQue(tempg1,result->last);
    tempg+=s;
  }
  return result;
}

public I4 PopUpPickGrElem(GrElem *root)
{
  Ltf *l=LtfNew;
  GrElem *tempg;
  I4 cur_num=0;

  tempg=root->next;
  while (tempg!=root) {
    LtfPrintF(l,"$MU,\"%Z\",%d$\r\n",
      tempg->type,"ST_GRELEM_TYPES",cur_num++);
    tempg=tempg->next;
  }
  LtfPrintF(l,"$MU,\"END\",%d$\r\n",cur_num);
  cur_num=PopUpMenu(l);
  LtfDel(l);
  return cur_num;
}

#define GED_PICK_TEXT		1
#define GED_PICK_GRAPHICALLY	2
#define GED_SET_ORIGIN		3
#define GED_SHIFT_ORIGIN	4
#define GED_INSERT		5
#define GED_DELETE		6
#define GED_EDIT		7
#define GED_END			8
#define GED_CANCEL		-1

I8 PopUpGrElemsEditChoice()
{
  I8 i;
  Ltf *l=LtfNew;
  LtfPutS(l,"$MU,\"Pick from text\",GED_PICK_TEXT$\r\n");
  LtfPutS(l,"$MU,\"Pick graphically\",GED_PICK_GRAPHICALLY$\r\n");
  LtfPutS(l,"$MU,\"Set Origin\",GED_SET_ORIGIN$\r\n");
  LtfPutS(l,"$MU,\"Insert Shift Origin\",GED_SHIFT_ORIGIN$\r\n");
  LtfPutS(l,"$MU,\"Insert\",GED_INSERT$\r\n");
  LtfPutS(l,"$MU,\"Delete\",GED_DELETE$\r\n");
//  LtfPutS(l,"$MU,\"Edit\",GED_EDIT$\r\n");
  LtfPutS(l,"$MU,\"End\",GED_END$\r\n");
  LtfPutS(l,"$MU,\"Cancel\",GED_CANCEL$\r\n");
  i=PopUpMenu(l);
  LtfDel(l);
  return i;
}

GrElem *GrNumToQueue(GrElem *root,I8 num,I8 *x=NULL,I8 *y=NULL)
{
  I8 xx=0,yy=0;
  GrElem *result=root->next;
  while (result!=root && num--) {
    if (result->type==GRET_SHIFT) {
      xx+=result->x1;
      yy+=result->y1;
    }
    result=result->next;
  }
  if (x) *x=xx;
  if (y) *y=yy;
  return result;
}

void GrEditUpdate(LtfBinEntry *tempb,GrElem *root)
{
  BoolU4 old_preempt=Preempt(OFF);
  Free(tempb->data);
  tempb->data=GrElemsFromQueue(root,&tempb->size);
  Preempt(old_preempt);
}

I4 GrElOffset[9]={0,1,2,3,0,4,5,6,7};

BoolU4 GrElemsInsert(LtfBinEntry *tempb,I8 *cur_num,GrElem *root,I8 x,I8 y,BoolU4 new_picture)
{
  I8 i,j,cmd,x1,y1,x2,y2,x3,y3,p1,p2;
  I4 *ptr;
  U8 color=ROP_EQU^GR_BLACK^((Fs->text_attribute>>4)&15);
  BoolU4 old_ip_double=Bts(&Fs->crt_flags,CRTf_NO_DOUBLE_CLICK);
  I8 eletype=-2;
  GrElem root2,*tempg,*tempg1,*tempg2,*insert_point;
  U8 num;
  BoolU4 old_inhibit=ip_inhibit_win_operations;
  GrBitMap *base=GrNew(grbase);
  I8 width=1;
  P3I4 *p;

  insert_point=GrNumToQueue(root,*cur_num,&x1,&y1);
  x+=x1; y+=y1;

  ip_inhibit_win_operations=TRUE;
  while (TRUE) {
    GrClear;
    if (eletype==-2) {
      ip_inhibit_win_operations=FALSE;
      i=PopUpGrElemType(new_picture);
      if (i>=-1)
	eletype=i;
      ip_inhibit_win_operations=TRUE;
    }
    switch (eletype) {
      case GRET_COLOR4:
	ip_inhibit_win_operations=FALSE;
	i=PopUpColor;
	if (i>=0) {
	  color=ROP_EQU|i;
	  tempg=MAlloc(GrElemBaseSize(GRET_COLOR4));
	  tempg->type=GRET_COLOR4;
	  tempg->color4=color;
	  InsQue(tempg,insert_point->last);
	  GrEditUpdate(tempb,root);
	  *cur_num=*cur_num+1;
	}
	ip_inhibit_win_operations=TRUE;
	eletype=-2;
	color^=((Fs->text_attribute>>4)&15);
	base->color=color;
	break;
      case GRET_COLOR24:
	eletype=-2;
	break;
      case GRET_WIDTH:
	ip_inhibit_win_operations=FALSE;
	i=PopUpWidth;
	if (i>=1) {
	  width=i;
	  tempg=MAlloc(GrElemBaseSize(GRET_WIDTH));
	  tempg->type=GRET_WIDTH;
	  tempg->width=width;
	  InsQue(tempg,insert_point->last);
	  GrEditUpdate(tempb,root);
	  *cur_num=*cur_num+1;
	  base->pen_width=width;
	}
	ip_inhibit_win_operations=TRUE;
	eletype=-2;
	break;
    }
    if (eletype!=-2) {
      cmd=0;p1=0;p2=0;
      if (eletype!=GRET_END && eletype!=-1) {
	cmd=GetMsg(&p1,&p2,
	  (1<<MSG_KEY_DOWN)+(1<<MSG_IP_L_DOWN)+
	  (1<<MSG_IP_R_UP));
	if (cmd==MSG_IP_R_UP)
	  eletype=-2;
      }
      if (eletype==GRET_END || eletype==-1
	 || cmd==MSG_KEY_DOWN) {
	if (eletype==GRET_END || eletype==-1
	  || p1==CH_CTRLQ || p1==CH_ESC) {
	  AssignBit(&Fs->crt_flags,CRTf_NO_DOUBLE_CLICK,old_ip_double);
	  ip_inhibit_win_operations=old_inhibit;
	  GrDel(base);
	  return eletype==GRET_END || p1==CH_ESC;
	}
      } else {
	switch (eletype) {
	  case GRET_LINE:
	    x1=p1; y1=p2;
	    x2=p1; y2=p2;
	    do {
	      base->color=color&0xFFFFFF|ROP_OR;
	      GrLine3(base,x1,y1,0,x2,y2,0);
	      cmd=GetMsg(&p1,&p2,
  		(1<<MSG_IP_L_UP)+(1<<MSG_IP_MOVE));
	      base->color=color&0xFFFFFF|ROP_NAND;
	      GrLine3(base,x1,y1,0,x2,y2,0);
	      x2=p1; y2=p2;
	    } while (cmd!=MSG_IP_L_UP);
	    base->color=color&0xFFFFFF|ROP_EQU;
	    GrLine3(base,x1,y1,0,x2,y2,0);
	    tempg=MAlloc(GrElemBaseSize(GRET_LINE));
	    tempg->type=GRET_LINE;
	    tempg->x1=x1-x;
	    tempg->y1=y1-y;
	    tempg->x2=x2-x;
	    tempg->y2=y2-y;
	    InsQue(tempg,insert_point->last);
	    GrEditUpdate(tempb,root);
	    *cur_num=*cur_num+1;
	    break;
	  case GRET_POINT:
	    x1=p1; y1=p2;
	    base->color=color;
	    GrPlot3(base,x1,y1,0);

	    tempg=MAlloc(GrElemBaseSize(GRET_POINT));
	    tempg->type=GRET_POINT;
	    tempg->x1=x1-x;
	    tempg->y1=y1-y;
	    InsQue(tempg,insert_point->last);
	    GrEditUpdate(tempb,root);
	    *cur_num=*cur_num+1;
	    break;
	  case GRET_POLYLINE:
	    root2.next=&root2;
	    root2.last=&root2;
	    num=0;
	    x3=p1-x; y3=p2-y;
	    x1=p1; y1=p2;
	    x2=p1; y2=p2;
	    do {
	      do {
		base->color=color&0xFFFFFF|ROP_OR;
		GrLine3(base,x1,y1,0,x2,y2,0);
		cmd=GetMsg(&p1,&p2,
  		  (1<<MSG_IP_L_UP)+(1<<MSG_IP_MOVE)+
		  (1<<MSG_IP_R_UP));
		base->color=color&0xFFFFFF|ROP_NAND;
		GrLine3(base,x1,y1,0,x2,y2,0);
		x2=p1; y2=p2;
	      } while (cmd!=MSG_IP_L_UP && cmd!=MSG_IP_R_UP);
	      base->color=color&0xFFFFFF|ROP_EQU;
	      if (cmd==MSG_IP_L_UP) {
		GrLine3(base,x1,y1,0,x2,y2,0);
		tempg=MAlloc(GrElemBaseSize(GRET_POINT));
		tempg->type=GRET_POINT;
		tempg->x1=x2-x;
		tempg->y1=y2-y;
		InsQue(tempg,root2.last);
		x1=x2;y1=y2;
		num++;
	      }
	    } while (cmd!=MSG_IP_R_UP);
	    if (num) {
	      tempg2=MAllocZ(GrElemBaseSize(GRET_POLYLINE)+
		     (num+1)<<1*sizeof(I4));
	      ptr=&tempg2->y1;
	      tempg=root2.next;
	      ptr[0]=x3;
	      ptr[1]=y3;
	      ptr+=sizeof(I4)<<1;
	      for (i=0;i<num;i++) {
		tempg1=tempg->next;
		ptr[i<<1]=tempg->x1;
		ptr[i<<1+1]=tempg->y1;
		Free(tempg);
		tempg=tempg1;
	      }
	      tempg2->type=GRET_POLYLINE;
	      tempg2->num=num+1;
	      InsQue(tempg2,insert_point->last);
	      GrEditUpdate(tempb,root);
	      *cur_num=*cur_num+1;
	    }
	    break;
	  case GRET_POLYPOINT:
	    root2.next=&root2;
	    root2.last=&root2;
	    x3=p1-x; y3=p2-y;
	    x1=p1; y1=p2;
	    x2=p1; y2=p2;
	    base->color=color&0xFFFFFF|ROP_EQU;
	    do {
	      cmd=GetMsg(&p1,&p2,
  		(1<<MSG_IP_L_UP)+(1<<MSG_IP_MOVE));
	      x2=p1; y2=p2;
	      GrLine3(base,x1,y1,0,x2,y2,0);
	      Line(&root2,x1-x,y1-y,0,x2-x,y2-y,0,&GrPolyPointPlot);
	      x1=x2;y1=y2;
	      num++;
	    } while (cmd!=MSG_IP_L_UP);

	    num=0;
	    tempg=root2.next;
	    x1=x3;y1=y3;
	    while (tempg!=&root2) {
	      tempg1=tempg->next;
	      if (tempg->x1==x1 && tempg->y1==y1) {
		RemQue(tempg);
		Free(tempg);
	      } else {
		num++;
		x1=tempg->x1;
		y1=tempg->y1;
	      }
	      tempg=tempg1;
	    }

	    tempg2=MAllocZ(GrElemBaseSize(GRET_POLYPOINT)+
	      sizeof(I4)*2+(num*3+7)>>3);
	    ptr=&tempg2->y1;
	    tempg=root2.next;
	    ptr[0]=x3;
	    ptr[1]=y3;
	    ptr+=sizeof(I4)<<1;
	    x1=x3;y1=y3;
	    for (i=0;i<num;i++) {
	      tempg1=tempg->next;
	      j=GrElOffset[SignI8(tempg->x1-x1)+1+3*(SignI8(tempg->y1-y1)+1)];
	      x1=tempg->x1;y1=tempg->y1;
	      if (j&1)	Bts(ptr,i*3);
	      if (j&2)	Bts(ptr,i*3+1);
	      if (j&4)	Bts(ptr,i*3+2);
	      Free(tempg);
	      tempg=tempg1;
	    }
	    tempg2->type=GRET_POLYPOINT;
	    tempg2->num=num+1;
	    InsQue(tempg2,insert_point->last);
	    GrEditUpdate(tempb,root);
	    *cur_num=*cur_num+1;
	    break;
	  case GRET_BSPLINE2:
	  case GRET_BSPLINE3:
	  case GRET_BSPLINE2_CLOSED:
	  case GRET_BSPLINE3_CLOSED:
	    root2.next=&root2;
	    root2.last=&root2;
	    num=0;
	    x3=p1-x; y3=p2-y;
	    x1=p1; y1=p2;
	    x2=p1; y2=p2;
	    do {
	      do {
		base->color=color&0xFFFFFF|ROP_OR;
		GrLine3(base,x1,y1,0,x2,y2,0);
		cmd=GetMsg(&p1,&p2,
  		  (1<<MSG_IP_L_UP)+(1<<MSG_IP_MOVE)+
		  (1<<MSG_IP_R_UP));
		base->color=color&0xFFFFFF|ROP_NAND;
		GrLine3(base,x1,y1,0,x2,y2,0);
		x2=p1; y2=p2;
	      } while (cmd!=MSG_IP_L_UP && cmd!=MSG_IP_R_UP);
	      base->color=color&0xFFFFFF|ROP_EQU;
	      if (cmd==MSG_IP_L_UP) {
		GrLine3(base,x1,y1,0,x2,y2,0);
		tempg=MAlloc(GrElemBaseSize(GRET_POINT));
		tempg->type=GRET_POINT;
		tempg->x1=x2-x;
		tempg->y1=y2-y;
		InsQue(tempg,root2.last);
		x1=x2;y1=y2;
		num++;
	      }
	    } while (cmd!=MSG_IP_R_UP);
	    if (num) {
	      tempg2=MAllocZ(GrElemBaseSize(GRET_POLYLINE)+
		     (num+1)*sizeof(P3I4));
	      p=&tempg2->y1;
	      tempg=root2.next;
	      p[0].x=x3;
	      p[0].y=y3;
	      p+=sizeof(P3I4);
	      for (i=0;i<num;i++) {
		tempg1=tempg->next;
		p[i].x=tempg->x1;
		p[i].y=tempg->y1;
		Free(tempg);
		tempg=tempg1;
	      }
	      tempg2->type=eletype;
	      tempg2->num=num+1;
	      InsQue(tempg2,insert_point->last);
	      GrEditUpdate(tempb,root);
	      *cur_num=*cur_num+1;
	    }
	    break;
	}
      }
    }
  }
}

void EditInsertGraphic(Ltf *l,I8 x,I8 y)
{
  BoolU4 old_preempt=Preempt(OFF);
  LtfEntry *ll;
  LtfBinEntry *tempb;
  I8 cur_num=0;
  GrElem *root;
  tempb=MAllocZ(sizeof(LtfBinEntry));
  tempb->type=LTFBT_ELEMENT_GRAPH;
  tempb->size=GrElemBaseSize(GRET_END,FALSE);
  tempb->data=MAllocZ(tempb->size);
  ll=MAllocZ(sizeof(LtfEntry));
  ll->display=NewString("");
  ll->plain_text=MSPrintF("PI %d",l->cur_bin_num);
  ll->bin_num=l->cur_bin_num;
  tempb->num=l->cur_bin_num++;
  ll->type=LTFT_PICTURE;
  ll->flags=LTFLF_HAS_BIN;
  ll->bin_data=tempb;
  InsQue(tempb,l->bin_root.last);
  LtfInsert(l,ll);
  Preempt(old_preempt);
  root=GrElemsToQueue(tempb->data);
  if (!GrElemsInsert(tempb,&cur_num,root,x,y,TRUE)) {
    Preempt(OFF);
    RemQue(ll);
    Free(ll);
    Free(ll->display);
    Free(ll->plain_text);
    RemQue(tempb);
    Free(tempb->data);
    Preempt(old_preempt);
  }
  GrElemsDel(root);
}

public void LtfPutGrElem(Ltf *l,U1 *elems,U8 size)
{
  BoolU4 old_preempt=Preempt(OFF);
  LtfEntry *ll;
  LtfBinEntry *tempb;
  tempb=MAllocZ(sizeof(LtfBinEntry),l->mem_tss);
  tempb->type=LTFBT_ELEMENT_GRAPH;
  tempb->size=size;
  tempb->data=MAlloc(size,l->mem_tss);
  MemCpy(tempb->data,elems,size);
  ll=MAllocZ(sizeof(LtfEntry),l->mem_tss);
  ll->display=NewString("",l->mem_tss);
  ll->plain_text=MSPrintF("PI %d",l->cur_bin_num);  //TODO:mem_tss
  ll->bin_num=l->cur_bin_num;
  tempb->num=l->cur_bin_num++;
  ll->type=LTFT_PICTURE;
  ll->flags=LTFLF_HAS_BIN;
  ll->bin_data=tempb;
  InsQue(tempb,l->bin_root.last);
  LtfInsert(l,ll);
  Preempt(old_preempt);
}

public void PutGrElem(U1 *elems,U8 size)
{
  Ltf *l=Fs->cur_ltf;
  if (l)
    LtfPutGrElem(l,elems,size);
}

void EditExistingGraphic(Ltf *l,I8 x,I8 y)
{
  BoolU4 *old_preempt=Preempt(OFF);
  LtfEntry *ll=l->cur_entry;
  LtfBinEntry *tempb=ll->bin_data;
  I8 i,cur_num=0,cmd,p1,p2,old_size=tempb->size,xx,yy;
  GrElem *cur_elem,*old_GrElem=tempb->data,
    *root=GrElemsToQueue(old_GrElem),*tempg,*insert_point;
  BoolU4 old_inhibit=ip_inhibit_win_operations;
  BoolU4 old_ip_double=Bt(&Fs->crt_flags,CRTf_NO_DOUBLE_CLICK);
  tempb->data=MAllocIdentical(old_GrElem);
  Preempt(old_preempt);
  do {
    i=PopUpGrElemsEditChoice;
    switch (i) {
      case GED_PICK_TEXT:
	cur_num=PopUpPickGrElem(root);
	break;
      case GED_PICK_GRAPHICALLY:
	l->cur_GrElem=tempb->data;
	GetMsg(&p1,&p2,1<<MSG_IP_L_UP);
	cur_num=l->cur_sub_GrElem;
	l->cur_GrElem=NULL;
	break;
      case GED_SET_ORIGIN:
	GetMsg(&p1,&p2,1<<MSG_IP_L_UP);
	GrSetOrigin(root,x-p1,y-p2,0);
	GrEditUpdate(tempb,root);
	break;
      case GED_SHIFT_ORIGIN:
	ip_inhibit_win_operations=TRUE;
	Bts(&Fs->crt_flags,CRTf_NO_DOUBLE_CLICK);
	insert_point=GrNumToQueue(root,cur_num);
	tempg=MAlloc(GrElemBaseSize(GRET_SHIFT));
	tempg->type=GRET_SHIFT;
	tempg->x1=0;
	tempg->y1=0;
	InsQue(tempg,insert_point->last);
	GetMsg(&p1,&p2,1<<MSG_IP_L_DOWN);
	xx=p1; yy=p2;
	do {
	  cmd=GetMsg(&p1,&p2,
  	    (1<<MSG_IP_L_UP)+(1<<MSG_IP_MOVE));
	  tempg->x1=p1-xx;
	  tempg->y1=p2-yy;
	  GrEditUpdate(tempb,root);
	} while (cmd!=MSG_IP_L_UP);
	AssignBit(&Fs->crt_flags,CRTf_NO_DOUBLE_CLICK,old_ip_double);
	ip_inhibit_win_operations=old_inhibit;
	break;
      case GED_INSERT:
	GrElemsInsert(tempb,&cur_num,root,x,y,FALSE);
	break;
      case GED_DELETE:
	cur_elem=GrNumToQueue(root,cur_num);
	if (cur_elem!=root) {
	  RemQue(cur_elem);
	  Free(cur_elem);
	  GrEditUpdate(tempb,root);
	}
	break;
      case GED_EDIT:
	break;
    }
  } while (i!=GED_CANCEL && i!=GED_END);
  Preempt(OFF);
  if (i==GED_END)
    Free(old_GrElem);
  else {
    Free(tempb->data);
    tempb->data=old_GrElem;
    tempb->size=old_size;
  }
  Preempt(old_preempt);
  GrElemsDel(root);
}
