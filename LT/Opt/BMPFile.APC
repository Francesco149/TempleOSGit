#help_index "Graphics/Windows BMP Files"

//This provides support for Window's BMP files.

class BMPFile
{
  U16 type;
  U32 file_size;
  U32 reserved;
  U32 data_offset;
 
  U32 header_size;
  U32 width;
  U32 height;
  U16 planes;
  U16 bit_cnt;
  U32 compression;
  U32 image_size;
  U32 x_pixels_per_meter;
  U32 y_pixels_per_meter;
  U32 colors_used;
  U32 important_colors;

  U0 end;

  BGREntry palette[16];
};


BMPFile *BMPFileNew(U64 width,U64 height,U64 bits)
{
  BMPFile *r;
  U64 size;
  if (bits==24)
    size=offset(BMPFile.end)+
	 width*height*sizeof(RGBEntry);
  else if (bits==4)
    size=offset(BMPFile.end)+
	 width*height>>1+16*sizeof(BGREntry);
  else {
    PutS("Format Not Supported.\r\n");
    return NULL;
  }
  r=CAlloc(size);
  r->type=0x4D42;
  r->planes=1;
  r->file_size=size;
  r->data_offset=offset(BMPFile.end);
  r->header_size=offset(BMPFile.end)-
		 offset(BMPFile.header_size);
  r->width=width;
  r->height=height;
  if (bits==24) {
    r->bit_cnt=32;
    r->image_size=width*height<<2;
  } else {
    r->bit_cnt=4;
    r->image_size=width*height>>1;
    r->data_offset+=16*sizeof(BGREntry);
    GetVGAPalette4(r->palette);
  }
  return r;
}


public BMPFile *BMPFile4To(GrBitMap *base)
{
//To Windows 4 bit BMP
  U8 *src,j;
  U64 wd=base->width_internal>>3,pl=wd*base->height;
  U8 *img=base->body;
  BMPFile *r=BMPFileNew(base->width,base->height,4);
  I64 x,y,i;
  U8 *rgb;
  rgb=r><(U8 *)+r->data_offset;
  for (y=base->height-1;y>=0;y--) {
    src=y*wd+img;
    for (x=0;x<wd;x++) {
      j=*src++;
      for (i=1;i<0x100;i<<=1) {
	if (i&j)
	  *rgb |= 0x10;
	i<<=1;

	if (i&j)
	  *rgb |= 0x01;
	rgb++;
      }
    }
  }

  rgb=r><(U8 *)+r->data_offset;
  for (y=base->height-1;y>=0;y--) {
    src=y*wd+img+pl;
    for (x=0;x<wd;x++) {
      j=*src++;
      for (i=1;i<0x100;i<<=1) {
	if (i&j)
	  *rgb |= 0x20;
	i<<=1;

	if (i&j)
	  *rgb |= 0x02;
	rgb++;
      }
    }
  }

  rgb=r><(U8 *)+r->data_offset;
  for (y=base->height-1;y>=0;y--) {
    src=y*wd+img+pl<<1;
    for (x=0;x<wd;x++) {
      j=*src++;
      for (i=1;i<0x100;i<<=1) {
	if (i&j)
	  *rgb |= 0x40;
	i<<=1;

	if (i&j)
	  *rgb |= 0x04;
	rgb++;
      }
    }
  }

  rgb=r><(U8 *)+r->data_offset;
  for (y=base->height-1;y>=0;y--) {
    src=y*wd+img+pl*3;
    for (x=0;x<wd;x++) {
      j=*src++;
      for (i=1;i<0x100;i<<=1) {
	if (i&j)
	  *rgb |= 0x80;
	i<<=1;

	if (i&j)
	  *rgb |= 0x08;
	rgb++;
      }
    }
  }
  return r;
}

public BMPFile *BMPFile24To(GrBitMap *base)
{
//To Windows 24 bit BMP
  U8 *src,j;
  U64 wd=base->width_internal>>3,pl=wd*base->height;
  U8 *img=base->body;
  BMPFile *r=BMPFileNew(base->width,base->height,24);
  I64 x,y,i;
  RGBEntry *rgb;

  rgb=r><(U8 *)+r->data_offset;
  for (y=base->height-1;y>=0;y--) {
    src=y*wd+img;
    for (x=0;x<wd;x++) {
      j=*src++;
      for (i=1;i<0x100;i<<=1) {
	if (i&j)
	  rgb->r=0x7F;
	rgb><(U8 *)+=4;
      }
    }
  }

  rgb=r><(U8 *)+r->data_offset;
  for (y=base->height-1;y>=0;y--) {
    src=y*wd+img+pl;
    for (x=0;x<wd;x++) {
      j=*src++;
      for (i=1;i<0x100;i<<=1) {
	if (i&j)
	  rgb->g=0x7F;
	rgb><(U8 *)+=4;
      }
    }
  }

  rgb=r><(U8 *)+r->data_offset;
  for (y=base->height-1;y>=0;y--) {
    src=y*wd+img+pl<<1;
    for (x=0;x<wd;x++) {
      j=*src++;
      for (i=1;i<0x100;i<<=1) {
	if (i&j)
	  rgb->b=0x7F;
	rgb><(U8 *)+=4;
      }
    }
  }

  rgb=r><(U8 *)+r->data_offset;
  for (y=base->height-1;y>=0;y--) {
    src=y*wd+img+pl*3;
    for (x=0;x<wd;x++) {
      j=*src++;
      for (i=1;i<0x100;i<<=1) {
	if (i&j) {
	  if (rgb->r) rgb->r=0xFF;
	  if (rgb->g) rgb->g=0xFF;
	  if (rgb->b) rgb->b=0xFF;
	}
	rgb><(U8 *)+=4;
      }
    }
  }
  return r;
}

public U64 BMPFileWrite(U8 *filename,GrBitMap *base,U64 bits=4)
{ //Window's BMP Files
  U64 size;
  BMPFile *r;
  if (bits==4)
    r=BMPFile4To(base);
  else if (bits==24)
    r=BMPFile24To(base);
  else {
    PutS("Format Not Supported.\r\n");
    return 0;
  }
  size=r->file_size;
  FileWrite(filename,r,r->file_size);
  Free(r);
  return size;
}

U8 *BMPFilePaletteNew(BMPFile *r)
{
  I64 i,j,best,score,best_score;
  U8 *result=CAlloc(16*sizeof(U8));
  BGREntry palette[16];
  GetVGAPalette4(palette);
  for (i=0;i<16;i++) {
    best=i;
    best_score=MAX_I64;
    for (j=0;j<16;j++) {
      score=SqrI64(r->palette[i].r-palette[j].r)+
	  SqrI64(r->palette[i].g-palette[j].g)+
	  SqrI64(r->palette[i].b-palette[j].b);
      if (score<best_score) {
	best=j;
	best_score=score;
      }
    }
    result[i]=best;
  }
  return result;
}

U8 ms_paint_palette[16]={0,4,2,6,1,5,3,8,7,12,10,14,9,13,11,15};

public GrBitMap *BMPFileRead(U8 *filename,BoolI8 use_ms_paint_palette=FALSE)
{ //Window's BMP Files
  I64 i,j;
  U8 *palette_map,*ptr1;
  BMPFile *r;
  GrBitMap *result=NULL;
  if (ptr1=FileRead(filename)) {
    r=ptr1;
    if (0<r->width<MAX_I32 && 0<r->height<MAX_I32) {
      result=GrNew(BMT_COLOR4,r->width,r->height);
      ptr1+=r->data_offset;
      if (r->bit_cnt==4) {
	if (use_ms_paint_palette)
	  palette_map=ms_paint_palette;
	else
	  palette_map=BMPFilePaletteNew(r);
	for (i=r->height-1;i>=0;i--)
	  for (j=0;j<(r->width+7)&-8;) {
	    result->color=palette_map[*ptr1&15];
	    GrPlot(result,j+1,i);
	    result->color=palette_map[*ptr1>>4];
	    GrPlot(result,j,i);
	    ptr1++;
	    j+=2;
	  }
	if (!use_ms_paint_palette)
	  Free(palette_map);
      } else {
	PutS("Format Not Supported.\r\n");
	GrDel(result);
	result=NULL;
      }
    } else
      PutS("Invalid BMP File\r\n");
    Free(r);
  }
  return result;
}

#help_index "Graphics/Windows BMP Files;Graphics/Screen"

public U64 BMPFileCaptureScreen(U8 *filename,U64 bits=4)
{
  GrBitMap *base=GrCaptureScreen;
  U64 size=BMPFileWrite(filename,base,bits);
  GrDel(base);
  return size;
}

#help_index ""
