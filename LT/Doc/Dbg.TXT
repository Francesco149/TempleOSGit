* I use [C:/LT/OSMain/Adam1b.HPZ,43] progress1-[C:/LT/OSMain/Adam1b.HPZ,52]
progress4 for debugging because they show on the wallpaper.  
They're just global integer vars.

* While debugging, you specify addresses of assembly  routines with just the 
label, as in _MALLOC+0x20.  You specify C+ function names with & before 
functions as in &PrintF+0x10.

* [C:/LT/OSMain/Dbg1a.CPZ,431] Dbg() will enter debugger or you might enter
the debugger through a fault.  
You might place a call in your code at fatal error points to enter the 
debugger.  If you see a stk dump, record the label+offset and unassemble, 
[C:/LT/Compiler/Unassembler.CPZ,851] U()
, possibly when not in the debugger, find the offset and follow the link to 
source code.  [C:/LT/OSMain/Dbg1a.CPZ,386] DbgExit() might exit the debugger
and retain the task or [C:/LT/OSMain/Task1a.CPZ,1] Exit() 
might exit debugger, but you will lose the task.

* You can use [C:/LT/OSMain/TaskCmd.CPZ,304] AdamLog() to send text to the
Adam task window.  It works like 
[C:/LT/OSMain/Str1a.CPZ,2509] PrintF().  I never use this.  Instead I use
[C:/LT/OSMain/Dbg1a.CPZ,182] DbgNum().

* [C:/LT/OSMain/Dbg1a.CPZ,266] D() [C:/LT/Adam/Ltf/LtfMain.APZ,704] LtfD() to
do 16 column hex dump mem with numbering from zero.  With 
[C:/LT/Adam/Ltf/LtfMain.APZ,704] LtfD the values are updated continually and
you can alter mem by editing.

* [C:/LT/OSMain/Dbg1a.CPZ,296] Dm() [C:/LT/Adam/Ltf/LtfMain.APZ,688] LtfDm()
to do 16 column hex dump mem with addresses showing.

* [C:/LT/OSMain/Dbg1a.CPZ,302] Da() to do one column address dump (for stk,
etc.) with symbolic addresses.

* [C:/LT/OSMain/Dbg1a.CPZ,334] Dr() dumps registers.  You can display and
modify registers in the debugger 
with var-like labels, RAX, RBX, etc.  See [C:/LT/OSMain/Dbg1a.CPZ,350]
DefineRegs().

* [C:/LT/Compiler/Unassembler.CPZ,851] U(&FunName+offset) to unassemble mem
or [C:/LT/Adam/Dbg2a.APZ,241] Uf("FunName") to unassemble a 
function.

* [C:/LT/Adam/Profiler.APZ,45] ProfBin(),[C:/LT/Adam/Profiler.APZ,80]
ProfAll() and [C:/LT/Adam/Profiler.APZ,106] ProfRep() provide code profiling.
 See 
[::/LT/Demo/AutoFile/Demo2.AUZ] ::/LT/Demo/AutoFile/Demo2.AUZ (This is an
[::/LT/Doc/Glossary.TXZ,AutoFile] AutoFile.)

* If you recompile OSMain with [C:/LT/Adam/Boot/InsBoot.APZ,157]
InstallBoot(), you can modify the handler for 
faults here: [C:/LT/OSMain/Dbg1a.CPZ,480] Fault2().

* Use [C:/LT/OSMain/Dbg1a.CPZ,182] DbgNum(), [C:/LT/OSMain/Dbg1a.CPZ,163]
DbgStr() and [C:/LT/OSMain/Dbg1a.CPZ,216] DbgAdd() to print debug info
bypassing the window 
framework.  You pass these routines a count in milliseconds for how long it 
should be displayed.  You can use [C:/LT/OSMain/Misc1a.CPZ,324] Raw(TRUE) to
make all output bypass the 
window framework.  The WinMgr runs on core0 and will overwrite raw text from 
other cores when it updates the screen.

* Use [C:/LT/OSMain/Misc1a.CPZ,305] SysDbg() to set a flag which you can read
with [C:/LT/OSMain/Misc1a.CPZ,311] IsSysDbg() when you wish 
to trigger some debug activity.  It's just a handy simple flag, nothing fancy.

* Use [C:/LT/OSMain/Misc1a.CPZ,315] SysDeterministic() to set a flag which
tries to keep the system 
deterministic for debugging.  [C:/LT/OSMain/Misc1a.CPZ,320]
IsSysDeterministic().  There is a Deterministic 
OSMain config flag.

* There are flags for various trace options that can help debugging when
there 
are compiler bugs.  Often, you place them in #exe{} blocks.
  
[C:/LT/Compiler/Directives.CPZ,63] Echo() turns on or off raw data going into
  the lexical analyzer.

[C:/LT/Compiler/Directives.CPZ,54] LTrace() shows the tokens coming out of
  the lexical analyzer.

[C:/LT/Compiler/Directives.CPZ,49] CTrace() unassembles code generated from
  the C+ compiler.

[C:/LT/Compiler/Directives.CPZ,31] PTrace() shows intermediate code comming
  out of the first stage of the 
compiler (it's not 100% valid because it hasn't been fixed-up).

[C:/LT/Compiler/Directives.CPZ,36] OTrace() shows intermediate code
  coming-out after optimization.  
[C:/LT/Compiler/Directives.CPZ,41] OPassTraceMask() ctrls which passes are
  displayed.


* There is a heap check utility which can find leaks.  Use
[C:/LT/Adam/HeapLog.APZ,121] HeapLog(), and 
[C:/LT/Adam/HeapLog.APZ,80] HeapLogRep().  It's a really simple program which
intercepts [C:/LT/OSMain/Memory.CPZ,956] MAlloc() and 
[C:/LT/OSMain/Memory.CPZ,950] Free().  You can customize the code to find
other heap issues.

* You can define functions for <CTRL-ALT-letter> keys, but they must operate 
in a interrupt environment or in the window mgr when in ques kbd msgs.  You 
can do [C:/LT/OSMain/Misc1a.CPZ,324] Raw() output.  Search for
[C:/LT/OSMain/OSGlbls.CPZ,40] fp_ctrl_alt_let_cbs[] and look at the code.  
They take scancode as an arg.

* If you recompile OSMain with [C:/LT/Adam/Boot/InsBoot.APZ,157]
InstallBoot(), you can set the MemInit, option 
to initialize memory to a value at boot, the HeapInit option to cause mem 
allocated off the heap to be initialized or VarInit option so both global and 
local vars will be initialized to a value.  Pick a non-zero value to discover 
uninitialized var bugs.  You can set [C:/LT/OSMain/Adam1b.HPZ,129]
sys_var_init_flag, and 
[C:/LT/OSMain/Adam1b.HPZ,125] sys_heap_init_flag directly after booting.  You
can also use the ProtectLow 
option to discover NULL dereferences.
