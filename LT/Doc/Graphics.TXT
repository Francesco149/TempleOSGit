                              Graphics Overview











 <1> (image)

































* See [C:/LT/Adam/Gr/GrScreen.APZ,724] GrUpdateScreen() and
[C:/LT/Adam/Gr/GrScreen.APZ,370] GrUpdateWins().  Only tasks on core0 are
allowed to 
have windows.  There is one window per task and no child windows.

* [C:/LT/OSMain/Adam1a.HPZ,3480] GrDCs (device contexts) are a data type for
controlling graphics on the 
screen or graphics in mem, not on the screen.  The device context structure 
has pen width and color associated with it, so you use
[C:/LT/Adam/Gr/GrDC.APZ,23] GrDCAlias() to create 
your own structure, with its own color and pen width.  Free it with
[C:/LT/Adam/Gr/GrDC.APZ,76] GrDCDel() 
when finished.

* [C:/LT/Adam/Gr/GrScreen.APZ,5] gr_dc is a global var for a bitmap redrawn
each refresh and placed on the 
screen.  You use an alias [C:/LT/OSMain/Adam1a.HPZ,3480] GrDC.  You change
the "Fs->draw_it" var to point to 
your "DrawIt()" which gets called each screen refresh.  You draw everything
in 
the window over and over again.  See [::/LT/Demo/Graphics/Box.CPZ]
::/LT/Demo/Graphics/Box.CPZ.
 
* gr_dc2 is a bitmap for persistent data on the screen, not needing to be 
redrawn.  You create an alias for this by using [C:/LT/Adam/Gr/GrDC.APZ,23]
GrDCAlias() and work with 
that.  It's slightly simpler than using the global var
[C:/LT/Adam/Gr/GrScreen.APZ,5] gr_dc, but it's not as 
good because changes aren't syncronized to the screen update and window 
borders are not enforced when windows are moved.  See 
[::/LT/Demo/Graphics/DotNet.CPZ] ::/LT/Demo/Graphics/DotNet.CPZ.

* Use [C:/LT/Adam/Gr/GrDC.APZ,42] GrDCNew() to create a mem bitmap which can
be used to work off-screen 
and which can be [C:/LT/Adam/Gr/GrBitMap.APZ,76] GrDCBloted onto the
screen.  If you set brush member of GrDC 
to another GrDC, all the graphic routines will
[C:/LT/Adam/Gr/GrBitMap.APZ,76] GrDCBlot() the brush instead of 
[C:/LT/Adam/Gr/GrPrimatives.APZ,47] GrPlot().  See
[::/LT/Demo/Graphics/Blot.CPZ] ::/LT/Demo/Graphics/Blot.CPZ.

* There are various flavors of line and point plotting
routines.  [C:/LT/Adam/Gr/GrPrimatives.APZ,420] GrLine() and 
[C:/LT/Adam/Gr/GrPrimatives.APZ,47] GrPlot() are the simplest.  The others
allow 3 dimensional graphics and 
rotations.

* See [::/LT/Doc/Transform.TXZ] ::/LT/Doc/Transform.TXZ for adding a
transformation.

* Set [C:/LT/OSMain/Adam1a.HPZ,3448] DCF_SYMMETRY in the
[C:/LT/OSMain/Adam1a.HPZ,3480] GrDC.flags and call
[C:/LT/Adam/Gr/MathGr.APZ,374] GrSetSymmetry() or 
[C:/LT/Adam/Gr/MathGr.APZ,396] GrSetSymmetry3().  This will plot a mirror
image in addition to the primary 
image.  Set [C:/LT/OSMain/Adam1a.HPZ,3452] DCF_JUST_MIRROR to plot just the
image, but this required 
[C:/LT/OSMain/Adam1a.HPZ,3448] DCF_SYMMETRY to be set at the same
time.  Note: You can only have one symmetry 
active at a time including in [C:/LT/Adam/Gr/Gr.APZ,55] GrSprites.

* Use the resource editor, <CTRL-R>, to create a picture-like thing called a 
sprite that can be plotted with [C:/LT/Adam/Gr/GrSpritePlot.APZ,27]
GrSpritePlot3().  Use $IB,"",1$ in a src 
program to insert the addr of picture #1.  After creating a picture with <CTRL
-R> in your src code, toggle to plain text with <CTRL-T> and check it's num.  
Then, make an assignment to a ptr var with $IB,"",n$ as the value. See 
[::/LT/Demo/Graphics/GrSprite1.CPZ] ::/LT/Demo/Graphics/GrSprite1.CPZ and
[::/LT/Demo/Graphics/GrSprite2.CPZ] ::/LT/Demo/Graphics/GrSprite2.CPZ.)  The 
origin (zero point) for a sprite is defined by the cursor location when you 
press <CTRL-R>.  The "x", "y" and "z" values you pass to
[C:/LT/Adam/Gr/GrSpritePlot.APZ,27] GrSpritePlot3() shift 
it around.  You can edit a Graphic Element by clicking the cursor on it and 
pressing <CTRL-R> again.

* There is a mechanism built-in for generating motion based on differential 
equations, which allows realistic physics.  You create an
[C:/LT/OSMain/Adam1a.HPZ,235] Ode struct with 
[C:/LT/Adam/MathOde.APZ,42] OdeNew(), passing it the num of vars in the state
vect.  For realistic 
physics, you usually have 2 state vars for each dimension (for each mass) 
because motion is governed by f=ma which is a 2nd order equation.  The two 
states are pos and velocity and to solve these you need to supply the 
derivative of pos and velocity.  The derivative of pos is usually simply the 
current velocity and the derivative of velocity is the acceleration (the sum 
of forces on a mass divided by mass).  To help provide meaningful names for 
values in the state vect, you can create an [C:/LT/OSMain/Adam1a.HPZ,192]
Order2D3 ptr and point it to a 
mass in the state vect.  Six elements in the state vect are required for each 
mass.

See [Math/Ode] Math/Ode.
See [::/LT/Demo/GameStarters/Rocks.CPZ] ::/LT/Demo/GameStarters/Rocks.CPZ.

* There are several [C:/LT/OSMain/Adam1a.HPZ,2874] raster operations
available.  They go in bits 8-11 of the 
dc->color member var.

* [C:/LT/OSMain/Adam1a.HPZ,2876] ROP_COLLISION is special.  It counts the num
of pixels drawn on 
non-background locations.  Using [C:/LT/OSMain/Adam1a.HPZ,2876] ROP_COLLISION
with vector [C:/LT/Adam/Gr/Gr.APZ,55] GrSprite's is 
tricky because overlapping pixels from lines in the [C:/LT/Adam/Gr/Gr.APZ,55]
GrSprite register as 
collisions.  You can either work with a nonzero count or convert your 
[C:/LT/Adam/Gr/Gr.APZ,55] GrSprite to a bitmap if your subelements draw on
top of each other.  Be sure 
to set ->bkcolor before using [C:/LT/OSMain/Adam1a.HPZ,2876]
ROP_COLLISION.  See 
[::/LT/Demo/Graphics/PixelCollision.CPZ]
::/LT/Demo/Graphics/PixelCollision.CPZ, [::/LT/Demo/GameStarters/Rocks.CPZ]
::/LT/Demo/GameStarters/Rocks.CPZ and 
[::/LT/Apps/Timeout/Timeout.CPZ] ::/LT/Apps/Timeout/Timeout.CPZ.
 
* The ->dither_probability member of [C:/LT/OSMain/Adam1a.HPZ,3480] GrDC is a
U16 used to statistically 
select between two colors.  See [::/LT/Demo/Graphics/Shading.CPZ]
::/LT/Demo/Graphics/Shading.CPZ.  It works 
with most graphic routines, but not those with pens.
