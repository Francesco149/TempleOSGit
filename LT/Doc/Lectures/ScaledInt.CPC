/*

You may wonder why I do scaled integer arithmetic in the graphics routines.  
The transformation matrix in a [C:/LT/OSMain/Adam1a.HPZ,3446] GrBitMap, r, is stored as 8-byte integers 
shifted 32 bits left to allow fractions.  This is faster than floating point 
(double) arithmetic, but less accurate.

*/

#define SAMPLE_SIZE	100000000

I4 coordinates[65536];

void TimeIns()
{
  U8 start1,end1,start2,end2,overhead_time,test_time;
  double reg d1;
  I8 reg i,reg temp,reg d2,reg sum;

  //Set-up some sample coordinates
  for (i=0;i<65536;i++)
    coordinates[i]=RandU4;

  Preempt(OFF);

//Measure Loop Overhead
  start1=GetTimeStamp;
  for (i=0;i<SAMPLE_SIZE;i++) {
  }
  end1=GetTimeStamp;
  overhead_time=end1-start1;

//Measure double arithmetic
  d1=Sin(1.0);
  sum=0;
  start2=GetTimeStamp;
  for (i=0;i<SAMPLE_SIZE;i++)
	  sum+=d1*coordinates[i&65535];
  coutln "Double Arithmetic Sum   :",sum;
  end2=GetTimeStamp;
  test_time=end2-start2;
  PrintF("Double Arithmetic Cycles: %10.5f\r\n",
    (test_time-overhead_time)*1.0/SAMPLE_SIZE);


//Measure scaled integer arithmetic
  d2=Sin(1.0)*0x100000000;
  sum=0;
  start2=GetTimeStamp;
  for (i=0;i<SAMPLE_SIZE;i++) {
	  temp=d2*coordinates[i&65535];
    sum+=temp.i4[1];
  }
  end2=GetTimeStamp;
  test_time=end2-start2;
  coutln "Scaled Integer Sum      :",sum;
  PrintF("Scaled Integer Cycles   :%10.5f\r\n",
    (test_time-overhead_time)*1.0/SAMPLE_SIZE);

  Preempt(ON);
}

TimeIns;


