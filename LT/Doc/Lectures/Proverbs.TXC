                                   Proverbs

Writing your own code is more fun then modifying someone else's.  Sadly, I 
heard 90% of programmers work on maintaining code.  One good thing about 
looking at other people's code is it's a good way to learn -- you can learn 
what to and what NOT to do.

Code written by one person is less redundant than code written by a team 
because one person knows when he is reinventing the wheel.  It is more 
vertical, meaning deeper levels of subroutines.

When working on other people's code, you tend to be defensive, using caution 
about uncertain items and this adds unnecessary code.

Documentation which is out-of-date is worse than no documentation.  With 
LoseThos, I tried to keep documentation right by code.

If you call common low-level routines, there is a potential for huge added 
functionality with changes to the low level routines, benefitting
everything.  
Imagine modifying a file choosing dialog.

Not all features are good to use.  I've seen cases where people use macro 
functions (#define) to make C code look like C++ code.  It becomes one-more 
layer you have to look-up to understand.  An advantage of nonvertical coding 
is readibility.  It is possible to get carried away with nonstandard library 
routines.

One mentor discouraged using abbreviations.  One advantage of nonabreviated 
labels is there's no uncertainty on how to spell them.  Typing is never what 
slows you down, except maybe at the command line.  Uncertainty is what slow 
you down.

One mentor always put "temp" on the beginning of local variables -- "tempd" 
instead of just "d".  The reason is probably for text searches.  I've
somewhat 
eliminated this need with the "whole label" search feature.

[C:/LT/Opt/Grep.APZ,161] Grep() is my best friend.  I use a wrapper function
[C:/LT/Accts/TAD/Adam3eWrappers.APZ,8] F().

It's easier to write a command-line interface than a GUI one and if it's for 
personal use, why not?

On a modern home computer, the only things which take significant memory are 
disk cache, graphics and sound.  Code related items do not.  If you had a 
million lines of code and stored an 8-byte value telling where each line was 
located, that would be 8 Meg.  I have 2Gig, so that would be 0.4 %.  
Structures for classes and functions amount to nothing.

A home computer doesn't really need a big disk cache.  How often do you
listen 
to the same multimedia items more than once?  If you have a server for a 
database, sure you need disk cache.
