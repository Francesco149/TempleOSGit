                                 Introduction

There's no point being an inferior immitation of Windows.  I picked a niche 
and specialized -- **programming as entertainment**.  I chose simplicity 
intentionally over conventional approaches.  This is not a platform for
games, 
but a platform for writing games.  Hobbiest programmers are a higher priority 
than commercial developers.

I have no plans to support multimedia or the Internet.  This is a
supplemental 
operating system (like supplemental insurance).  Duel boot and do that stuff 
on your primary operating system.  There's no reason to reinvent the wheel 
and, unlike what I've done in LoseThos , I see nothing I could add to a 
browser or multimedia player -- you can't change the file formats.

LoseThos has no networking and will never have networking so there's no need 
for security.  Did an Apple II or Commodore 64 have security?  I mention
these 
classic systems because the intended usage of LoseThos is similar, only 
modern. 

LoseThos is not for desktop publishing or word processing.  It's document 
format is designed for interaction on the screen and does not lend itself to 
printing.  Click here for a hint <-This text is hidden until you click on
it.>.

When I started programming in 1981 on an Apple II, it took two lines of code 
to draw a line on the screen and it could be typed from the command line or
in 
a BASIC program:

HGR
HLINE 1,1 TO 30,30

Programming is far more intimidating, now.  It's not uncommon for a "Hello 
World" application to take 50 lines of code.

Most game development packages for amateurs are like fitting a square peg in
a 
round hole.  People want good looking games, but don't have "the chops".  Lose
Thos games will not look as good, but there is complete freedom -- you won't 
be constrained.  I suggest you stick to 2D instead of 3D.

Game companies employ more artists than programmers.  In the past, games were 
often made by individual programmers.  Modern games are more like movies, 
relying on lots of "canned" video and sound.

I had to have an option for simple graphics so I made a graphic layer that is 
"persistent" (stays on the screen without having to be refreshed.)  There is
a 
second layer which is redrawn each refresh.  The two layers are merged (XOR), 
along with a text layer, to form the screen image.  There's actually a 
persistent layer for each CPU, but beginners don't need to know that.

I hate fighting with fonts.  There will always be just one font, a
fixed-width 
font, because variable width letters screw-up tables.  Now, I fight with 
colors and it's about the same.  Oh, well.

I like ASCII more than UNICODE.  I'll stick to the American market.  I might 
add extended ASCII, but not UNICODE.  Let programmers in other countries
write 
their own operating systems.

The text layer allows animated character graphics, which were fun.  It's been 
modified to shift the character in each position horizontally or vertically, 
so you can do superscripts or subscripts.

I hated learning one language for the command line and another for 
programming.  With LoseThos, the command line feeds right into the C+ (more 
than C, less than C++) compiler, line by line, and it places code in memory
it 
[C:/LT/OSMain/Memory.CPZ,925] MAlloc()s.  It's like the compiler is
paused.  Naturally, you #include a 
program to load it into memory and, usually, start it.  During boot, many 
files get compiled before it allows you to access the command line.  All the 
header declarations for the operating system are already compiled and are 
available for use in your programs without needing to #include them.  
Everything is truely compiled and nothing is "interpreted".

Statements outside the "scope" of a C+ function execute immediately.  There
is 
no main() function.  Instead, you give a meaningful name and invoke that 
function by calling it with a statement outside the scope of any function, 
usually at the bottom of your file.

I started with C syntax, but didn't like the command line for a directory 
listing looking like this:

Dir("*.*",FALSE);

So, I added default parameters from C++ and it looked like this:

Dir();

I didn't like that, so I made parentheses optional on calls with no
parameters 
and it looks like this:

Dir;

The only side effect in changing the syntax is that when you specify the 
address of a function, you must include a & in front (which is better anyway).

Once I was no longer using standard syntax, I decided to change everything I 
didn't like.  Here are the new [::/LT/Compiler/CmpInit.CPZ,OP_precidence]
operator precidence rules.  See 
[::/LT/Doc/Differences.TXZ] Departures from C/C++.

There are no object files in LoseThos and, normally, you don't make
executable 
files either, but you can.  That's known as "static" compilation.

I looked at Linux code to learn how to use a hard drive and, damn it was 
confusing.  It had so many layers it was hard to find the actual IN and OUT 
instructions that access the hardware.  I decided I'd keep layering to a 
minimum.  Why have open source software if people can't understand and modify 
it?

One problem with Linux is it handles many platforms and different pieces of 
hardware so it's full of #if's and I found it difficult to read.  I don't
know 
if LoseThos will become that way or not.  I'm starting with 64-bit CPU's and 
hardware of that vintage, so I have no reason to support the majority of old 
hardware.

I cherished a book called "Mapping the Commodore 64" when I was a kid because 
it literally told what everything did.  I had a lot of fun.  Commodore, 
Ticketmaster's VAXTMOS and MATLAB are influences.

I made the kernel (known as OSMain) intentionally simple, so everybody could 
understand and tinker.  Technically, it shouldn't be called a kernel since
**eve
rything always runs in kernel mode**.  All code always has full priviledge.  
User programs can access all memory, use all CPU instructions, access all I/O 
ports directly, and can access all parts of the disk.  My system reboots in 3 
seconds if I crash it and I like total freedom as a programmer.

Tasks have no priority scheme and are never removed from the queue.  Instead 
they poll whatever they are waiting on and swap-out.  This keeps it simple.  
It's only a problem if you have too many tasks busy.

The file system is simple so no body can sue me.  There is an allocation 
bitmap and all files are stored contiguously.  You cannot grow files.  Files 
have checksums, however.  Filenames ending in "Z" are stored compressed.  
LoseThos supports direct block access into files.  There is no PATH but
parent 
directories are searched when a file is not found.  See [::/LT/Doc/LTZ.TXZ]
LTZ for transferring 
files to your primary partition.

At one job I made a hardware device which plugged into the parallel port.  
When we upgraded from Win98 to WinXP, hardware ports became off-limits.  A 
coworker found some software to enable them.  LoseThos allows full access to 
ports.  Some hobbiests might want to plug hobby hardware projects into the 
parallel port.

I like being able to turn-off interrupts (Cli; and Sti;) when I change a 
structure used in a multitasking environment.  LoseThos runs all programs in 
kernel mode, so no instructions are restricted.  Turning-off preemption with 
[C:/LT/OSMain/Adam1b.HPZ,98] Preempt() is a less drastic measure that is
usually sufficient.

The graphic resolution is poor, 640x480x4.  I've decided to set this as the 
one and only resolution, forever.  It uses minimal CPU.  A fixed size keeps
it 
simple.  Everybody has the same appearance on their screen.  It's good for 
mobile devices.  VGA is currently the least common denominator on PC's.  Look 
on the bright-side -- you won't spend your time twiddling pixels.

LoseThos is for hobbiest programmers on single user home computers.  The
focus 
task is all-important so "symmetrical multiprocessing" is almost pointless.  
When it comes to multicore utilization, all resources should be devoted to
the 
focus task.  For now, you must explicitly make use of mutlicore in your 
programs.  You can make use of Gs->grbase, a persistent graphics layer
present 
for each core.  It gets merged (XORed) to make the final image.  Multicore is 
fun.  A practical use I plan is placing time-critical tasks on a core which 
doesn't allow long periods with preemption turned-off.

I didn't want to use virtual memory, but I had to for 64-bit mode.  It's just 
as though there is no virtual memory, except you can mark pages as uncached
or 
write-through for MultiCore programming.

There is no distinction between "task", "process" or "thread".  All have a 
[C:/LT/OSMain/Adam1a.HPZ,3235] TssStruct() pointed to by Fs-> while Gs->
points to a [C:/LT/OSMain/Adam1a.HPZ,3708] CPUStruct for the 
current CPU.  Each task can have just one window.

In LoseThos , "Adam" refers to the father of all tasks.  He's never supposed 
to die.  Since task's inherit the symbols of parents, system-wide stuff is 
associated with Adam.  His heap is like kernel memory in other operating 
systems.  He stays in a server mode, taking requests, so you can ask him to #i
nclude something which places that code system-wide.  A funny story is that, 
originally, I called it the "root" task and even had a "/LT/Root" directory.

For easy back-up, place everything you do in your HOME directory and 
subdirectories.  That should make upgrading easy, too.  To make an account
use 
[C:/LT/OSMain/Dsk/Dsk1c.CPZ,104] MkDir() to create a directory under
/LT/Accts.  It will be HOME if you boot to 
it.  The customizable start-up scripts should go in your HOME directory.  The 
default start-up files are in /LT/Accts, the parent of all accounts.  Copy
the 
start-up files you wish to customize into HOME and modify them.  See 
[::/LT/Doc/GuideLines.TXZ,ACCOUNT FILES] Account Files.

Typically, your usage pattern through the day will be repeatedly left or
right 
clicking on filenames in a command line [C:/LT/OSMain/Dsk/Dsk1b.CPZ,238]
Dir() listing.  You left-click files 
to edit them and right-click to #include them.  To begin a project, type
[Edit] Edit(
""); and supply a filename.  Press ESC to save and exit the file.  You'll
need 
to do a new [C:/LT/OSMain/Dsk/Dsk1b.CPZ,238] Dir() command, periodically, so
make a macro.  Access the macro by 
pressing the WINDOWS key, cursoring until you are on top of it and pressing 
the SPACE BAR.

CTRL-T toggles plain text mode, similar to html.  CTRL-L inserts a nongraphic 
widget.  CTRL-R inserts a graphic or edits the graphic under the cursor.

CTRL-ALT-ESC creates a new terminal window.  CTRL-ALT-X kills a window.  
You'll do these periodically.  CTRL-SHIFT-F pops-up the "favorites"
document.  
The favorites can be used from anywhere.  You can put anything there.  I use 
it as a handy TODO file, along with common links.

[C:/LT/Opt/Grep.APZ,161] Grep() is your best friend.  There's a wrapper
function called [C:/LT/Accts/TAD/Adam3eWrappers.APZ,8] F() in your Use
r.CPZ file.  [C:/LT/Opt/Grep.APZ,161] Grep() can also be used to replace
strings across multiple files.

As you browse code, use the WordStat window to look-up functions, etc.  Press 
CTRL-SHIFT-F1 (or whatever) to follow a symbol to it's source.  You can
browse 
deeper and deeper.  You go back with CTRL-Q.

Use the [::/LT/Doc/HelpIndex.TXZ] Help Index to find-out what exists.  It's
broken down by category.  A 
link to the help index should be on your menu.  (WINDOW's KEY).  Also, look
in 
the /LT/Demo directory.


Take Tour
`SpawnUser("Cd(\"::/LT/Accts/Tour\");;AutoFile(\"Tour\");");`

