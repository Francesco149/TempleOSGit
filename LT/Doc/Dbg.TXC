* I use [C:/LT/OSMain/Adam1b.HPZ,42] progress1-[C:/LT/OSMain/Adam1b.HPZ,45]
progress4 for debugging because they show on the wallpaper.  
They're just global integer vars.

* While debugging, you specify addres of assembly  routines with just the 
label, as in _MALLOC+0x20.  You specify C+ function names with & before 
functions as in &PrintF+0x10.

* [C:/LT/OSMain/Dbg1a.CPZ,362] Dbg() will enter debugger.  You might enter
the debugger through a fault.  
You might place a call in your code at fatal error points to enter the 
debugger.  If you see a stk dump, record the label+offset and unassemble, 
[C:/LT/Compiler/Unassembler.CPZ,847] U()
, possibly when not in the debugger, find the offset and follow the link to 
source code.  [C:/LT/OSMain/Dbg1a.CPZ,356] DbgExit() might exit the debugger
and retain the task or [C:/LT/OSMain/Task1a.CPZ,2] Exit() 
might exit debugger, but you will lose the task.

* You can use [C:/LT/OSMain/TaskCmd.CPZ,303] AdamLog() to send text to the
Adam task window.  It works like 
[C:/LT/OSMain/Str1a.CPZ,1122] PrintF().

* [C:/LT/OSMain/Dbg1a.CPZ,269] D() [C:/LT/Adam/Ltf/LtfMain.APZ,698] LtfD() to
do 16 column hex dump mem with numbering from zero.  With 
[C:/LT/Adam/Ltf/LtfMain.APZ,698] LtfD the values are updated continually and
you can alter mem by editing.

* [C:/LT/OSMain/Dbg1a.CPZ,302] Dm() [C:/LT/Adam/Ltf/LtfMain.APZ,682] LtfDm()
to do 16 column hex dump mem with addres showing.

* [C:/LT/OSMain/Dbg1a.CPZ,308] Da() to do one column addr dump (for stk,
etc.) with symic addres.

* [C:/LT/OSMain/Dbg1a.CPZ,340] Dr() dumps registers.  You can display and
modify registers in the debugger 
with var-like labels, RAX, RBX, etc.

* [C:/LT/Compiler/Unassembler.CPZ,847] U() to unassemble mem or
[C:/LT/Adam/Dbg2a.APZ,241] Uf() to unassemble a function.

* [C:/LT/Adam/Profiler.APZ,45] ProfBin(),[C:/LT/Adam/Profiler.APZ,80]
ProfAll() and [C:/LT/Adam/Profiler.APZ,106] ProfRep() provide code profiling.
 See 
[::/LT/Demo/AutoFile/Demo2.AUZ] ::/LT/Demo/AutoFile/Demo2.AUZ (This is an
[::/LT/Doc/Glossary.TXZ,AutoFile] AutoFile.)

* If you recompile OSMain with [C:/LT/Opt/Boot/InsBoot.APZ,185]
InstallBoot(), you can modify the handler for 
faults here: [C:/LT/OSMain/Dbg1a.CPZ,412] Fault2().

* Use [C:/LT/OSMain/Dbg1a.CPZ,183] DbgNum(), [C:/LT/OSMain/Dbg1a.CPZ,164]
DbgStr() and [C:/LT/OSMain/Dbg1a.CPZ,219] DbgAdd() to print debug info
bypassing the window 
framework.  You pass these routines a count in milliseconds for how long it 
should be displayed.  You can use [C:/LT/OSMain/Misc1a.CPZ,442] Raw(TRUE) to
make all output bypass the 
window framework.

* Use [C:/LT/OSMain/Misc1a.CPZ,430] SysDbg() to set a flag which you can read
with [C:/LT/OSMain/Misc1a.CPZ,436] IsSysDbg() when you wish 
to trigger some debug activity.  It's just a handy simple flag, nothing fancy.

* There are flags for various trace options that can help debugging when
there 
are compiler bugs.  Often, you place them in #exe{} blocks.
  
[C:/LT/Compiler/Directives.CPZ,65] Echo() turns on or off raw data going into
  the lexical analyzer.

[C:/LT/Compiler/Directives.CPZ,56] LTrace() shows the tokens coming out of
  the lexical analyzer.

[C:/LT/Compiler/Directives.CPZ,51] CTrace() unassembles code generated from
  the C+ compiler.

[C:/LT/Compiler/Directives.CPZ,33] PTrace() shows intermediate code comming
  out of the first stage of the 
compiler (it's not 100% valid because it hasn't been fixed-up).

[C:/LT/Compiler/Directives.CPZ,38] OTrace() shows intermediate code
  coming-out after optimization.  
[C:/LT/Compiler/Directives.CPZ,43] OPassTraceMask() ctrls which passes are
  displayed.


* There is a heap check utility which can find leaks.  Use
[C:/LT/Opt/HeapLog.APZ,112] HeapLog(), and 
[C:/LT/Opt/HeapLog.APZ,79] HeapLogRep().  It's a really simple program which
intercepts [C:/LT/OSMain/Memory.CPZ,925] MAlloc() and 
[C:/LT/OSMain/Memory.CPZ,919] Free().  You can customize the code to find
other heap issues.

* You can define functions for <CTRL-ALT-letter> keys, but they must operate 
in a interrupt environment or in the window manager when in queues kbd msgs.  
You can do [C:/LT/OSMain/Misc1a.CPZ,442] Raw() output.  Search for
[C:/LT/OSMain/OSGlbls.CPZ,40] fp_ctrl_alt_let_cbs[] and look at the 
code.  They take scancode as an arg.

* If you recompile OSMain with [C:/LT/Opt/Boot/InsBoot.APZ,185]
InstallBoot(), you can set the MemInit, option 
to initialize memory to a value at boot, the HeapInit option to cause mem 
allocated off the heap to be initialized or VarInit option so both global and 
local vars will be initialized to a value.  Pick a non-zero value to discover 
uninitialized var bugs.  You can set [C:/LT/OSMain/Adam1b.HPZ,132]
sys_var_init_flag, and 
[C:/LT/OSMain/Adam1b.HPZ,128] sys_heap_init_flag directly after booting.  You
can also use the ProtectLow 
option to discover NULL dereferrences.
