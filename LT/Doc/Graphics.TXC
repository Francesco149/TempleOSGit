* The support for 3 dimensional graphics is not very good.  You'll probably 
just get frustrated.

* Gs->grbase is a bitmap for persistent data on the screen, not needing to be 
redrawn.  You create an alias for this by using [C:/LT/Adam/Gr/GrNew.APZ,23]
GrAlias() and work with that.  
This image is XORed on top of everything, so the colors you work with, you 
usually XOR with WHITE to compensate. (White is usually the text background 
color. XORing twice gets you to what you started with.) It's slightly simpler 
using this bitmap then [grbase2] grbase2, but it's not as good because
changes aren't 
syncronized to the screen update and window borders are not enforced.  See 
[::/LT/Demo/Graphics/DotNet.CPZ] ::/LT/Demo/Graphics/DotNet.CPZ

* There is actually one Gs->grbase for each core and they get merged.  See 
[::/LT/Demo/MultiCore2.CPZ] ::/LT/Demo/MultiCore2.CPZ

* [grbase2] grbase2 is a bitmap for the screen, redrawn each refresh.  You
create an 
alias with [C:/LT/Adam/Gr/GrNew.APZ,23] GrAlias() and work with that.  You
must change the "Fs->update_win" 
variable to point to your update function and must draw everything in the 
window over and over again. "DrawIt()" is the preferred name for your update 
function, so everyone is consistent.  See [::/LT/Demo/Graphics/Box.CPZ]
::/LT/Demo/Graphics/Box.CPZ
 
* Use [C:/LT/Adam/Gr/GrNew.APZ,23] GrAlias() to create your own structure for
accessing the screen and pass 
it either Gs->grbase or [grbase2] grbase2.  (Free it with
[C:/LT/Adam/Gr/GrNew.APZ,79] GrDel() when finished).  A 
[C:/LT/OSMain/Adam1a.HPZ,3446] GrBitMap returned by
[C:/LT/Adam/Gr/GrNew.APZ,23] GrAlias() stores the pen width and current
color.  It 
also can hold info necessary to rotate the whole image in 3D and shift it 
around.

* Use [GrBitMapNew] GrBitMapNew() to create a memory bitmap which can be used
to work 
off-line and which can be [C:/LT/Adam/Gr/GrBitMap.APZ,189] GrBloted onto the
screen.  If you set brush member 
of GrBitMap to another GrBitMap, all the graphic routines will
[C:/LT/Adam/Gr/GrBitMap.APZ,189] GrBlot() the 
brush instead of [C:/LT/Adam/Gr/GrPrimatives.APZ,47] GrPlot().  See
[::/LT/Demo/Graphics/Blot.CPZ] ::/LT/Demo/Graphics/Blot.CPZ.

* There are various flavors of line and point plotting
routines.  [C:/LT/Adam/Gr/GrPrimatives.APZ,437] GrLine() and 
[C:/LT/Adam/Gr/GrPrimatives.APZ,47] GrPlot() are the simplest.  The others
allow 3 dimensional graphics.

* [GrTheta] GrTheta() and [GrPhi] GrPhi() create matrices for 3 dimensional
rotations. You pass 
them an angle in radians.  To make the matrices take effect, assign them to 
your graphic [C:/LT/OSMain/Adam1a.HPZ,3446] GrBitMap's "r" variable and set
the [C:/LT/OSMain/Adam1a.HPZ,3410] BMF_TRANSFORMATION flag.  
Transformations (rotations) can be combined using
[C:/LT/Adam/Gr/GrMath.APZ,220] GrMulMat().  See 
[::/LT/Demo/Graphics/Box.CPZ] ::/LT/Demo/Graphics/Box.CPZ.

* You can rotate single points using [GrRotate] GrRotate().

* You can shift the image around by changing a [C:/LT/OSMain/Adam1a.HPZ,3446]
GrBitMap's "x","y" and "z" 
variables.

* Use the resource editor, CTRL-R, to create a picture-like thing called a 
Graphic Element that can be plotted with [GrElemsPlot] GrElemsPlot().  Use
$IB,"",1$ in a 
source program to insert the address of picture #1.  (After creating a
picture 
with CTRL-R in your source code, toggle to plain text with CTRL-T and check 
it's number.  Then, make an assignment to a pointer variable with $IB,"",n$
as 
the value. See [::/LT/Demo/Graphics/Sprite1.CPZ]
::/LT/Demo/Graphics/Sprite1.CPZ and 
[::/LT/Demo/Graphics/Sprite2.CPZ] ::/LT/Demo/Graphics/Sprite2.CPZ.)  The
origin (zero point) for a graphic 
element is defined by the cursor location when you press CTRL-R.  The "x",
"y" 
and "z" values you pass to [GrElemsPlot] GrElemsPlot() shift it around.  You
can edit a 
Graphic Element by clicking the cursor on it and pressing CTRL-R again.

* There is a mechanism built-in for generating motion based on differential 
equations, which allows real-world physics.  You create an
[C:/LT/OSMain/Adam1a.HPZ,229] Ode struct with 
[C:/LT/Adam/Ode.APZ,42] OdeNew(), passing it the number of variables in the
state vector.  For 
real-world physics, you usually have 2 state variables for each dimension
(for 
each mass) because motion is governed by f=ma which is a 2nd order equation.  
The two states are position and velocity and to solve these you need to
supply 
the derivative of position and velocity.  The derivative of position is 
usually simply the current velocity and the derivative of velocity is the 
acceleration (the sum of forces on a mass divided by mass).  To help provide 
meaningful names for values in the state vector, you can create an
[C:/LT/OSMain/Adam1a.HPZ,186] Order2D3 
pointer and point it to a mass in the state vector.  Six elements in the
state 
vector are required for each mass.

See [::/LT/Apps/Rocks/Rocks.CPZ] ::/LT/Apps/Rocks/Rocks.CPZ



