* You can enter the debugger with [C:/TempleOS/Kernel/Dbg1a.CPP.Z,691] Dbg()
or <CTRL-ALT-D>.  You might enter the 
debugger through a fault.  Enter [C:/TempleOS/Kernel/Dbg1a.CPP.Z,501] G() or
[C:/TempleOS/Kernel/Dbg1a.CPP.Z,527] G2() to continue execution.  Place a 
call to [C:/TempleOS/Kernel/Dbg1a.CPP.Z,691] Dbg() in your code at fatal
error points to enter the debugger.  If 
you see a stk dump, record the label+offset and unassemble,
[C:/TempleOS/Compiler/Unassembler.CPP.Z,866] U().
[C:/TempleOS/Compiler/Unassembler.CPP.Z,866]
U([C:/TempleOS/Kernel/Adam1a.HPP.Z,3656] _RIP); 

* I use [C:/TempleOS/Kernel/Adam1b.HPP.Z,43]
progress1-[C:/TempleOS/Kernel/Adam1b.HPP.Z,52] progress4 for debugging
because they show on the wallpaper.  
They're just global integer vars.

* While debugging, you specify addresses of assembly  routines with just the 
label, as in _MALLOC+0x20.  You specify [C:/Doc/HolyC.TXT,1] HolyC function
names with & before 
functions as in &Print+0x10.

* You can use [C:/TempleOS/Kernel/TaskCmd.CPP.Z,307] AdamLog() to send text
to the Adam task window.  It works like 
[MN:Print] Print().  I never use this.  Instead I use [MN:RawPrint]
RawPrint().

* [C:/TempleOS/Kernel/Dbg1a.CPP.Z,271] D(),
[C:/TempleOS/Adam/Doc/DocMain.CPP.Z,651] DocD(), [MN:RawD] RawD() to do 16
column hex dump mem with numbering from zero.  
With [C:/TempleOS/Adam/Doc/DocMain.CPP.Z,651] DocD the values are updated
continually and you can alter mem by editing.

* [C:/TempleOS/Kernel/Dbg1a.CPP.Z,301] Dm(),
[C:/TempleOS/Adam/Doc/DocMain.CPP.Z,635] DocDm(), [MN:RawDm] RawDm() to do 16
column hex dump mem with addresses showing.

* [C:/TempleOS/Kernel/Dbg1a.CPP.Z,307] Da() to do one column address dump
(for stk, etc.) with symbolic addresses.

* [C:/TempleOS/Kernel/Dbg1a.CPP.Z,378] Dr() dumps regs.  You can display and
modify regs in the debugger with 
var-like labels, _RAX, _RBX, etc.

* [C:/TempleOS/Compiler/Unassembler.CPP.Z,866] U(&FunName+offset) to
unassemble mem or [C:/TempleOS/Adam/Dbg2a.CPP.Z,236] Uf("FunName") to
unassemble a 
function. [C:/TempleOS/Compiler/Unassembler.CPP.Z,866]
U([C:/TempleOS/Kernel/Adam1a.HPP.Z,3656] _RIP-16);

* [C:/TempleOS/Adam/Profiler.CPP.Z,46]
ProfBin(),[C:/TempleOS/Adam/Profiler.CPP.Z,82] ProfAll() and
[C:/TempleOS/Adam/Profiler.CPP.Z,109] ProfRep() provide code profiling.  See 
[C:/Demo/AutoFile/AFProfile.AUT,1] (This is an [C:/Doc/Glossary.TXT,1]
AutoFile.)

* Use [C:/TempleOS/Kernel/Display.CPP.Z,1] RawPutChar() and [MN:RawPrint]
RawPrint() to print debug info bypassing the window 
framework.  You pass these routines a count in milliseconds for how long it 
should be displayed.  You can use [C:/TempleOS/Kernel/Misc1a.CPP.Z,282]
Raw(TRUE) to make all output bypass the 
window framework.  The WinMgr runs on core0 and will overwrite raw text from 
other cores when it updates the screen.

* Use [C:/TempleOS/Kernel/Misc1a.CPP.Z,263] SysDbg() to set a flag which you
can read with [C:/TempleOS/Kernel/Misc1a.CPP.Z,269] IsSysDbg() when you wish 
to trigger some debug activity.  It's just a handy simple flag, nothing fancy.

* There are flags for various trace options that can help debugging when
there 
are compiler bugs.  Often, you place them in #exe{} blocks.
  
[C:/TempleOS/Compiler/Directives.CPP.Z,48] Echo() turns on or off raw data
  going into the lexical analyzer.

[C:/TempleOS/Compiler/Directives.CPP.Z,38] CTrace() unassembles code
  generated from the HolyC compiler.

[C:/TempleOS/Compiler/Directives.CPP.Z,26] OTrace() shows intermediate code
  coming-out after optimization.  [MN:OTraceMask] OTraceMask(
) ctrls which passes are displayed.


* There is a heap check utility which can find leaks.  Use
[C:/TempleOS/Adam/HeapLog.CPP.Z,121] HeapLog(), and 
[C:/TempleOS/Adam/HeapLog.CPP.Z,80] HeapLogRep().  It's a really simple
program which intercepts [C:/TempleOS/Kernel/Memory.CPP.Z,956] MAlloc() and 
[C:/TempleOS/Kernel/Memory.CPP.Z,950] Free().  You can customize the code to
find other heap issues.

* You can define functions for <CTRL-ALT-letter> keys, but they must operate 
in a interrupt environment or in the window mgr when in ques kbd msgs.  You 
can do [C:/TempleOS/Kernel/Misc1a.CPP.Z,282] Raw() output.  Search for
[C:/TempleOS/Kernel/KGlbls.CPP.Z,51] fp_ctrl_alt_let_cbs[] and look at the
code.  
They take scancode as an arg.

* If you recompile Kernel with [MN:MakeOSPrtBootInstall]
MakeOSPrtBootInstall(), you can set the MemInit
, option to initialize memory to a value at boot, the HeapInit option to
cause 
mem allocated off the heap to be initialized or VarInit option so both global 
and local vars will be initialized to a value.  Pick a non-zero value to 
discover uninitialized var bugs.  You can set
[C:/TempleOS/Kernel/Adam1b.HPP.Z,129] sys_var_init_flag, and 
[C:/TempleOS/Kernel/Adam1b.HPP.Z,125] sys_heap_init_flag directly after
booting.
