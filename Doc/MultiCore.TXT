TempleOS does master-slave multicore instead of SMP.  Core0 is the master.  
The master core's applications explicitly assign computational jobs to other 
cores and the TempleOS scheduler does not move tasks between cores.

There are multicore safe locks for file access and heap allocations, however, 
so TempleOS is symmetrical in some sense.  See
[C:/Demo/MultiCore/LoadTest.CPP.Z,1].

Only tasks on core0 can have windows, but other cores can help render them.

Each core has an executive seth task which is the father of all tasks on that 
core.  Adam is the seth task on core 0.

You give a job to a seth task with [C:/Kernel/MultiProc.CPP.Z,213] JobQue()
and get the res with [C:/Kernel/SrvCmd.CPP.Z,198] JobResGet().  
You spawn a task on another core with [C:/Kernel/KTask.CPP.Z,222] Spawn().

Note: You must use the LOCK asm prefix when changing shared structures in a 
multicore environment.  The [C:/Kernel/KernelB.HPP.Z,26] LBts(),
[C:/Kernel/KernelB.HPP.Z,24] LBtr() and [C:/Kernel/KernelB.HPP.Z,22] LBtc()
insts have LOCK 
prefixes.  The compiler has a lock{} feature but it doesn't work well.  See 
[C:/Demo/MultiCore/Lock.CPP.Z,1].

See [C:/Demo/Graphics/Transform.CPP.Z,1].
See [C:/Kernel/MultiProc.CPP.Z,1].
