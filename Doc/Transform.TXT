[C:/Kernel/Adam1a.HPP.Z,3210] CDC's have a 4x4 matrix for rotating, scaling,
skewing and shifting in 3 
dimensions.  To make the graphics routines respond to the transformation, you 
must set the [C:/Kernel/Adam1a.HPP.Z,3178] DCF_TRANSFORMATION flag.

The matrix consists of integers that have been scaled 32 bits
([C:/Adam/Gr/MathGr.CPP.Z,226] gr_scale).  See 
[C:/Demo/Lectures/FixedPoint.CPP.Z,1] to learn why.

See [C:/Adam/Gr/MathGr.CPP.Z,247] GrRotXNew(), [C:/Adam/Gr/MathGr.CPP.Z,263]
GrRotYNew(), [C:/Adam/Gr/MathGr.CPP.Z,279] GrRotZNew(),
[C:/Adam/Gr/MathGr.CPP.Z,295] GrScaleNew(), [C:/Adam/Gr/MathGr.CPP.Z,323]
GrRotXEqu(), 
[C:/Adam/Gr/MathGr.CPP.Z,343] GrRotYEqu(), [C:/Adam/Gr/MathGr.CPP.Z,363]
GrRotZEqu() and [C:/Adam/Gr/MathGr.CPP.Z,383] GrScaleEqu() to rotate about
axes and scale.  
Combine them with [C:/Adam/Gr/MathGr.CPP.Z,304] GrMulMat() and assign them to
the [C:/Kernel/Adam1a.HPP.Z,3210] CDC.dc with [C:/Adam/Gr/MathGr.CPP.Z,391]
GrSetRotMat(). 
 See [C:/Demo/Graphics/Box.CPP.Z,1].

You can rotate single points using [C:/Adam/Gr/MathGr.CPP.Z,228] GrRot().

The 4th dimension allows a neat trick where you can place pos shifts 
(translations), into the matrix and [C:/Adam/Gr/MathGr.CPP.Z,304] GrMulMat
them to combine rotation/shift 
operations.  Normally, you can't combine pos shift operations.  See 
[C:/Adam/Gr/MathGr.CPP.Z,437] GrSetTranslation() and
[C:/Demo/Graphics/Transform.CPP.Z,1].

Finally, [C:/Kernel/Adam1a.HPP.Z,3210] CDC's have an x, y and z which is an
additional shift (translation).

The transformation is implemented as a callback on the
[C:/Kernel/Adam1a.HPP.Z,3210] CDC's transform() 
member.  The default transfrom() callback is [C:/Adam/Gr/MathGr.CPP.Z,238]
GrTransform().  See 
[C:/Demo/Games/EagleDive.CPP.Z,1] or
[C:/Demo/Games/CastleFrankenstein.CPP.Z,1] to see how 
to change the transfrom() callback for foreshortening.
