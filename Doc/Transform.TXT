[C:/Kernel/Adam1a.HPP.Z,3220] CDC's have a 4x4 matrix for rotating, scaling,
skewing and shifting in 3 
dimensions.  To make the graphics routines use the transform, you must set
the 
[C:/Kernel/Adam1a.HPP.Z,3188] DCF_TRANSFORMATION flag.

The matrix consists of integers that have been scaled 32 bits
([C:/Adam/Gr/GrDC.CPP.Z,4] gr_scale).  See 
[C:/Demo/Lectures/FixedPoint.CPP.Z,1] to learn why.

See [C:/Adam/Gr/MathGr.CPP.Z,83] GrRotXNew(), [C:/Adam/Gr/MathGr.CPP.Z,99]
GrRotYNew(), [C:/Adam/Gr/MathGr.CPP.Z,115] GrRotZNew(),
[C:/Adam/Gr/MathGr.CPP.Z,131] GrScaleNew(), [C:/Adam/Gr/MathGr.CPP.Z,159]
GrRotXEqu(), 
[C:/Adam/Gr/MathGr.CPP.Z,179] GrRotYEqu(), [C:/Adam/Gr/MathGr.CPP.Z,199]
GrRotZEqu() and [C:/Adam/Gr/MathGr.CPP.Z,219] GrScaleEqu() to rotate about
axes and scale.  
Combine them with [C:/Adam/Gr/MathGr.CPP.Z,140] GrMulMat() and assign them to
the [C:/Kernel/Adam1a.HPP.Z,3220] CDC.dc with [C:/Adam/Gr/GrDC.CPP.Z,47]
GrSetRotMat(). 
 See [C:/Demo/Graphics/Box.CPP.Z,1].

You can rotate single points using [C:/Adam/Gr/GrDC.CPP.Z,6] GrRot().

The 4th dimension allows a neat trick where you can place pos shifts 
(translations), into the matrix and [C:/Adam/Gr/MathGr.CPP.Z,140] GrMulMat
them to combine rotation/shift 
operations.  Normally, you can't combine pos shift operations.  See 
[C:/Adam/Gr/MathGr.CPP.Z,240] GrSetTranslation() and
[C:/Demo/Graphics/Transform.CPP.Z,1].

Finally, [C:/Kernel/Adam1a.HPP.Z,3220] CDC's have an x, y and z which is an
additional shift (translation).

The transformation is implemented as a callback on the
[C:/Kernel/Adam1a.HPP.Z,3220] CDC's transform() 
member.  The default transfrom() callback is [C:/Adam/Gr/GrDC.CPP.Z,16]
GrTransform().  See 
[C:/Demo/Games/EagleDive.CPP.Z,1] or
[C:/Demo/Games/CastleFrankenstein.CPP.Z,1] to see how 
to change the transfrom() callback for foreshortening.
