[C:/Kernel/Adam1a.HPP.Z,3547] CDC's have a 4x4 matrix for rotating, scaling,
skewing and shifting in 3 
dimensions.  To make the graphics routines use the transform, you must set
the 
[C:/Kernel/Adam1a.HPP.Z,3521] DCF_TRANSFORMATION flag.

The matrix consists of integers that have been scaled 32 bits
([C:/Adam/Gr/GrDC.CPP.Z,4] GR_SCALE).  See 
[C:/Demo/Lectures/FixedPoint.CPP.Z,1] to learn why.

See [C:/Adam/Gr/MathGr.CPP.Z,83] GrRotXNew(), [C:/Adam/Gr/MathGr.CPP.Z,98]
GrRotYNew(), [C:/Adam/Gr/MathGr.CPP.Z,113] GrRotZNew(),
[C:/Adam/Gr/MathGr.CPP.Z,128] GrScaleNew(), [C:/Adam/Gr/MathGr.CPP.Z,154]
GrRotXEqu(), 
[C:/Adam/Gr/MathGr.CPP.Z,173] GrRotYEqu(), [C:/Adam/Gr/MathGr.CPP.Z,192]
GrRotZEqu() and [C:/Adam/Gr/MathGr.CPP.Z,211] GrScaleEqu() to rotate about
axes and scale.  
Combine them with [C:/Adam/Gr/MathGr.CPP.Z,136] GrMulMat() and assign them to
the [C:/Kernel/Adam1a.HPP.Z,3547] CDC.dc with [C:/Adam/Gr/GrDC.CPP.Z,44]
GrSetRotMat(). 
 See [C:/Demo/Graphics/Box.CPP.Z,1].

You can rotate single points using [C:/Adam/Gr/GrDC.CPP.Z,6] GrRot().

The 4th dimension allows a neat trick where you can place pos shifts 
(translations), into the matrix and [C:/Adam/Gr/MathGr.CPP.Z,136] GrMulMat
them to combine rotation/shift 
operations.  Normally, you can't combine pos shift operations.  See 
[C:/Adam/Gr/MathGr.CPP.Z,232] GrSetTranslation() and
[C:/Demo/Graphics/Transform.CPP.Z,1].

Finally, [C:/Kernel/Adam1a.HPP.Z,3547] CDC's have an x, y and z which is an
additional shift (translation).

The transformation is implemented as a callback on the
[C:/Kernel/Adam1a.HPP.Z,3547] CDC's transform() 
member.  The default transfrom() callback is [C:/Adam/Gr/GrDC.CPP.Z,15]
GrTransform().  See 
[C:/Demo/Games/EagleDive.CPP.Z,1] or
[C:/Demo/Games/CastleFrankenstein.CPP.Z,1] to see how 
to change the transfrom() callback for foreshortening.
