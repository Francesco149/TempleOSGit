                                    HolyC

* See [C:/Doc/ImportExports.TXT.Z,1] Scoping and Linkages for details on
extern, import, _extern, _import, 
etc.

* See [C:/Doc/Directives.TXT.Z,1].

* Built-in types include I0,I8,I16,I32,I64 for signed 0-8 byte ints and U0,U8,
U16,U32,U64 for unsigned 0-8 byte ints and F64 for 8 byte floats.

	U0	void
	I8	char
	U8	unsigned char
	I16	short
	U16	unsigned short
	I32	int
	U32	unsigned int
	I64	long (64-bit)
	I64	unsigned long (64-bit)
	F64	double
	no F32 float.

* Function with no args, or just default args can be called without 
parentheses. 

* Default args don't have to be on the end.  This code is valid:
  U0 Test(I64 i=4,I64 j,I64 k=5)
{
  Print("%X %X %X\n",i,j,k);
}

Test(,3);

* A char const all alone is sent to [C:/Kernel/Display.CPP.Z,199] PutChars().
 A string with or without args 
is sent to [C:/Kernel/StrPrint.CPP.Z,946] Print().  An empty string literal
signals a variable fmt_str 
follows.

  void Demo(char drv,char *fmt,char *name,int age)
{
  printf("Hello World!\n");
  printf("%s age %d\n",name,age);
  printf(fmt,name,age);
  putchar(drv);
  putchar('*');
}

U0 Demo(U8 drv,U8 *fmt,U8 *name,I64 age)
{
  "Hello World!\n";
  "%s age %d\n",name,age;
  "" fmt,name,age;
  '' drv;
  '*';
}

* When dealing with function addresses, precede the name with "&".

* There is no main() function.  Any code outside of functions gets executed
on 
start-up, in order.

* You can access bytes or words within any int.  i.u8[2] returns bits 24-27
in 
the variable, i.  See [C:/Kernel/Adam1a.HPP.Z,50] I64 declaration.  The real
feature is that a class can 
be accessed as a whole, if you put a type in front of the class declaration.

* Variable arg count functions (...) can access their args with built-in 
variables similar to 'this' in C++.  They are 'I64 argc' and 'I64 argv[]'.  
  
  U0 GrPrint(CDC *dc,I64 x,I64 y,U8 *fmt,...)
  {
    U8 *buf=SPrintJoin(NULL,fmt,argc,argv);
    GrPrint(dc,x,y,buf);
    Free(buf);
  }
  
* Allows "5<i<j+1<20" instead of "5<i && i<j+1 && j+1<20".
  
if (13<=age<20)
  "Teen-ager";

* switch statements always use a jump table.  Don't use them with cases with 
really big, sparse ranges.

* Allows ranges like "case 4...7:" in switch statements. 

* nobound_switch can be used if you know a switch statement will not exceed 
the lowest or highest case values.  It's a little faster because it doesn't 
check.

* sub_switch_start/sub_switch_end allow a new type of nested-switch control 
flow.  (Don't goto, throw exception or return out of sub_switch_start front 
porch area.)

  U0 SubSwitch()
{
  I64 i;
  for (i=0;i<10;i++)
    switch (i) {
      case 0: "Zero ";	break;
      case 2: "Two ";		break;
      case 4: "Four ";	break;
      sub_switch_start:
        "[";
        case 1: "One";	break;
        case 3: "Three";	break;
        case 5: "Five";	break;
      sub_switch_end:
        "] ";
        break;
    }
  NewLine;
}
OutPut:
>Zero [One] Two [Three] Four [Five]

* noreg or reg can be placed before a function local var name.  You can, 
optionally, specify a reg after the reg keyword.

* interrupt, haserrcode, public, argpop or noargpop are function flags. See 
[C:/Demo/Lectures/PageTableEntries2.CPP.Z,1].

* A nounusedwarn statement will suppress an unused var warning.

* You can have multiple member vars of a class named "pad" or "reserved", and 
it won't issue warnings. 

* Type casting is postfix.  To typecast int or F64, use
[C:/Kernel/Adam1b.HPP.Z,197] ToI64(), [C:/Kernel/Adam1b.HPP.Z,199] ToBool()
or 
[C:/Kernel/Adam1b.HPP.Z,198] ToF64(). (TempleOS follows normal C float<-->int
conversion, but sometimes you 
want to override.  These functions are better than multiplying by "1.0" to 
convert to float.) 

* A single quote can encompass multiple characters.  'ABC' is equal to 0x43424
1.  [C:/Kernel/Display.CPP.Z,199] PutChars() takes multiple characters.

* The "`" operator raises a base to a power.

* There is no question-colon operator.

* TempleOS [C:/Compiler/CmpInit.CPP.Z,1] operator precedence
  `,>>,<<
  *,/,%
  &
  ^
  |
  +,-
  <,>,<=,>=
  ==,!=
  &&
  ^^
  ||
  =,<<=,>>=,*=,/=,&=,|=,^=,+=,-=

* You can use [C:/Compiler/ICLCC.CPP.Z,6] OptOn([C:/Kernel/Adam1a.HPP.Z,1469]
OPTf_WARN_PAREN) to find unnecessary parentheses in code.

* You can use [C:/Compiler/ICLCC.CPP.Z,6] OptOn([C:/Kernel/Adam1a.HPP.Z,1470]
OPTf_WARN_DUP_TYPES) to find dup local var type 
statements.

* With the #exe{} feature in your src code, you can place programs that
insert 
text into the stream of code being compiled.  See [C:/Kernel/KEnd.CPP.Z,1]
#exe {} for an example where 
the date/time and compile-time prompting for cfguration data is placed into a 
program.  [C:/Compiler/CmpMain.CPP.Z,1] StreamPrint() places text into a src
program stream following the 
conclusion of the #exe{} blk.

* No #define functions exist (I'm not a fan)

* No typedef, use class.

* No type-checking

* Can't use <> with #include, use "".

* "$" is an escape character.  Two dollar signs signify an ordinary $.  See 
[C:/Doc/Dollar.TXT.Z,1].  In asm or [C:/Doc/HolyC.TXT.Z,1] HolyC code, it
also refers to the instruction's 
addr. 

* union is more like a class, so you don't reference it with a union label 
after you define it.  Some common unions are declared in
[C:/Kernel/Adam1a.HPP.Z,12] Adam1a.HPP for 1,2,4 
and 8 byte objects.  If you place a type in front of a union declaration,
that 
is the type when used by itself.  See [C:/Demo/SubIntAccess.CPP.Z,1]. 

* class member vars can have meta data. fmtstr and fmtdata are two meta data 
types now used.  All compiler structures are saved and you can access the 
compiler's info about classes and vars.  See [C:/Demo/ClassMeta.CPP.Z,1] and  
[C:/Adam/Doc/DocPopUp.CPP.Z,301] DocFormDo().

* There is a keyword lastclass you use as a dft arg.  It is set to the class 
name of the previous arg.  See [C:/Adam/Dbg2a.CPP.Z,134] ClassRep().

* See [C:/Demo/Exceptions.CPP.Z,1].  try{} catch{} and throw are different
from C++. 
throw is a function with a char arg.  The char string passed in throw() can
be 
accessed from within a catch{} using the Fs->except_ch.  Within a catch {} 
blk, set the var Fs->catch_except to TRUE if you want to terminate the search 
for a handler.  Use [C:/Kernel/Except.CPP.Z,46] PutExcept() as a handler, if
you like.

* A function is available similar to sizeof which provides the offset of a 
member of a class.  It's called offset.  You place the class name and member 
inside as in offset(classname.membername).  It has nothing to do with 16-bit 
code.  Both sizeof and offset only accept one level of member vars.  That is, 
you can't do sizeof(classname.membername.submembername).

* There is no continue statement.  Use goto.

* No bit field support, but there are bit access [Bit,1] library routines.

* lock{} can be used to apply asm LOCK prefixes to code for safe multicore 
read-modify-write accesses.  The code bracked with have LOCK asm prefix's 
applied to relevant instructions within.  It's a little shoddy.  See 
[C:/Demo/MultiCore/Lock.CPP.Z,1].

* There is a function called [C:/Kernel/Mem1b.CPP.Z,371] MSize() which gives
the size of an object 
allocated off the heap.  For larger size allocations, the system rounds-up to 
a power of two, so MSize() lets you know the real size and you can take full 
advantage of it.

* You can [C:/Kernel/Mem1b.CPP.Z,370] Free() a NULL ptr.  Useful variants of
[C:/Kernel/Mem1b.CPP.Z,376] MAlloc() can be found [C:/Kernel/Mem1b.CPP.Z,383]
Here.  
Each task has a heap and you can MAlloc and Free off of other task's heaps,
or 
make an independent heap with [C:/Kernel/Mem1c.CPP.Z,42] HeapCtrlBPInit().

* The stk does not grow because virtual mem is not used.  I recommend 
allocating large local vars from the heap.  You can change
[C:/Kernel/Adam1a.HPP.Z,2584] DFT_STK and 
recompile Kernel or request more when doing a [C:/Kernel/Task1a.CPP.Z,225]
Spawn().  You can use 
[C:/Kernel/Task1a.CPP.Z,89] CallStkGrow(), but it's odd.  See
[C:/Demo/StkGrow.CPP.Z,1]. 

* Only one base class is allowed.

* All values are extended to 64-bit when accessed.  Intermediate calculations 
are done with 64-bit values.

  The follow examples should be inserted in a function, so that reg variables 
are used.  (Global vars are never reg.)

I16 i;
I32 j;
j=i=0x12345678; //Resulting i is 0x5678 but j is 0x12345678

I64 i=0x8000000000000000;
Print("%X\n",i>>1);  //Result is 0xC000000000000000 as expected

U64 u=0x8000000000000000;
Print("%X\n",u>>1);  //Result is 0x4000000000000000 as expected

I32 i= 0x80000000;   //const is loaded into a 64-bit reg var.
Print("%X\n",i>>1);  //Result is 0x40000000

I32 i=-0x80000000;
Print("%X\n",i>>1);  //Result is 0xC0000000 as expected


                                 Print Family

[C:/Kernel/StrPrint.CPP.Z,954] MPrint() is like
[C:/Kernel/StrPrint.CPP.Z,932] SPrint() but it returns a
[C:/Kernel/Mem1b.CPP.Z,376] MAllocated str.  It is vary handy 
because you don't have to worry about overflow.

[C:/Kernel/SrvCmd.CPP.Z,491] Auto(U8 *fmt,...) sends text to the current
task's input buffer.
[C:/Kernel/SrvCmd.CPP.Z,472] AutoStr(U8 *fmt,...) sends text of an
[C:/Doc/Glossary.TXT.Z,1] AutoFile to the keyboard stream of the 
current TASK but can also do mouse cmds.

[C:/Kernel/SrvCmd.CPP.Z,451] XTalk(CTask *task,U8 *fmt,...) and text to
another task's input buffer.
[C:/Kernel/SrvCmd.CPP.Z,501] XTalkStr(CTask *task,U8 *fmt,...) sends text of
an [C:/Doc/Glossary.TXT.Z,1] AutoFile to the keyboard 
stream of another TASK but can also do mouse cmds.

[C:/Adam/Doc/DocPlain.CPP.Z,679] DocPrint(CDoc *doc,U8 *fmt,...) sends text
to a document.  You can buffer to a 
Doc and save it, providing the functionality of fprintf.  See 
[C:/Demo/Dsk/FPrintF.CPP.Z,1].

[C:/Kernel/SrvCmd.CPP.Z,404] Adam(U8 *fmt,...) sends text to the adam task to
be compiled and run.
[C:/Kernel/SrvCmd.CPP.Z,425] AdamLog(U8 *fmt,...) and
[C:/Kernel/SrvCmd.CPP.Z,437] AdamErr(U8 *fmt,...) send text to the adam task
to be 
displayed.

[C:/Compiler/CmpMain.CPP.Z,1] StreamPrint(U8 *fmt,...) sends text to the
stream of code being compiled and 
must reside in a #exe{} blk.

[C:/Adam/Gr/GrBitMap.CPP.Z,866] GrPrint(CDC *dc,I64 x,I64 y,U8 *fmt,...) and
[C:/Adam/Gr/GrBitMap.CPP.Z,875] GrVPrint() plots text in graphics 
mode.

[C:/Compiler/CmpMain.CPP.Z,640] ExePrint(U8 *fmt,...) compiles and execute a
string.  Note: It returns the 
result of the last executed expression.

[C:/Adam/AutoFile2a.CPP.Z,28] AFPrint(I64 mS,U8 *fmt)
[C:/Kernel/Display.CPP.Z,199] PutChars()s one at a time with a delay.

[C:/Kernel/Dbg1a.CPP.Z,222] RawPrint(I64 mS,U8 *fmt) sends direct to screen
memory, bypassing window 
manager.

**Note:** Use Print("%s",src) if you need an unmodified string.


The [C:/Kernel/StrPrint.CPP.Z,946] Print() family supports extended format
codes.  See [C:/Kernel/StrPrint.CPP.Z,247] SPrintJoin().
  %[-][0][width][.decimals][flags][hsub_fmt][main_fmt]

flags:
    * 't' is a flag which will truncate to field width.
* ',' is a flag which will add commas every three digits in a %d, %f, %g, 
%e and %n entries.
* '$' is a flag which affects the %Q entry, converting '$' to "\044".
* '/' is a flag which affects the %Q and %q entries, converting '%' to "%%
".
  
sub_fmt:
    For "%n", "%d" or "%u", the sub_fmt causes thousands mode.  "%h?n" will 
pick a var exponent multiples of three unit, while "%h-3n" will display 
milli units or "%h6n" will display mega units.  The 'k' flag is always on 
for "%n".  See [C:/Demo/Print.CPP.Z,1].
  
*  "%n" will print a floating point in engineering notation, exponents being 
multiples of three.  If it has a sub_fmt code, it will display scientific 
units letters.

* "%S" will print a Define entry.

* "%C" will print a ToUpper character.

* "%F" will print a text file.

* "%p" will display ptr.

* "%P" will display link to ptr.

* "%T" and "%D" will display a date or time if you pass a
  [C:/Kernel/Adam1a.HPP.Z,202] CDate.

* "%z" will display a subentry of an enumerated list of text entries.  It 
calls [C:/Kernel/Str1a.CPP.Z,385] LstSub().  Pass subentry first, list second.

* "%Z" will display a Define subentry.  Pass subentry first, lst_define 
second.

* "%Q" will convert "\" to "\\" and quote to backslash quote. (For use in 
creating strs in strs.)

* "%q" will reverse a "%Q".
