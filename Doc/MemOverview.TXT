                               Memory Overview

Paging is practically not used.  64-bit mode requires paging, however, so it 
is identity-mapped, virtual ident to physical.  All tasks on all cores use
the 
same page table map, just as though all addresses are physical addresses.  2 
Meg page table entries are used.  Nothing swaps to disk.

In TempleOS, the lowest 2 Gig of memory is called the code heap.  TempleOS's 
compiler always uses 32-bit signed relative JMP & CALL insts because 64-bit 
CALLs take two insts.  With signed +/- 32-bit values, code can only call a 
function within 2 Gig distance.  Therefore, TempleOS keeps all code in the 
lowest 2 Gig memory addresses including what would normally be called "the 
kernel".  Two Gig is plenty for code, don't worry.

You can create new, independent heaps using [C:/Kernel/Mem/HeapCtrl.CPP.Z,1]
HeapCtrlInit().  Then, use the 
[C:/Kernel/KernelA.HPP.Z,2899] CHeapCtrl as the 2nd arg to
[C:/Kernel/Mem/MAllocFree.CPP.Z,387] MAlloc().  See
[C:/Adam/Opt/Utils/HeapLog.CPP.Z,73] HeapLog() for an example.

Memory alloced by a task will be freed when the task is killed.

Eventually, memory will become fragmented, requiring a reboot.

See [C:/Adam/Opt/Utils/MemRep.CPP.Z,191] MemRep() and [C:/Demo/MemDemo.CPP,1].

                          Single System-wide Mem Map

 0x0000007C00- 0x00000347EF
  Kernel module, placed here by the boot-loader,
  [C:/Kernel/KernelA.HPP.Z,3875] BOOT_RAM_BASE.

 0x0000096600- 0x0000096FFF
  Boot block relocated here before loading the Kernel module,
  [C:/Adam/Opt/Boot/BootDVD.CPP.Z,1] BootDVD & 
[C:/Adam/Opt/Boot/BootHD.CPP.Z,1] BootHD.

 0x0000097000- 0x0000097030
  Multicore start-up vect code, [C:/Kernel/KernelA.HPP.Z,503] MPN_VECT.

~0x000009F000- 0x000009FFFF
  Extended BIOS data area.

 0x00000A0000- 0x00000BFFFF
  VGA graphics mem, marked as write-through cache in
  [C:/Kernel/KGlbls.CPP.Z,29] text.vga_alias.

 0x0000100000- 0x00001835FF
  [C:/Kernel/KernelA.HPP.Z,3463] CSysFixedArea for page tables and misc.  128
  Gig of address space mapped.

 0x0000183600- 0x007FFDFFFF
  Code Heap mem.

             - 0x007FFFFFFF
  Data Heap mem.  (This exists if there is less than 2 Gig of code heap.)

 0x00E0000000- 0x00FFFFFFFF
  32-bit devices could alloc memory at 0xF0000000 going up, but this is
  wrong, 
since some PCs already have devices at 0xF0000000.  No PCI devices are 
supported, so [C:/Kernel/Mem/MemPhysical.CPP.Z,78] Mem32DevAlloc() flaws are
  not an issue.

 0x0080000000-~0x00DFFFFFFF
 0x0100000000-~0x1FFFFFFFFF
  Data Heap mem.  (The physical memory that exists in this range is data 
heap.)

             - 0x1FFFFFFFFF
  64-bit devices are alloced with [C:/Kernel/Mem/MemPhysical.CPP.Z,128]
  Mem64DevAlloc() counting bwd from 128 Gig, 
but no PCI devices are actually supported.
  


* Note: There is a break in the data-heap block pool.  This has no effect 
except the obvious effect that fragmentation has on contiguous requests.  I 
can [C:/Kernel/Mem/MAllocFree.CPP.Z,387] MAlloc() an 8 Gig chunk on my 12 Gig
machine.

* Note: For systems with less than 2 Gig RAM, the code and data heap block 
pools are the same.  For systems with 2-4 Gig of RAM, the code heap is 1/4 of 
the total.  See [C:/Kernel/Mem/BlkPool.CPP.Z,29] BlkPoolsInit().

* See [C:/Kernel/KEnd.CPP.Z,1] Independent HeapCtrl Example.
