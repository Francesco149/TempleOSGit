                                 MultiTasking

TempleOS is a preemptive multitasking operating system.  However, you can 
turn-off preemption on a task by task basis and the task will not yield ctrl 
unless it volunteers with [C:/Kernel/Scheduler.CPP.Z,362] Yield(),
[C:/Kernel/Misc1a.CPP.Z,183] Sleep() or a call to I/O which yields ctrl. 
 Use the [C:/Kernel/Adam1b.HPP.Z,94] Preempt() cmd to turn on or off
preemption.  This is useful when you 
have multiple tasks modifying data structures simultaneously.  Interrupts 
still occur when preemption is off.   

**Preemption is turned-off by default when a task is
[C:/Kernel/Task1a.CPP.Z,230] Spawn()ed.**

The time-slice rate is set by [C:/Kernel/Adam1a.HPP.Z,526] JIFFY_FREQ.

TempleOS does not remove tasks from "the queue" when they are waiting.  They 
swap-in, check for whatever condition they are waiting for and swap-out. 
This 
keeps it simple, but would cause problems if too many tasks existed. 
TempleOS 
is intended for non-server home computers with a maximum of around ten, or
so, 
tasks.  See [C:/Kernel/Scheduler.CPP.Z,1] Scheduler.

TempleOS has no task priority scheme.

Disk requests are not broken into pieces for sharing.  Therefore, if one task 
makes a big request, the drive is locked onto that task until it is done.  
During that time, other tasks can do CPU-only operations, however.


                                  Interrupts

You can turn-on and off interrupts, in your user programs.  This is part of 
the mission statement, giving complete freedom to programmers  Use
[C:/Kernel/Adam1b.HPP.Z,141] Cli() or 
[C:/Kernel/Adam1b.HPP.Z,142] Sti().  TempleOS currently doesn't use interrupt
besides the timer and 
keyboard interrupt.  Since the interrupt flag is part of your task context
and 
since you are voluntarily swapped-out if you call
[C:/Kernel/KbdMouse/Message.CPP.Z,175] GetChar() or whatever, you 
won't even notice if you turn-off interrupts at the cmd prompt because you
are 
being swapped-out and interrupts are being turned-on by the next task.  

I saw no reason to make the hard drive or CD-ROM drive code interrupt driven 
-- it just creates potential compatibility issues.  On a home system, you do 
one thing at a time, mostly.  TempleOS can do multiple things at once, but
not 
as efficiently as a server operating system.  It would bogg down with a 
hundred tasks asking for service.  It sure is simpler, though... smaller... 
simpler to maintain... and understandable by a layman!  The disk code does
not 
break-up requests, if you are curious why one task must wait until another 
finishes an operation.

See [C:/Demo/Lectures/Spinning.CPP.Z,1].
