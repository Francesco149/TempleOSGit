+] Abbreviations
  Abs	Absolute
Acct	Account
Addr	Address
AOT	Ahead-of-Time
AP	Application Processor (CPU# > 0)
Arg	Argument
Attr	Attribute
Aux	Auxilliary
Blk	Block
BSP	Boot-strap Processor (CPU#0)
Buf	Buffer
CB	Call-Back or Code Block
Cfg	Config
Chg	Change
Chk	Check
Const	Consant
Cmd	Command
Cmp	Compiler
Cnt	Count
Ctrl	Control.  The ctrl key is indicated with "^" in documentation.
Cur	Current
Cvt	Convert
Dbg	Debug
Dbl	Double
DC	Device Context
Del	Delete
Desc	Descriptor or Description
Dev	Device
Dft	Default
Dir	Directory, Direction
Doc	Document
Drv	Drive
Dsk	Disk
Dst	Destination
Ed	Edit, Editor
Elem	Element
Evt	Event
Exe	Execute
Ext	Extern or Extended
Feat	Feature
Fmt	Format
Fwd	Forward
fp_	Function ptr
Fun	Function
Gen	Generate
Glbl	Global
Gr	Graphic
IDE	Integrated Drive Electronics, Integrated Development Environment
Ident	Identifier, Identity
IDT	Interrupt Descriptor Table
Init	Initialize
Ins	Insert
Int	Interrupt
ip_	Input Pointer.  See [C:/Kernel/KbdMouse/InputPointer.CPP.Z,1]
  InputPointer.CPP.
Irq	Interrupt (Request)
JIT	Just-in-Time
Kbd	Keyboard
KD	Keyboard Device
Len	Length
Let	Letter
Lex	Lexical Analyser
Loc	Location, Lines of Code
Log	Logarithm or Logical
Lst	List
Man	Manual
Mem	Memory
Mgd	Managed
Mgr	Manager
Mon	Month
MP	MultiProcessor
Msg	Message
Num	Number
Obj	Object
Occ	Occurrence
CMathODE	Ordinary Differential Equation
Paren	Parenthesis
Pix	Pixel
Pkg	Package
Pmt	Prompt
Poly	Polygon
Pos	Position
Prec	Precedence
Prod	Product or Production
Pri	Primary
Prt	Partition
Pt	Point
Ptr	Pointer
Que	Queue
Reg	Register, Registry or Regular
Rem	Remove
Rep	Report
Rqst	Request
Rst	Reset
Rot	Rotation
Rx	Receive
Sec	Second or Secondary
Sect	Sector
Seq	Sequence
Snd	Sound
Src	Source
Srv	Servant
Stat	Status or Statistic
Std	Standard
Stk	Stack
Str	String
Sym	Symbol
Sys	System
Term	Terminal
Tri	Triangle
Tx	Transmit
Val	Value
Var	Variable
Vect	Vector
Vol	Volume
Win	Window
Wiz	Wizard
WS	WordStat
WSD	WordStat Dictionary

+] Task/Process/Thread
  There is no distinction between "task", "process" or "thread."  The Fs
  segment reg is kept pointing to the current task's
  [C:/Kernel/Adam1a.HPP.Z,2879] CTask.  There is only one window per task.

+] Adam Task
  This is Adam, as in Adam and Eve, the parent of all tasks.  This task is
  created at start-up and appears in the small window at the top beneath the
  user windows.  On it's heap are all memory objects which are system wide. 
  When created, it runs the file [C:/Kernel/Adam1.CPP.Z,1]  Normally,
  Adam1.CPP.Z ends by #include [C:/Adam/Adam2.CPP.Z,1] where the remainder of
  the operating system is "#included".  When start-up is finished, the adam
  task enters a server mode where it accepts requests from other tasks.  The
  [C:/Kernel/SrvCmd.CPP.Z,404] Adam("") routine will cause the adam task to
  compile and run text src code.  "#include" statements can be sent to the
  [C:/Kernel/SrvCmd.CPP.Z,404] Adam("") routine, creating system-wide code and
  data which don't disappear when any particular task ends.  (The Adam task is
  immortal.)

+] Seth Task
  This is Seth, as in Adam and Eve's child.  Each CPU core has a special task
  which is immortal and which is special.  The Adam task on CPU#0 is also it's
  Seth task.

+] Code and Data Heaps
  TempleOS uses the asm CALL instruction exclusively and it's limited to
  calling routines +/-2 Gig from the current code location.  To prevent
  out-of-range issues, I decided to separate code and data, placing all code
  within the lowest 2 Gig of memory.  The compiler and
  [C:/Kernel/Hash1b.CPP.Z,386] Load()er allocate memory from the code heap to
  store code and glbl vars, unless the compiler option
  [C:/Kernel/Adam1a.HPP.Z,1474] OPTf_GLBLS_ON_DATA_HEAP is used.  When programs
  call [C:/Kernel/Mem1b.CPP.Z,376] MAlloc() is comes from the data heap, which
  in not limited in size, except by how much physical RAM memory you have.  You
  can allocate from any heap you like, or even make independent heaps.

+] Parent/Child Task
  Often a task will [C:/Kernel/Task1a.CPP.Z,225] Spawn() or
  [C:/Adam/Doc/DocPopUp.CPP.Z,395] PopUp() a task as a helper.  The helper is
  known as a Child Task, though you can Spawn a task and assign it a different
  parent... like Adam.  Links are kept as to who spawned what so when one task
  is [C:/Kernel/Task1a.CPP.Z,28] Kill()ed the helper tasks disappear, too.  You
  can get a report on current system tasks with [C:/Adam/Utils2a.CPP.Z,413]
  TaskRep().  There is just one possible window per task, so child tasks are
  needed.

+] HolyC
  [C:/Doc/HolyC.TXT.Z,1] HolyC is more than C and less than C++.  It has the
  default args of C++ and uses class in place of struct.  It uses
  U0,U8,U16,U32,I64 and I0,I8,I16,I32,I64 for signed and unsigned integers.  It
  has different [C:/Doc/HolyC.TXT.Z,1] operator precedence.  It has PASCAL-like
  function calls with no parens, but requires an "&" when referring to function
  addresses.

+] AOT Compile Mode
  This term to refers to conventional compilation mode.  It is not the
  preferred mode for this operating system and is discouraged.  .PRJ files are
  compiled to .BIN files, skipping .OBJ files.  After compiling, you do a
  [C:/Kernel/Hash1b.CPP.Z,386] Load() cmd which is available by right-clicking
  on a link (like from [C:/Kernel/Dsk/Dsk1b.CPP.Z,243] Dir()).  There is no
  main() routine.  Instead, statements outside functions are automatically
  executed upon loading.  There is no way to unload except by killing the task.
   To invoke AOT Compiled Mode, use the [C:/Compiler/CmpMain.CPP.Z,448] Cmp()
  routine or right-click on a link.  The Kernel modules and compiler are made
  in AOT compiled mode and stored in Kernel.BIN.C and Compiler.BIN.Z,
  respectively.

See [C:/Demo/Games/EagleDive.CPP.Z,1] for an example of an AOT module.

+] JIT Compile Mode
  In just-in-time mode, the compiler allocates objects, code and data, from
  the heap, incrementally.  This mode is used during cmd line operations.  When
  you #include a file, it is compiled function by function and objects are
  placed all over in mem.  The [C:/Compiler/CmpMain.CPP.Z,649] ExeFile()
  routine is the same as #include but can be placed in programs. 
  [C:/Compiler/CmpMain.CPP.Z,640] ExePrint() routine will compile and run a
  string.

+] Compiler Intermediate Code
  The compiler generates instructions one step before making actual assembly
  (machine) language instructions.  This code is reverse polish in nature and
  can be viewed with [C:/Compiler/ICLCC.CPP.Z,21] OTrace().  The compiler does
  not "interpret" code, except in the process of optimization.  The assembly
  language can be viewed when it is compiled with the
  [C:/Compiler/ICLCC.CPP.Z,33] CTrace() routine, or afterward with
  [C:/Compiler/Unassembler.CPP.Z,647] U().

+] Partition/Drive
  There is no distinction between "partition" or "drive."  They are specified
  with a single letter from 'A'-'Z'.

':' is the boot drive.

For commands taking a drive letter as an argument, 0 is the current drive.

[AutoFile,1] AutoFile
[Char/Define,1] Define
[Hash,1] Hash Table
[C:/Adam/Doc/Doc.CPP.Z,37] Editor Link Types
[C:/Doc/RedSea.TXT.Z,1] RedSea File System
[Graphics/Sprite,1] Sprite
+] files_find_mask
  [C:/Kernel/Dsk/DskStr.CPP.Z,40] FilesFindMatch().  An optional directory
  plus a list of filename masks, as in /Demo/*.TXT.Z;*.CPP.Z

See [C:/Kernel/Adam1a.HPP.Z,3454] FUF_RECURSE, [C:/Kernel/Define1a.CPP.Z,112]
  ST_FILE_UTIL_FLAGS, [C:/Kernel/Adam1a.HPP.Z,2089] FILEMASK_TXT,
  [C:/Kernel/Adam1a.HPP.Z,2088] FILEMASK_SRC, [C:/Kernel/Adam1a.HPP.Z,2087]
  FILEMASK_AOT, [C:/Kernel/Adam1a.HPP.Z,2086] FILEMASK_JIT, and
  [C:/Kernel/Adam1a.HPP.Z,2090] FILEMASK_GRA.

+] Filename Extention Types
  
*.???.Z
  These files are automatically compressed or uncompresses files when read or
  written.
*.???.C
  Contiguous files--NOT compressed.
*.TXT.Z;*.TXT;*.LOG.Z;*.LOG
  Text Files
*.CPP.Z;*.CPP
  HolyC src files.  The default HolyC compiler type is ".CPP.Z".
*.PRJ.Z;*.PRJ
  HolyC src files to be compiled AOT.
*.HPP.Z;*.HPP
  HolyC src header files.
*.MAP.Z;*.MAP
  Compiler "map" files
*.BIN.Z;*.BIN.C;*.BIN
  Binary executable files, created by [C:/Compiler/CmpMain.CPP.Z,448] Cmp()
  and read by [C:/Kernel/Hash1b.CPP.Z,386] Load().
*.DAT.Z;*.DAT
  Data files
*.ISO
  CD-ROM image file--ISO9660.
*.AUT.Z;*.AUT
  "AutoFile" Basically a HolyC program who's stdout goes to the input of a
  task when [C:/Kernel/SrvCmd.CPP.Z,484] AutoFile() is called.
*.GRA.Z;*.GRA
  Graphics file

[C:/Kernel/Adam1a.HPP.Z,2089] FILEMASK_TXT
[C:/Kernel/Adam1a.HPP.Z,2088] FILEMASK_SRC
[C:/Kernel/Adam1a.HPP.Z,2087] FILEMASK_AOT
[C:/Kernel/Adam1a.HPP.Z,2086] FILEMASK_JIT
[C:/Kernel/Adam1a.HPP.Z,2090] FILEMASK_GRA

+] Naming Convention
  The following are rules I stick to.  If you work on the operating system,
  it'd be good to stick with them for uniformity, but you can do what you like.
   Since there are no "namespaces" and I don't plan to implement name spaces, I
  highly recommend putting a 2-3 character module code prefix on syms. e.g.
  "WS","Doc","Lex"

ALL_CAPS
  Assembly Language labels are capitalized with underscores between words. 
  So are #define's.

_ALL_CAPS
  Asm routines which are [C:/Doc/HolyC.TXT.Z,1] HolyC callible should have a
  leading underscore.

MixedCaps
  [C:/Doc/HolyC.TXT.Z,1] HolyC Functions and class names are MixedCaps.

lower_case
  Local function vars and glbl vars are lower case.  Class member names are
  also lower_case.

_lower_case
  Function args which are outputs (passed as ptrs) have leading underscores. 
  Also, args which have identically named local variable counterparts have
  leading underscores. 

DOCf_????
  Flags bit nums instead of bit values are designated with a lower case "f".

DOCG_????
  Flag groups are designated with "G".

"result" is reserved for local variables that hold the function return val.

* I used C++ like naming.  I place "New", "Del", "Init", "Rst", ect. on the
  end of a function name instead of at the beginning.  "RstMusicSettings"
  should be "MusicSettingsRst".

+] Fs
  The CPU FS segment reg.  This reg points to the current task's
  [C:/Kernel/Adam1a.HPP.Z,2879] CTask.

+] Gs
  The CPU GS segment reg.  This reg points to the
  [C:/Kernel/Adam1a.HPP.Z,3488] CCPU.

+] Bt,Bts,Btr,Btc,LBts,LBtr,LBtc
  These are bit manipulation functions named after x86 instructions.  They
  stand for "Bit Test", "Bit Test and Set", "Bit Test and Reset" and "Bit Test
  and Compliment".  An 'L' means locked with an ASM lock prefix.

+] Cli,Sti
  Turn on or off interrupts.  They are named after the x86 instructions. 
  "Cli" turns off interrupts.

+] Heap
  Programs can dynamically request chunks of memory allocated from a "heap"
  using [C:/Kernel/Mem1b.CPP.Z,376] MAlloc().  They must
  [C:/Kernel/Mem1b.CPP.Z,370] Free() it when finished.  Ptrs are used to refer
  to it.  The "heap" is dynamically allocated mem.

+] Root
  The base of a binary tree or the head of a queue is the root.  (I don't
  like the word "head.")

+] Join
  When two parts of a program have a common low-level routine, that routine
  is often labeled SomethingJoin.

+] user_data
  Many operating system structures have space set aside for you to store
  values.  You are on your own managing these with multiple applications and
  libraries.

+] BSP/AP
  The "boot-strap processor" is core#0, has the Adam task, and is the master.
   The "application processors" have Seth tasks and are the slave processors. 
  Only the BSP processor's tasks can have windows.

