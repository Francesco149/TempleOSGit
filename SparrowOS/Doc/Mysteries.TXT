This is to clearify how several mysterious things happen in SparrowOS.


* SparrowOS runs in VGA 640x480 16 color graphics mode, not text mode.  It 
changes to this mode with a [::/SparrowOS/OSMain/OSStart.CPP.Z,1] BIOS call
while in real-mode before it switches to 
64-bit mode.  The text is [C:/SparrowOS/Adam/Gr/GrScreen.CPP.Z,628] drawn
manually.  If graphics mode fails, it 
falls-back on text mode.  You can force text mode with an
[::/SparrowOS/OSMain/OSCfg.CPP.Z,1] OSMain config 
option.

* SparrowOS identity-maps all memory, all the time.  There is no "high half" 
memory space.  SparrowOS is ring-0-only, so everything is kernel, even user 
programs.  There is a special task called "Adam" and he doesn't die, so his 
heap never gets freed.  That's as close to "kernel memory" as it gets.

* SparrowOS puts all code in the lowest 2 Gig, so that REL32 addressing can
be 
used.  SparrowOS is 64-bit, but I just thought 2 Gig was enough for code.  It 
actually puts global variables there, too, but you can turn that off with 
[C:/SparrowOS/OSMain/Adam1a.HPP.Z,1474] OPTf_GLBLS_ON_DATA_HEAP. 
[C:/SparrowOS/OSMain/Memory.CPP.Z,956] MAlloc() can allocate any memory, of
course.

* SparrowOS doesn't use software interrupts or SYSCALL instructions because
it 
never needs to change out of ring-0, even running user programs.  Calls are 
always CALL REL32 instructions.

* The stack does not grow.  In theory, memory gets fragmented, too.

* There is no PATH.  You do not enter filenames at the command-line and
expect 
them to run.  You enter C-like code.  [::/SparrowOS/Doc/CmdLine.TXT.Z,1] Get
Started Here.

* If you use [::/SparrowOS/Doc/Grub.TXT.Z,1] Grub, you "chain-load" like
Windows.  You can use the SparrowOS 
boot-loader.  [::/SparrowOS/Adam/Boot/BootMHD.CPP.Z,1]
Master-Boot-Loader-Stage1, [::/SparrowOS/Adam/Boot/BootMHD2.CPP.Z,1]
Master-Boot-Loader-Stage2, 
[::/SparrowOS/Adam/Boot/BootHD.CPP.Z,1] Partition-Boot-Loader,
[::/SparrowOS/Adam/Boot/BootCD.CPP.Z,1] CD-DVD-Boot-Loader.

* The boot-loaders must be patched by you running
[C:/SparrowOS/Adam/Boot/InsBoot.CPP.Z,165] InstallBoot() or 
[C:/SparrowOS/Adam/Boot/InsBoot.CPP.Z,291] InstallMasterBoot().  Those will
write the block address into the boot-loader 
because the boot-loaders do not navigate file systems to find the
[::/SparrowOS/OSMain/OSStart.CPP.Z,1] Stage2 if 
you relocate it.

* The /0000Boot directory and the 0000OSMain.BIN.C file are named so that
they 
are first in alphabetical order and, therefore, at a predictable block 
address.  The [::/SparrowOS/Adam/Boot/BootCD.CPP.Z,1] CD/DVD Boot Loader will
find 0000OSMain.BIN.C at [C:/SparrowOS/Adam/Boot/InsBoot.CPP.Z,30] Block
#0x16.  
The SparrowOS boot loader can be used with http://www.magiciso.com if you 
place 0000OSMain.BIN.C in the right spot.

* SparrowOS is 64-bit.  Like all PC operating systems, the boot-loader starts 
in 16-bit real-mode.  SparrowOS calls a few BIOS info routines, switches to 
VGA-640x480x4bit, switches to 32-bit, then, 64-bit mode.  There is an odd 
thing called a PCI BIOS which is 32-bit used for PCI config space access.  
SparrowOS calls [::/SparrowOS/OSMain/BIOS32.CPP.Z,1] that a couple times.  It
must temporarily drop-out-of 64-bit 
mode for that and stop multi-tasking.

* PUSH EAX : All stack operations in 64-bit mode are 64-bits.

* XOR EAX,EAX : Operations on 32-bit registers clear the high 32-bits.

* MOV RAX,FS:[RAX] : FS can be set with a WRMSR, but displacement is RIP 
relative, so it's tricky to use.  FS is used for the current
[C:/SparrowOS/OSMain/Adam1a.HPP.Z,2864] CTask, GS for 
[C:/SparrowOS/OSMain/Adam1a.HPP.Z,3493] CCPU.

* SparrowOS uses JIT file compression on a file-by-file basis.  Files are 
[::/SparrowOS/OSMain/Compress.CPP.Z,1] compressed, not encrypted.

* SparrowOS has a dictionary that is shipped compressed.  When you boot the 
first time it is uncompressed.  SparrowOS has a Windows utility for 
uncompressing.  That utility needs Microsoft DLL files.  SparrowOS does not 
use any libraries, modules or code from other sources -- I wrote it all from 
scratch and it is self-contained.

* There are no OBJ or EXE files.  There are only two files compiled 
ahead-of-time -- OSMain.BIN.C and Compiler.BIN.Z.  You can delete them and 
recompile with [C:/SparrowOS/Adam/Boot/InsBoot.CPP.Z,165] InstallBoot(). 
SparrowOS is 137,965 lines.  Roughly 50,000 is 
compiled AOT and 50,000 during boot JIT.  The rest is JIT demos and 
applications.

* The main difference between SparrowOS and other systems is that the heap
and 
compiler sym table are associated with tasks, not applications.

* There are sym(hash) tables maintained by each task.  They are similar in 
scope to environment variables.  When a symbol is not found, the parent
task's 
symbol table is checked.  All process chain back to the Adam process.  Adam 
has the symbols from headers you normally #include in other operating
systems, 
so you do not need to #include any headers in SparrowOS.

* The compiler only creates pos independent code.  You can't create code
which 
is loaded at a fixed, specified location.  The code is pos independent by 
virtue of the fact that abs addresses get patched.

* Binary executable files have export syms which are loaded into the sym 
tables.  The operating system OSMain has such an export table.  In addition, 
some map files are processed to provide more information on syms -- src file 
links.  This is how the [C:/SparrowOS/Adam/Doc/DocMain.CPP.Z,588]
Man()/WORDSTAT feature can find src lines.

* The word "public" does very little except allow the
[::/SparrowOS/Doc/HelpIndex.TXT.Z,1] help_index and
[C:/SparrowOS/Adam/Hash2a.CPP.Z,136] HashRep() 
program varients to exclude meaningless syms.  If you wish a full report of 
public and nonpublic syms Click Here
`DocMax(1000000);HAllRep;View;
`
.

* When compilation takes place, the structures used by the compiler stick 
around.  Data on classes can be accessed by code.  See
[C:/SparrowOS/Adam/Dbg2a.CPP.Z,136] ClassRep().

* Filenames ending in ".Z" are automatically compressed and uncompressed when 
writing to disk.  File size in directory listing is the compressed size.  You 
can view uncompressed size with [C:/SparrowOS/OSMain/Dsk/Dsk1b.CPP.Z,233]
Dir("*",TRUE); if you use the native SparrowOS 
filesystem.  See [::/SparrowOS/Doc/TSZ.TXT.Z,1] ::/SparrowOS/Doc/TSZ.TXT.Z
for uncompressing from WINDOWS.

* Some memory objects are allocated when needed and will decrease the 
available memory displayed.  A task keeps mem objects smaller than a couple 
blocks in it's own separate heap when freed and these are not counted in the 
available system free memory, though they are free.  They get returned to the 
system when the task is killed.  To get a sense of this, compile the
operating 
system and see the amount of mem used.  Then, compile it again and far less 
will be allocated.  This is because it is reusing the small chunks.  See 
[Memory,1] Memory.  Click Here
`MemRep;View;`
 for a [C:/SparrowOS/Adam/MemRep.CPP.Z,190] MemRep.

* The cursor location is stored as an ASCII 5 in files.  ASCII 31 is SHIFT-SPA
CE, a character which does not get converted to tabs by space-to-tabs,
[C:/SparrowOS/Adam/S2T.CPP.Z,61] S2T().  
The ASCII 28 is SHIFT-ESC. 

* Binary data is stored beyond the terminating NULL in text files.  Map files 
store debug src lines and other files store sprites.

* Sprites can be stored as vect graphics so they might take shockingly little 
room.  They can be converted to bitmaps.

* If you change code in the /SparrowOS/Adam, /SparrowOS/Adam or your HOME 
directory, you don't need to recompile, you just need to reboot because those 
directories get recompiled when you boot.  It uses JIT compilation.  There is 
no ".BIN" file for JIT compilation.

* If a file is not found, the parent directories are searched for a file of 
the same name.

* SparrowOS supports FAT32 and a native SparrowOS file system type.  The 
native  SparrowOS partitions will appear as FAT32 to other operating systems, 
but will not work.  Do not access the native SparrowOS partitions from other 
operating systems.  This was to fool a bootloader when I tricked it to use 
it's recovery partition feature.

* The CPU usage during disk operation expands to 99%.  It polls while 
swapping-out.  You can do other, non-disk activity during disk operations 
because it swaps-out a lot and task swaps take only half a microsecond, 
probably a hundred times faster than a typical OS.  See 
[::/SparrowOS/Demo/Lectures/Spinning.CPP.Z,1] Cooperative Multitasking.  It
does not break-up disk operations into small 
pieces for sharing, however, so the disk is lock onto that one task.


* "Windows" is a trademark of MicroSoft Corp.
