                                 SparrowOS C+

* See [::/SparrowOS/Doc/ImportExports.TXT.Z,1] Scoping and Linkages for
details on extern, import, _extern, _import, 
etc.

* See [::/SparrowOS/Doc/Directives.TXT.Z,1] ::/SparrowOS/Doc/Directives.TXT.Z.

* Built-in types include I0,I8,I16,I32,I64 for signed 0-8 byte ints and U0,U8,
U16,U32,I64 for unsigned 0-8 byte ints and F64 for 8 byte floats.

	U0	void
	I8	char
	U8	unsigned char
	I16	short
	U16	unsigned short
	I32	int
	U32	unsigned int
	I64	long (64-bit)
	I64	unsigned long (64-bit)
	F64	double
	no F32 float.

* Function with no, or just default args can be called without parentheses. 

* Default args don't have to be on the end.  This code is valid:
  U0 Test(I64 i=4,I64 j,I64 k=5)
{
  PrintF("%X %X %X\n",i,j,k);
}

Test(,3);

* A string or char constant all alone is sent to
[C:/SparrowOS/OSMain/Display.CPP.Z,205] PutS() or
[C:/SparrowOS/OSMain/Display.CPP.Z,200] PutChar().  A 
string with args is sent to [C:/SparrowOS/OSMain/Str1a.CPP.Z,2620] PrintF(). 
 An empty string literal signals a 
variable fmt_str follows.

  U0 Demo1(U8 drv,U8 *fmt,U8 *name,I64 age)
{
  PutS("Hello World!\n");
  PrintF("%s age %d\n",name,age);
  PrintF(fmt,name,age);
  PutChar(drv);
  PutChar('*');
}

U0 Demo2(U8 drv,U8 *fmt,U8 *name,I64 age)
{
  "Hello World!\n";
  "%s age %d\n",name,age;
  "" fmt,name,age;
  '' drv;
  '*';
}

* When dealing with function addresses, precede the name with "&".

* There is no main() function.  Any code outside of functions gets executed
on 
start-up, in order.

* You can access bytes or words within any int.  i.u8[2] returns bits 24-27
in 
the variable, i.  See [C:/SparrowOS/OSMain/Adam1a.HPP.Z,50] I64 declaration. 
The real feature is that a class can 
be accessed as a whole, if you put a type in front of the class declaration.

* Variable arg count functions (...) can access their args with built-in 
variables similar to 'this' in C++.  They are 'I64 argc' and 'I64 argv[]'.  
  
  U0 GrPrintF(CDC *dc,I64 x,I64 y,U8 *fmt,...)
  {
    U8 *buf=SPrintFJoin(NULL,fmt,argc,argv);
    GrPutS(dc,x,y,buf);
    Free(buf);
  }
  
* Allows "5<i<j+1<20" instead of "5<i && i<j+1 && j+1<20".
  
if (13<=age<20)
  "Teen-ager";

* switch statements always use a jump table.  Don't use them with cases with 
really big, sparse ranges.

* Allows ranges like "case 4...7:" in switch statements. 

* nobound_switch can be used if you know a switch statement will not exceed 
the lowest or highest case values.  It's a little faster because it doesn't 
check.

* noreg or reg can be placed before a function local var name.  You can, 
optionally, specify a register after the reg keyword.

* interrupt, public, argpop or noargpop are function flags.

* A nounusedwarn statement will suppress an unused var warning.

* You can have multiple member vars of a class named "pad" or "reserved", and 
it won't issue warnings. 

* Type casting is postfix.  To typecast int or F64, use
[C:/SparrowOS/OSMain/Adam1b.HPP.Z,209] ToI64(),
[C:/SparrowOS/OSMain/Adam1b.HPP.Z,211] ToBool() or 
[C:/SparrowOS/OSMain/Adam1b.HPP.Z,210] ToF64(). (SparrowOS follows normal C
float<-->int conversion, but sometimes 
you want to override.  These functions are better than multiplying by "1.0"
to 
convert to float.) 

* The "`" operator raises a base to a power.

* A single quote can encompass multiple characters.  'ABC' is equal to 0x43424
1.

* SparrowOS [::/SparrowOS/Compiler/CmpInit.CPP.Z,1] operator precedence
  `,>>,<<
  *,/,%
  &
  ^
  |
  +,-
  <,>,<=,>=
  ==,!=
  &&
  ^^
  ||
  :,?
  =,<<=,>>=,*=,/=,&=,|=,^=,+=,-=

* You can use [C:/SparrowOS/Compiler/Directives.CPP.Z,6]
OptOn([C:/SparrowOS/OSMain/Adam1a.HPP.Z,1468] OPTf_WARN_PAREN) to find
unnecessary parentheses in code.

* You can use [C:/SparrowOS/Compiler/Directives.CPP.Z,6]
OptOn([C:/SparrowOS/OSMain/Adam1a.HPP.Z,1469] OPTf_WARN_DUP_TYPES) to find
dup local var type 
statements.

* With the #exe{} feature in your src code, you can place programs that
insert 
text into the stream of code being compiled.  See
[::/SparrowOS/OSMain/OSEnd.CPP.Z,1] #exe {} for an example where 
the date/time and compile-time prompting for cfguration data is placed into a 
program.  The [C:/SparrowOS/Compiler/CmpMain.CPP.Z,14] StreamPrintF() and
[C:/SparrowOS/Compiler/CmpMain.CPP.Z,1] StreamPutS() place text into a src
program 
stream following the conclusion of the #exe{} blk.

* No #define functions exist (I'm not a fan)

* No typedef, use class.

* No type-checking

* Can't use <> with #include, use "".

* "$" is an escape character.  Two dollar signs signify an ordinary $.  See 
[::/SparrowOS/Doc/Dollar.TXT.Z,1] ::/SparrowOS/Doc/Dollar.TXT.Z.  In asm or
C+ code, it also refers to the 
instruction's addr. 

* union is more like a class, so you don't reference it with a union label 
after you define it.  Some common unions are declared in
[C:/SparrowOS/OSMain/Adam1a.HPP.Z,12] Adam1a.HPP.Z for 
1,2,4 and 8 byte objects.  If you place a type in front of a union 
declaration, that is the type when used by itself.  See 
[::/SparrowOS/Demo/SubIntAccess.CPP.Z,1]
::/SparrowOS/Demo/SubIntAccess.CPP.Z. 

* class member vars can have meta data. fmtstr and fmtdata are two meta data 
types now used.  All compiler structures are saved and you can access the 
compiler's info about classes and vars.  See 
[::/SparrowOS/Demo/ClassMeta.CPP.Z,1] ::/SparrowOS/Demo/ClassMeta.CPP.Z and 
[C:/SparrowOS/Adam/Doc/DocPopUp.CPP.Z,295] DocFormDo().

* See [::/SparrowOS/Demo/Exceptions.CPP.Z,1]
::/SparrowOS/Demo/Exceptions.CPP.Z.  try{} catch{} and throw are 
different from C++. throw is a function with var ("...") args.  The values 
passed in throw() can be accessed from within a catch{} using the Fs->except_a
rgc and Fs->except_argv[] vars.  Within a catch {} blk, set the var Fs->catch_
except to TRUE if you want to terminate the search for a handler.  By 
convention, the first arg of except_argv[] specifies the exception type num.  
A list of assigned exception types can be found at
[C:/SparrowOS/OSMain/Adam1a.HPP.Z,2486] EXCEPT_LOCAL.  For a 
handler that will catch all excepts, you can use
[C:/SparrowOS/OSMain/Except.CPP.Z,226] CatchAll().

* A function is available similar to sizeof which provides the offset of a 
member of a class.  It's called offset.  You place the class name and member 
inside as in offset(classname.membername).  It has nothing to do with 16-bit 
code.  Both sizeof and offset only accept one level of member vars.  That is, 
you can't do sizeof(classname.membername.submembername).

* There is no continue statement.  Use goto.

* No bit field support, but there are bit access [Bit,1] library routines.

* lock{} can be used to apply asm LOCK prefixes to code for safe multicore 
read-modify-write accesses.  The code bracked with have LOCK asm prefix's 
applied to relevant instructions within.  It's a little shoddy.  See 
[::/SparrowOS/Demo/MultiCore/Lock.CPP.Z,1]
::/SparrowOS/Demo/MultiCore/Lock.CPP.Z.

* There is a function called [C:/SparrowOS/OSMain/Memory.CPP.Z,951] MSize()
which gives the size of an object 
allocated off the heap.  For larger size allocations, the system rounds-up to 
a power of two, so MSize() lets you know the real size and you can take full 
advantage of it.

* You can [C:/SparrowOS/OSMain/Memory.CPP.Z,950] Free() a NULL ptr.  Useful
variants of [C:/SparrowOS/OSMain/Memory.CPP.Z,956] MAlloc() can be found
[C:/SparrowOS/OSMain/Memory.CPP.Z,963] Here.  
Each task has a heap and you can MAlloc and Free off of other task's heaps,
or 
make an independent heap with [C:/SparrowOS/OSMain/Memory.CPP.Z,1167]
HeapCtrlIndependentInit().

* The stk does not grow because virtual mem is not used.  I recommend 
allocating large local vars from the heap.  You can change
[C:/SparrowOS/OSMain/Adam1a.HPP.Z,2585] DFT_STK and 
recompile OSMain or request more when doing a
[C:/SparrowOS/OSMain/Task1a.CPP.Z,226] Spawn().  You can use 
[C:/SparrowOS/OSMain/Task1a.CPP.Z,89] CallStkGrow(), but it's odd.  See
[::/SparrowOS/Demo/StkGrow.CPP.Z,1] ::/SparrowOS/Demo/StkGrow.CPP.Z. 

* Only one base class is allowed.

* All values are extended to 64-bit when accessed.  Intermediate calculations 
are done with 64-bit values.

  The follow examples should be inserted in a function, so that register 
variables are used.  (Global vars are never register.)

I16 i;
I32 j;
j=i=0x12345678; //Resulting i is 0x5678 but j is 0x12345678

I64 i=0x8000000000000000;
PrintF("%X\n",i>>1);  //Result is 0xC000000000000000 as expected

I64 u=0x8000000000000000;
PrintF("%X\n",u>>1);  //Result is 0x4000000000000000 as expected

I32 i=0x80000000; 	  //constant is loaded into a 64-bit register var.
PrintF("%X\n",i>>1);  //Result is 0x40000000

I32 i=-0x80000000;
PrintF("%X\n",i>>1);  //Result is 0xC0000000 as expected


                                PrintF Family

[C:/SparrowOS/OSMain/Str1a.CPP.Z,2628] MSPrintF() is like
[C:/SparrowOS/OSMain/Str1a.CPP.Z,2312] SPrintF() but it returns a
[C:/SparrowOS/OSMain/Memory.CPP.Z,956] MAllocated str.  It is vary 
handy because you don't have to worry about overflow.

[C:/SparrowOS/OSMain/Display.CPP.Z,205] PutS() doesn't print a new line.

[C:/SparrowOS/OSMain/TaskCmd.CPP.Z,354] Auto(U8 *fmtstr,...) sends text to
the current task's input buffer.
[C:/SparrowOS/OSMain/TaskCmd.CPP.Z,384] AutoStr(U8 *fmtstr,...) sends text of
an [::/SparrowOS/Doc/Glossary.TXT.Z,1] AutoFile to the keyboard stream of 
the current TASK but can also do mouse cmds.

[C:/SparrowOS/OSMain/TaskCmd.CPP.Z,333] XTalk(CTask *task,U8 *fmtstr,...) and
text to another task's input buffer.
[C:/SparrowOS/OSMain/TaskCmd.CPP.Z,409] XTalkStr(CTask *task,U8 *fmtstr,...)
sends text of an [::/SparrowOS/Doc/Glossary.TXT.Z,1] AutoFile to the keyboard 
stream of another TASK but can also do mouse cmds.


[C:/SparrowOS/Adam/Doc/DocPlain.CPP.Z,1111] DocPutS(CDoc *doc,U8 *src) and
[C:/SparrowOS/Adam/Doc/DocPlain.CPP.Z,1267] DocPrintF(CDoc *doc,U8
*fmtstr,...) send text 
to a linked text file.  You can buffer to a Doc and save it, providing the 
functionality of fprintf.  See [::/SparrowOS/Demo/Dsk/FPrintF.CPP.Z,1]
::/SparrowOS/Demo/Dsk/FPrintF.CPP.Z.

[C:/SparrowOS/OSMain/TaskCmd.CPP.Z,286] Adam(U8 *fmtstr,...) send text to the
adam task to be compiled and run.
[C:/SparrowOS/OSMain/TaskCmd.CPP.Z,307] AdamLog(U8 *fmtstr,...) and
[C:/SparrowOS/OSMain/TaskCmd.CPP.Z,319] AdamErr(U8 *fmtstr,...) send text to
the adam task 
to be displayed.

[C:/SparrowOS/Compiler/CmpMain.CPP.Z,14] StreamPrintF(U8 *fmtstr,...) and
[C:/SparrowOS/Compiler/CmpMain.CPP.Z,1] StreamPutS(U8 *src) send text to the
stream 
of code being compiled and must reside in a #exe{} blk.

[C:/SparrowOS/Adam/Gr/GrBitMap.CPP.Z,845] GrPrintF(CDC *dc,I64 x,I64 y,U8
*fmtstr,...) and [C:/SparrowOS/Adam/Gr/GrBitMap.CPP.Z,797] GrPutS(CDC *dc,I64
x,I64 y,U8 
*src) plots text in graphics mode.  [C:/SparrowOS/Adam/Gr/GrBitMap.CPP.Z,852]
GrVPrintF() and [C:/SparrowOS/Adam/Gr/GrBitMap.CPP.Z,820] GrVPutS() will
print 
vertically.

[C:/SparrowOS/Compiler/CmpMain.CPP.Z,555] ExePrintF(U8 *fmtstr,...) and
[C:/SparrowOS/Compiler/CmpMain.CPP.Z,523] ExePutS(U8 *src) compile and
execute a string.  
Note: It returns the result of the last executed expression.

**Note:** If no PutS variant is available, you can use PrintF("%s",src).


The [C:/SparrowOS/OSMain/Str1a.CPP.Z,2620] PrintF() family supports extended
format codes.  See [C:/SparrowOS/OSMain/Str1a.CPP.Z,1594] SPrintFJoin().
  %[-][0][width][.decimals][flags][hsub_fmt][main_fmt]

flags:
    * 't' is a flag which will truncate to field width.
* ',' is a flag which will add commas every three digits in a %d, %f, %g, 
%e and %n entries.
* '$' is a flag which affects the %Q entry, converting '$' to "\044".
* 'k' is a flag which forces 1000 instead of 1024 on integer with sub_fmts
.
  
sub_fmt:
    On date or time entries, the sub_format specifies the format.  See 
[::/SparrowOS/Demo/DateTime.CPP.Z,1] ::/SparrowOS/Demo/DateTime.CPP.Z.

On "%n", "%d" or "%u", the sub_fmt causes thousands mode.
  "%h?n" will pick a var exponent multiples of three unit, while "%h-3n", 
for example, will display milli units or "%h6n" will display mega units.  
The 'k' flag is always on for "%n".  See [::/SparrowOS/Demo/PrintF.CPP.Z,1]
    ::/SparrowOS/Demo/PrintF.CPP.Z.
  
*  "%n" will print a floating point in engineering notation, exponents being 
multiples of three.  If it has a sub_fmt code, it will display scientific 
units letters.

* "%S" will print a Define entry.

* "%C" will print a ToUpper character.

* "%F" will print a text file.

* "%P" will display a PSECT expression which is good for ptrs or addresses.

* "%T" and "%D" will display a date or time and the format is selected with 
a subcode, entered after a "h".  Example: "%20h1D" uses date format code 
"1". See [::/SparrowOS/Demo/DateTime.CPP.Z,1]
  ::/SparrowOS/Demo/DateTime.CPP.Z, [C:/SparrowOS/OSMain/Str1a.CPP.Z,1235]
  MSPrintFDate() and [C:/SparrowOS/OSMain/Str1a.CPP.Z,1144] MSPrintFTime() 
for subcodes.

* "%z" will display a subentry of an enumerated list of text entries. It 
calls [C:/SparrowOS/OSMain/Str1a.CPP.Z,393] ListEntryPt().  Pass entry_num
  first, list second.

* "%Z" will display a Define subentry.  Pass entry_num first, list_systext 
second.

* "%Q" will convert "\" to "\\" and quote to backslash quote. (For use in 
creating strs in strs.)

* "%q" will reverse a "%Q".

