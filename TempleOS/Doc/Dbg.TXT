* You can enter the debugger with [C:/TempleOS/Kernel/Dbg1a.CPP.Z,691] Dbg()
or <CTRL-ALT-D>.  You might enter the 
debugger through a fault.  Enter [C:/TempleOS/Kernel/Dbg1a.CPP.Z,501] G() or
[C:/TempleOS/Kernel/Dbg1a.CPP.Z,527] G2() to continue execution.  Place a 
call to [C:/TempleOS/Kernel/Dbg1a.CPP.Z,691] Dbg() in your code at fatal
error points to enter the debugger.  If 
you see a stk dump, record the label+offset and unassemble,
[C:/TempleOS/Compiler/Unassembler.CPP.Z,866] U().

* I use [C:/TempleOS/Kernel/Adam1b.HPP.Z,43]
progress1-[C:/TempleOS/Kernel/Adam1b.HPP.Z,52] progress4 for debugging
because they show on the wallpaper.  
They're just global integer vars.

* While debugging, you specify addresses of assembly  routines with just the 
label, as in _MALLOC+0x20.  You specify [C:/TempleOS/Doc/HolyC.TXT.Z,1] Holy
C function names with & before 
functions as in &PrintF+0x10.

* You can use [C:/TempleOS/Kernel/TaskCmd.CPP.Z,307] AdamLog() to send text
to the Adam task window.  It works like 
[C:/TempleOS/Kernel/Str1a.CPP.Z,2351] PrintF().  I never use this.  Instead I
use [C:/TempleOS/Kernel/Dbg1a.CPP.Z,187] DbgI64().

* [C:/TempleOS/Kernel/Dbg1a.CPP.Z,271] D()
[C:/TempleOS/Adam/Doc/DocMain.CPP.Z,651] DocD() to do 16 column hex dump mem
with numbering from zero.  With 
[C:/TempleOS/Adam/Doc/DocMain.CPP.Z,651] DocD the values are updated
continually and you can alter mem by editing.

* [C:/TempleOS/Kernel/Dbg1a.CPP.Z,301] Dm()
[C:/TempleOS/Adam/Doc/DocMain.CPP.Z,635] DocDm() to do 16 column hex dump mem
with addresses showing.

* [C:/TempleOS/Kernel/Dbg1a.CPP.Z,307] Da() to do one column address dump
(for stk, etc.) with symbolic addresses.

* [C:/TempleOS/Kernel/Dbg1a.CPP.Z,378] Dr() dumps registers.  You can display
and modify registers in the debugger 
with var-like labels, _RAX, _RBX, etc.

* [C:/TempleOS/Compiler/Unassembler.CPP.Z,866] U(&FunName+offset) to
unassemble mem or [C:/TempleOS/Adam/Dbg2a.CPP.Z,236] Uf("FunName") to
unassemble a 
function.

* [C:/TempleOS/Adam/Profiler.CPP.Z,46]
ProfBin(),[C:/TempleOS/Adam/Profiler.CPP.Z,82] ProfAll() and
[C:/TempleOS/Adam/Profiler.CPP.Z,109] ProfRep() provide code profiling.  See 
[C:/TempleOS/Demo/AutoFile/AFProfile.AUT.Z,1] (This is an
[C:/TempleOS/Doc/Glossary.TXT.Z,1] AutoFile.)

* Use [C:/TempleOS/Kernel/Dbg1a.CPP.Z,187] DbgI64(),
[C:/TempleOS/Kernel/Dbg1a.CPP.Z,168] DbgStr() and
[C:/TempleOS/Kernel/Dbg1a.CPP.Z,221] DbgAdd() to print debug info bypassing
the window 
framework.  You pass these routines a count in milliseconds for how long it 
should be displayed.  You can use [C:/TempleOS/Kernel/Misc1a.CPP.Z,282]
Raw(TRUE) to make all output bypass the 
window framework.  The WinMgr runs on core0 and will overwrite raw text from 
other cores when it updates the screen.

* Use [C:/TempleOS/Kernel/Misc1a.CPP.Z,263] SysDbg() to set a flag which you
can read with [C:/TempleOS/Kernel/Misc1a.CPP.Z,269] IsSysDbg() when you wish 
to trigger some debug activity.  It's just a handy simple flag, nothing fancy.

* Use [C:/TempleOS/Kernel/Misc1a.CPP.Z,273] SysDeterministic() to set a flag
which tries to keep the system 
deterministic for debugging.  [C:/TempleOS/Kernel/Misc1a.CPP.Z,278]
IsSysDeterministic().  There is a Deterministic 
Kernel config flag.

* There are flags for various trace options that can help debugging when
there 
are compiler bugs.  Often, you place them in #exe{} blocks.
  
[C:/TempleOS/Compiler/Directives.CPP.Z,48] Echo() turns on or off raw data
  going into the lexical analyzer.

[C:/TempleOS/Compiler/Directives.CPP.Z,43] LTrace() shows the tokens coming
  out of the lexical analyzer.

[C:/TempleOS/Compiler/Directives.CPP.Z,38] CTrace() unassembles code
  generated from the Holy C compiler.

[C:/TempleOS/Compiler/Directives.CPP.Z,21] PTrace() shows intermediate code
  comming out of the first stage of the 
compiler (it's not 100% valid because it hasn't been fixed-up).

[C:/TempleOS/Compiler/Directives.CPP.Z,26] OTrace() shows intermediate code
  coming-out after optimization.  
[C:/TempleOS/Compiler/Directives.CPP.Z,31] OPassTraceMask() ctrls which
  passes are displayed.


* There is a heap check utility which can find leaks.  Use
[C:/TempleOS/Adam/HeapLog.CPP.Z,121] HeapLog(), and 
[C:/TempleOS/Adam/HeapLog.CPP.Z,80] HeapLogRep().  It's a really simple
program which intercepts [C:/TempleOS/Kernel/Memory.CPP.Z,956] MAlloc() and 
[C:/TempleOS/Kernel/Memory.CPP.Z,950] Free().  You can customize the code to
find other heap issues.

* You can define functions for <CTRL-ALT-letter> keys, but they must operate 
in a interrupt environment or in the window mgr when in ques kbd msgs.  You 
can do [C:/TempleOS/Kernel/Misc1a.CPP.Z,282] Raw() output.  Search for
[C:/TempleOS/Kernel/KGlbls.CPP.Z,51] fp_ctrl_alt_let_cbs[] and look at the
code.  
They take scancode as an arg.

* If you recompile Kernel with [C:/TempleOS/Adam/Boot/InsBoot.CPP.Z,128]
MakeOSInstallPrtBootLoader(), you can set the M
emInit, option to initialize memory to a value at boot, the HeapInit option
to 
cause mem allocated off the heap to be initialized or VarInit option so both 
global and local vars will be initialized to a value.  Pick a non-zero value 
to discover uninitialized var bugs.  You can set
[C:/TempleOS/Kernel/Adam1b.HPP.Z,129] sys_var_init_flag, and 
[C:/TempleOS/Kernel/Adam1b.HPP.Z,125] sys_heap_init_flag directly after
booting.  You can also use the ProtectLow 
option to discover NULL dereferences.
