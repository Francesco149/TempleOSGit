I didn't want to use paged memory mode, but 64-bit mode requires it.  For all 
intents and purposes, virtual mem (paging) is not used.  TempleOS identity 
maps pages to physical memory.  All cores use the same page table map.  Page 
table entries have a granularity of 2 Meg, except the first 2 Meg.  It does 
not swap to disk.

TempleOS always uses 32-bit signed relative jump/call instructions.  It is a 
signed +/- value, so if one part of your code calls a function, the function 
must be within 2 Gig distance.  Therefore, TempleOS keeps all code in the 
lowest 2 Gig memory addresses including what would normally be called "the 
kernel."  This lowest 2 Gig I call the "code heap".

You can create new independent heaps by first allocating mem with 
[C:/TempleOS/Kernel/Memory.CPP.Z,428] MemBlksUncachedAlloc() or
[C:/TempleOS/Kernel/Memory.CPP.Z,215] MemBlksNonTaskAlloc(), then calling 
[C:/TempleOS/Kernel/Memory.CPP.Z,1167] HeapCtrlIndependentInit() and, then,
using [C:/TempleOS/Kernel/Memory.CPP.Z,956] MAlloc().

Memory allocated by a task will be freed when the task is killed.

Eventually, memory will become fragmented, requiring a reboot.

See [C:/TempleOS/Adam/MemRep.CPP.Z,192] MemRep().

                          Single System-wide Mem Map

 0x0000007C00- 0x000003E2BF
  Kernel module, placed here by the boot-loader,
  [C:/TempleOS/Kernel/BootDefs.HPP.Z,6] BOOT_RAM_BASE.

 0x000007F000- 0x000007F02E
  Multicore start-up vect code, [C:/TempleOS/Kernel/Adam1a.HPP.Z,576]
  MPN_VECT.

 0x000007F600- 0x000007FFFF
  Boot block relocated here before loading the Kernel module,
  [C:/TempleOS/Adam/Boot/BootCD.CPP.Z,1] BootCD &
  [C:/TempleOS/Adam/Boot/BootHD.CPP.Z,1] BootHD.

~0x000009F000- 0x000009FFFF
  Extended BIOS data area.

 0x00000A0000- 0x00000BFFFF
  VGA graphics mem, marked as write-through cache.

 0x0000100000- 0x0000182FFF
  Page tables, 128 Gig of space

 0x0000183000- 0x007FFFFFFF
  Code Heap mem.

 0x00E0000000- 0x00FFFFFFFF
  Various hardware devices have addresses here.  32-bit devices are allocated 
memory starting at 0xF0000000 going up.

 0x0080000000-~0x00DFFFFFFF
 0x0100000000-~0x1FFFFFFFFF
  Data Heap mem.

             - 0x1FFFFFFFFF
  64-bit devices are mapped counting backward from 128 Gig.
  

                                      [C:/TempleOS/Kernel/Adam1a.HPP.Z,2719] CBlkPools [C:/TempleOS/Kernel/Adam1a.HPP.Z,2735] CHeapCtrls
 <1> (image)

0000,0000,0000,0000                   Core 0   

0000,0000,0000,7C00 Kernel
0000,0000,0003,E2BF 

0000,0000,0010,0000 Page_Tables                    AdamTask

0000,0000,0018,3000

                    sys_code_bp

                                                   Task




                                      Core 1
                                                   SethTask

0000,0000,7FFF,FFFF                     
0000,0000,8000,0000

                                        

                    sys_data_bp
                                                   Task
0000,0000,DFFF,FFFF 
0000,0000,F000,0000 32-bit devices

0000,0001,0000,0000
                                        
                                                   SethTask 

                                       


                    sys_data_bp       Core n 




                                      Independent  




                    64-bit devices

0000,001F,FFFF,FFFF

* Note: There is a break in the data-heap block pool.  This has no effect 
except the obvious effect that fragmentation has on contiguous requests.  I 
can [C:/TempleOS/Kernel/Memory.CPP.Z,956] MAlloc() an 8 Gig chunk on my 12
Gig machine.

* Note: For systems with less than 2 Gig RAM, the code and data heap block 
pools are the same.  For systems with 2-4 Gig of RAM, the code heap is 1/4 of 
the total.  See [C:/TempleOS/Kernel/Memory.CPP.Z,1371] HeapsInit().

* See [C:/TempleOS/Kernel/KEnd.CPP.Z,1] Independent Heap Ctrl Example.

