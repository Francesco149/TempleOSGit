                          Strategic Decisions Making
                               TempleOS Simple

The trivial solution in math is the simple, obvious answer.  TempleOS has
many 
examples of using trivial solutions.

* Everything runs in kernel, ring 0, mode.

* One memory map for all tasks on all cores with virtual addresses set equal 
to physical.

* One platform -- x86_64 PC's, no 32-bit support.

* No security.

* No networking.

* Least (greatest) common denominator hardware support.  Mostly, one driver 
for each device class.  I can't be in the business of different drivers.  
Compatibility is the greatest challenge for PC operating systems.  Disk code 
does not use interrupts, avoiding compatibility risks.  PS/2 keyboard/mouse
is 
used instead of USB, also more compatible.

* 640x480 16 colors.  Updates whole screen at 60 fps, optimized for full 
screen games where "invalid rectangles" are counter-productive.

* One font, 8x8.  Text and graphic layers done in software with text normally 
on an 8x8 grid.  It can run in Text mode if graphic initialization fails.

* Compiler extends all values to 64-bit when fetched and does only 64-bit 
computations intermediately.  Assembler has minimal 16-bit support, good 
enough for compiling boot loaders.

* No object files.  Linking can be done at
[C:/TempleOS/Kernel/Hash1a.CPP.Z,735] Load() time for AOT modules, if you 
insist on not using JIT.  Modules have imports and exports.

* Whole files are processed almost exclusively, allowing compression.

* One language and compiler for command-line, scripts, and code.

* One editor/word processor/browser for the command-line window, source code, 
documentation browser, dialog forms.

* No child windows.  One window per task.  Buttons are widgets, not child 
windows.  There are child tasks, however.

* No distinction between "thread", "process" or "task".

* The [C:/TempleOS/Kernel/Scheduler.CPP.Z,1] Scheduler is mostly for home
systems, not servers or mainframes.  The 
focus task is all important.  Disk requests are not broken-up, so sharing is 
bad, however.

* [C:/TempleOS/Doc/MultiCore.TXT.Z,1] MultiCore is done master/slave, instead
of SMP.  Core zero explicitly 
assigns jobs.  Locks are present allowing multicore file, heap, and hardware 
access, though.

* [C:/TempleOS/Adam/Snd/Music.CPP.Z,104] Music is done with an elegant
one-voice notation.

* All tasks have a heap and a sym table.  Scope is that of environment vars
in 
other operating systems.  As text is typed at the command line or you run 
programs by #includeing them, the syms go in the table.  If a sym is not 
found, the parent task's table is checked.  The father of all tasks has the 
API syms you'll need waiting in it's table.  No need to #include headers.

* No need for namespaces -- scoping occurs automatically based on task symbol 
table hierarchy with the Adam task's symbol system-wide global.

* Sometimes, I [C:/TempleOS/Doc/CutCorners.TXT.Z,1] cut corners in the
interest of keeping the code beautiful.


