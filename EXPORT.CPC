//This is NOT Terry's work. I wrote this program to export historical
//versions of TempleOS to git.
//The goal is to obtain something easily browsable in a normal text editor
//and easy to diff in git while not loosing too much information. Docs are
//converted to plaintext but retain links and a few decorations, binary data
//is embedded as hex strings in code and dumped to a BIC file for docs.
//As an added bonus, I try to match each iteration's coding style.
//This code is public domain.

//Just in case the filesystem gets corrupted while I develop it
void BackupExport() {
  Copy("D:/EXPORT.CPC","C:/EXPORT.CPC");
  Copy("D:/EXPORT.CPC","D:/EXPORTB.CPC");
  Copy("D:/EXPORT.CPC","C:/J/ACCOUNTS/TAD/EXPORT.CPC");
}

BackupExport;

#define EXPORT_W 78

void ExportBinary(char *src_file,LtfBinEntry *b) {
  DWORD len;
  char *buf,*buf1;

  len=StrLen(src_file);
  buf1=MAlloc(len+1);
  StrCpy(buf1,src_file);
  buf=buf1+len-1;
  while (buf>buf1 && *buf!='.')
    buf--;
  *buf=0;
//NOTE: filenames are limited to 8 characters and it can cause problems here
  if (b->num<10)
    buf=MSPrintF("%s%d.DAC",buf1,b->num);
  else if (b->num<'Z'-'A'+1)
    buf=MSPrintF("%s%c.DAC",buf1,'A'+b->num);
  else
    buf=MSPrintF("%s%d.DAC",buf1,b->num);
  Free(buf1);
  PrintF("%s\r\n",buf);
  WriteFile(buf,b->data,b->size);
  Free(buf);
}

char *ResolveLink(char *filename)
{ //Adapted from [T:/J/ROOT/EDIT.CPZ,2764] Edit. Resolves stuff like MN:Func to the file
  char *buf;
  int i;
  SysHashEntry *temph;

  if (StrLen(filename)>3 && filename[2]==':') {
    buf=NewString(filename);
    buf[2]=0;
    i=MatchSysTextEntry(buf,"ST_LINK_TYPES",MLE_IGNORE_CASE);
    if (i==LK_MAN_PAGE) {
      temph=FindLocalHash(filename+3,
        HTT_GLBL_VAR|HTT_CLASS|HTT_FUNCTION|HTT_STRING_CONSTANT);
      if (temph)
        return ResolveLink(temph->source_link);
    }
    Free(buf);
    return filename+3;
  }
  return filename;
}

char *IndentString(int n) {
  char *s=MAlloc(n+1);
  MemSet(s,' ',n);
  s[n]=0;
  return s;
}

char *Wrap(char *base,char *s,int *line_len,int indent=0,BOOL debug=FALSE)
{ //Performs word wrapping on base, starting from s, line_len is state.
  //Also adds indent spaces to every soft and hard newline.
  //Returns new value for base.
  //This is supposed to also take tabs into account but fuck that shit
  int len,i;
  char *p,*buf;
  char *end;
  char *lbstring;
  int lbstring_len;

  if (debug)
    lbstring=NewString("\r\n");
  else
    lbstring=NewString("\n");
  for (i=0;i<indent;i++)
    lbstring=Add2String(lbstring," ");
  lbstring_len=StrLen(lbstring);

  s-=*line_len;
  end=s+EXPORT_W;
  for (p=s;*p && p<end;p++) {
    if (*p=='\n') {
      buf=NewString(p+1);
      if(p>s && *(p-1)=='\r')
        p--;
      *p=0;
      len=p-base;
      base=Add2String(base,lbstring);
      base=Add2String(base,buf);
      Free(buf);
      p=base+len+lbstring_len-1;
      s=p+1;
      *line_len=0;
      end=s+EXPORT_W;
    }
  }
  while (StrLen(s)>EXPORT_W) {
    for (p=s+EXPORT_W-1;p>s;p--) {
      if (*p==' ')
        break;
    }
    if (*p!=' ') {
//Truncate words longer than a line
      while (StrLen(s)>EXPORT_W) {
        buf=NewString(s+EXPORT_W);
        s[EXPORT_W]=0;
        len=s-base;
        base=Add2String(base,lbstring);
        base=Add2String(base,buf);
        Free(buf);
        s=base+len+EXPORT_W+lbstring_len;
        *line_len=0;
      }
      break;
    }
    buf=NewString(p+1);
    *p=0;
    len=p-base;
    base=Add2String(base,lbstring);
    base=Add2String(base,buf);
    Free(buf);
    *line_len=0;
    s=base+len+lbstring_len;
  }
  *line_len=StrLen(s);
  Free(lbstring);
  return base;
}

//All these string operations are crazy slow because I don't preallocate mem
//but it's good enough for now.
//This whole thing should've been designed to do one big allocation and be
//done with it but it's too late now.

void ExportSingle(char *in_path,char *out_path,BOOL debug=FALSE)
{
  Ltf *l;
  LtfEntry *cl;
  LtfBinEntry *b;
  char *out,*buf;
  DWORD len,olen,i,flags;
  BOOL is_code;
  int indent=0,line_len=0,prev_len=0;
  char *indents=NewString("");

  buf=out_path+StrLen(out_path)-1;
//The C suffix means contiguous, uncompressed
  *buf='C';
  while (buf>out_path && *buf!='.') buf--;
  buf++;

  if (!StrCmp(buf,"BIC") || !StrCmp(buf,"DAC")) {
    buf=ReadFile(in_path,&len);
    WriteFile(out_path,buf,len);
    Free(buf);
    return;
  }

  l=LtfRead(in_path);
  if (!l) {
    buf=ReadFile(in_path,&len);
    WriteFile(out_path,buf,len);
    Free(buf);
    return;
  }

  is_code=(!StrCmp(buf,"CPC") || !StrCmp(buf,"HPC") || !StrCmp(buf,"AUC"));

  out=NewString("");
  for (b=l->bin_root.next;b!=&l->bin_root;b=b->next) {
    if (is_code) {
      buf=MSPrintF("%s#define __BIN_%d_TYPE 0x%08X
#define __BIN_%d_SIZE 0x%08X
#define __BIN_%d \"",out,b->num,b->type,b->num,b->size,b->num);
      Free(out); out=buf;
      olen=StrLen(out);
      len=olen+b->size<<2;
      buf=MAlloc(len+1);
      StrCpy(buf,out);
      Free(out); out=buf;
      buf+=olen;
      for (i=0;i<b->size;i++)
        SPrintF(buf+i<<2,"\\x%02X",b->data[i]);
      out=Add2String(out,"\"\r\n");
    } else if (StrCmp(buf,"MPC"))
      ExportBinary(out_path,b);
//MP files are symbol maps and the binary data is just debug info (line nums)
//so there's no need to create hundreds of bin files just for the line nums
  }
  if (*out)
    out=Add2String(out,"\r\n");
  for (cl=l->dummy.next;cl!=l;cl=cl->next) {
    switch (cl->btype) {
      case LTFT_ERROR:
      case LTFT_TEXT:
      case LTFT_ANCHOR:
      case LTFT_TREE: //Trees text includes the +] at the beginning
        if (!cl->display)
          break;
        if (cl->flags & LTFLF_CENTER_X)
          buf=IndentString((EXPORT_W-StrLen(cl->display))/2);
        else if (cl->flags & LTFLF_RIGHT_X)
          buf=IndentString(EXPORT_W-StrLen(cl->display));
        else
          buf=NULL;
        if (buf) {
//This should actually go back to the beginning of the line but having text
//before a justify tag actually breaks even in J OS itself so I assume there's
//no invalid usage anywhere
          out=Add2String(out,buf);
          Free(buf);
        }
        if (debug) {
//CL breaks everything and the file is truncated when you open it
          len=StrLen(out);
          out=Add2String(out,cl->display);
          for (buf=out+len;*buf;buf++) {
            if (*buf=='$') *buf='_';
          }
        } else
          out=Add2String(out,cl->display);
        break;
      case LTFT_INSERT_BINARY_TYPE:
        if (is_code)
          buf=MSPrintF("%s__BIN_%d_TYPE",out,cl->bin_data->num);
        else
          buf=MSPrintF("%s%d",out,cl->bin_data->type);
        Free(out); out=buf;
        break;
      case LTFT_INSERT_BINARY_SIZE:
        if (is_code)
          buf=MSPrintF("%s__BIN_%d_SIZE",out,cl->bin_data->num);
        else
          buf=MSPrintF("%s%d",out,cl->bin_data->size);
        Free(out); out=buf;
        break;
      case LTFT_INSERT_BINARY:
        if (is_code) {
          buf=MSPrintF("%s__BIN_%d",out,cl->bin_data->num);
          Free(out); out=buf;
        } else
          out=Add2String(out,"(binary data)");
        break;
      case LTFT_PICTURE:
        if (is_code)
          buf=MSPrintF("%s/* %s <%d> (image) */",
            out,cl->display,cl->bin_data->num);
        else
          buf=MSPrintF("%s%s <%d> (image)",out,cl->display,
            cl->bin_data->num);
        Free(out); out=buf;
        break;
      case LTFT_MACRO:
        if (cl->display)
          out=Add2String(out,cl->display);
        else
          out=Add2String(out,"(macro)");
        out=Add2String(out,"\r\n");
        if (cl->flags & LTFLF_RIGHT_MACRO) {
          buf=MSPrintF("%s`%s`\r\n",out,cl->right_macro);
          Free(out); out=buf;
        }
        if (cl->flags & LTFLF_LEFT_MACRO) {
          buf=MSPrintF("%s`%s`\r\n",out,cl->left_macro);
          Free(out); out=buf;
        }
        break;
      case LTFT_LINK:
        if (cl->aux_string)
          buf=MSPrintF("%s[%s] %s",out,ResolveLink(cl->aux_string),
            cl->display);
        else
          buf=MSPrintF("%s[%s]",out,ResolveLink(cl->display));
        Free(out); out=buf;
        break;
      case LTFT_CR:
      case LTFT_SOFT_CR:
        if (debug) {
          out=Add2String(out,"\r\n");
          prev_len+=2;
        } else {
          out=Add2String(out,"\n");
          prev_len++;
        }
        if (!(flags & LTFLF2_WORD_WRAP)) {
          line_len=indent;
          out=Add2String(out,indents);
        } else
          line_len=0; //Wrap will take care of it
        break;
      case LTFT_TAB:
        out=Add2String(out,"\t");
        break;
      case LTFT_BLINK:
        out=Add2String(out,"**");
        break;
      case LTFT_UNDERLINED:
        out=Add2String(out,"_");
        break;
      case LTFT_HIDE_START:
        out=Add2String(out,"<-");
        break;
      case LTFT_HIDE_END:
        out=Add2String(out,">");
        break;
      case LTFT_WORD_WRAP:
//Not sure which is the right flag to check but this works
        flags&=(~LTFLF2_WORD_WRAP);
        flags|=(cl->flags2 & LTFLF2_WORD_WRAP);
        if ((l->flags|cl->flags) & LTFF_WORD_WRAP)
          flags|=LTFLF2_WORD_WRAP;
        break;
      case LTFT_INDENT:
        indent+=cl->attr;
//This is tricky - an indent tag effectively moves the following text, even
//if there's something before it, so if you have foo$ID,2$bar it will display
//as fbar. to handle this I'm just gonna go back to the beginning of the line
//and overwrite. Not quite the same behaviour but close enough.
//We also need to re-wrap the line.
        for (buf=out+StrLen(out)-1;*buf>out && *buf!='\n';buf--)
          line_len++;
        buf[1]=0;
        Free(indents); indents=IndentString(indent);
        out=Add2String(out,indents);
        break;
      case LTFT_FOREGROUND_COLOR:
      case LTFT_BACKGROUND_COLOR:
      case LTFT_LINK_FOREGROUND:
      case LTFT_LINK_BACKGROUND:
      case LTFT_MACRO_FOREGROUND:
      case LTFT_MACRO_BACKGROUND:
      case LTFT_TREE_FOREGROUND:
      case LTFT_LEFT_MARGIN:
      case LTFT_RIGHT_MARGIN:
      case LTFT_CURSOR_MOVEMENT:
      case LTFT_SHIFTED_X:
      case LTFT_SHIFTED_Y:
      case LTFT_CURSOR:
      case LTFT_INVERTED:
      case LTFT_HEADER:
      case LTFT_FOOTER:
      case LTFT_PAGE_BREAK:
        break;
      default:
        buf=MSPrintF("%s /* Unknown token: %d */ ",out,cl->btype);
        Free(out); out=buf;
        PrintF("Unknown token: %d\r\n",cl->btype);
        break;
    }
    if (flags & LTFLF2_WORD_WRAP)
      out=Wrap(out,out+prev_len,&line_len,indent,debug);
    prev_len=StrLen(out);
  }
//Terry uses a mix of tabs and spaces all over the place and converting tabs
//to 8 spaces is not good enough because some formatting relies on tabs align
//so I'm just gonna leave it
  WriteFile(out_path,out,StrLen(out));
  Free(out);
  LtfDel(l);
  Free(indents);
}

void PutExportTree(JDirEntry *ent,BOOL debug=FALSE)
{
  JDirEntry *next_ent;
  while (ent) {
//user_data comes from [T:/J/ROOT/DISK10.CPZ,120] GetCopyTree
    PrintF("%s\r\n",ent->user_data);
    next_ent=ent->next;
    if (ent->attr & J_ATTR_DIR) {
      MkDir(ent->user_data);
      if (ent->sub)
        PutExportTree(ent->sub,debug);
    } else
      ExportSingle(ent->full_name,ent->user_data,debug);
    Free(ent->user_data);
    DelJDirEntry(ent);
    ent=next_ent;
  }
}

void ExportTreeImpl(char *src_mask="T:/*",char *dst_mask="D:/GIT",
  BOOL debug=FALSE)
{
  JFileAccess *fa;
  JDirEntry *ent;
  DWORD flags=(1<<FUf_RECURSE);

  fa=NewJFileAccess(src_mask);
  if (fa) {
    ent=FindFiles(fa->mask,&flags);
//I borrowed this from [T:/J/ROOT/DISK10.CPZ,136] CopyTree's internals
    GetCopyTree(ent,".");
    DelJFileAccess(fa);
  }
  fa=NewJFileAccess(dst_mask,TRUE,TRUE);
  if (fa) {
    PutExportTree(ent,debug);
    DelJFileAccess(fa);
  }
}

//This is pretty neat - instead of hogging the current window and making it
//change dir, we spawn a new terminal and programmatically send keystrokes
//to start the export.

void ExportTree() {
  TssStruct *tss=Spawn(&UserCmdLine);
  XTalk(tss,"#include \"D:/EXPORT.CPC\"
ExportTreeImpl;
ExportSingle(\"D:/EXPORT.CPC\",\"D:/GIT/EXPORT.CPC\");
");
  WindowToTop(tss);
}
